parser grammar SoalParser;

options {
	tokenVocab=SoalLexer;
	generateCompiler=true;
	generateCompilerBase=true;
}

$RootScope(Namespace)
main : $Property(Declarations) namespaceDeclaration* EOF;

$Name
name : identifier;

$Name
qualifiedName : qualifier;

$Qualifier
qualifier : identifier (TDot identifier)*;
identifierList : identifier (TComma identifier)*;
qualifierList : qualifier (TComma qualifier)*;

annotationList : annotation+;

returnAnnotationList : returnAnnotation+;

$Property(Annotations)
$Symbol(Annotation)
annotation : TOpenBracket annotationHead TCloseBracket;

$Property(Annotations)
$Symbol(Annotation)
returnAnnotation : TOpenBracket KReturn TColon annotationHead TCloseBracket;

annotationHead : $Property(Name) $Value identifier annotationBody?;

$Body
annotationBody : TOpenParen annotationPropertyList? TCloseParen;

annotationPropertyList : annotationProperty (TComma annotationProperty)*;

$Property(Properties)
$Symbol(AnnotationProperty)
annotationProperty : $Property(Name) $Value identifier TAssign $Property(Value) annotationPropertyValue;

annotationPropertyValue
	: constantValue
	| typeofValue
	;

$NameDef(symbolType=Namespace,nestingProperty=Declarations,merge=true)
namespaceDeclaration : annotationList? KNamespace qualifiedName TAssign ($Property(Prefix) $Value identifier TColon)? $Property(Uri) $Value stringLiteral namespaceBody;

$Body 
namespaceBody : TOpenBrace declaration* TCloseBrace;

$Property(Declarations)
declaration : enumDeclaration | structDeclaration | databaseDeclaration | interfaceDeclaration | componentDeclaration | compositeDeclaration | assemblyDeclaration | bindingDeclaration | endpointDeclaration | deploymentDeclaration;

// Enums

$TypeDef(Enum)
enumDeclaration : annotationList? KEnum name (TColon $Property(BaseType) $TypeUse(symbolType=Enum) qualifier)? enumBody;

$Body
enumBody: TOpenBrace enumLiterals? TCloseBrace;
enumLiterals : enumLiteral (TComma enumLiteral)* TComma?;

$Property(EnumLiterals)
$NameDef(EnumLiteral)
enumLiteral : annotationList? name;

// Structs and exceptions

$TypeDef(Struct)
structDeclaration : annotationList? KStruct name (TColon $Property(BaseType) $TypeUse(symbolType=Struct) qualifier)? structBody;

$Body
structBody : TOpenBrace propertyDeclaration* TCloseBrace;

$Property(Properties)
$NameDef(Property)
propertyDeclaration : annotationList? $Property(Type) typeReference name TSemicolon;


// Database

$TypeDef(Database)
databaseDeclaration : annotationList? KDatabase name databaseBody;

$Body
databaseBody : TOpenBrace entityReference* operationDeclaration* TCloseBrace;

$Property(Entities)
entityReference : KEntity $TypeUse(Struct) qualifier TSemicolon;


// Interface

$TypeDef(Interface)
interfaceDeclaration : annotationList? KInterface name interfaceBody;

$Body
interfaceBody : TOpenBrace operationDeclaration* TCloseBrace;

$Property(Operations)
$NameDef(Operation)
operationDeclaration : operationHead TSemicolon;

operationHead : annotationList? operationResult name TOpenParen parameterList? TCloseParen (KThrows $Property(Exceptions) $TypeUse(Struct) qualifierList)?;

parameterList : parameter (TComma parameter)*;

$Property(Parameters)
$NameDef(InputParameter)
parameter : annotationList? $Property(Type) typeReference name;

$Property(Result)
$Symbol(OutputParameter)
operationResult : returnAnnotationList? operationReturnType;

// Component

$TypeDef(Component)
componentDeclaration : $Property(name=IsAbstract,value=true) KAbstract? KComponent name (TColon $Property(BaseComponent) $TypeUse(symbolType=Component) qualifier)? componentBody;

$Body
componentBody : TOpenBrace componentElements? TCloseBrace;

componentElements : componentElement+;

componentElement
	: componentService
	| componentReference
	| componentProperty
	| componentImplementation
	| componentLanguage
	;

$Property(Services)
$NameDef(Service)
componentService : KService $Property(Interface) $TypeUse(Interface) qualifier name? componentServiceOrReferenceBody;
$Property(References)
$NameDef(Reference)
componentReference : KReference $Property(Interface) $TypeUse(Interface) qualifier name? componentServiceOrReferenceBody;

$Body
componentServiceOrReferenceBody 
	: TSemicolon #componentServiceOrReferenceEmptyBody
	| TOpenBrace componentServiceOrReferenceElement* TCloseBrace #componentServiceOrReferenceNonEmptyBody;

componentServiceOrReferenceElement
	: KBinding $Property(Binding) $NameUse(Binding) qualifier TSemicolon;

$Property(Properties)
$NameDef(Property)
componentProperty : typeReference name TSemicolon;

$Property(Implementation)
$NameDef(Implementation)
componentImplementation : KImplementation name TSemicolon;

$Property(Language)
$NameDef(Language)
componentLanguage : KLanguage name TSemicolon;

$TypeDef(Composite)
compositeDeclaration : KComposite name (TColon $Property(BaseComponent) $TypeUse(symbolTypes=(Component,Composite)) qualifier)? compositeBody;

$Body
compositeBody : TOpenBrace compositeElements? TCloseBrace;

$TypeDef(Assembly)
assemblyDeclaration : KAssembly name (TColon $Property(BaseComponent) $TypeUse(symbolTypes=(Component,Composite)) qualifier)? compositeBody;

compositeElements : compositeElement+;

compositeElement
	: componentService
	| componentReference
	| componentProperty
	| componentImplementation
	| componentLanguage
	| compositeComponent
	| compositeWire
	;

$Property(Components)
compositeComponent : KComponent $NameUse(Component) qualifier TSemicolon;

$Property(Wires)
$Symbol(Wire)
compositeWire : KWire wireSource KTo wireTarget TSemicolon;

wireSource : $Property(Source) $NameUse(Port) qualifier;
wireTarget : $Property(Target) $NameUse(Port) qualifier;

$NameDef(Deployment)
deploymentDeclaration : KDeployment name deploymentBody;

$Body
deploymentBody : TOpenBrace deploymentElements? TCloseBrace;

deploymentElements : deploymentElement+;

deploymentElement
	: environmentDeclaration
	| compositeWire
	;

$Property(Environments)
$NameDef(Environment)
environmentDeclaration : KEnvironment name environmentBody;

$Body
environmentBody : TOpenBrace runtimeDeclaration runtimeReference* TCloseBrace;

$Property(Runtime)
$NameDef(Runtime)
runtimeDeclaration : KRuntime name TSemicolon;

runtimeReference
	: assemblyReference
	| databaseReference
	;

$Property(Assemblies)
assemblyReference : KAssembly $TypeUse(Assembly) qualifier TSemicolon;

$Property(Databases)
databaseReference : KDatabase $TypeUse(Database) qualifier TSemicolon;

// Binding

$NameDef(Binding)
bindingDeclaration : KBinding name bindingBody;

$Body
bindingBody : TOpenBrace bindingLayers? TCloseBrace;

bindingLayers : transportLayer encodingLayer+ protocolLayer*;


$Property(Transport)
transportLayer 
	: httpTransportLayer 
	| restTransportLayer 
	| webSocketTransportLayer
	;

$Symbol(HttpTransportBindingElement) 
httpTransportLayer : KTransport IHTTP httpTransportLayerBody;

$Body
httpTransportLayerBody
	: TSemicolon #httpTransportLayerEmptyBody
	| TOpenBrace httpTransportLayerProperties* TCloseBrace #httpTransportLayerNonEmptyBody;

$Symbol(RestTransportBindingElement) 
restTransportLayer : KTransport IREST restTransportLayerBody;

$Body
restTransportLayerBody
	: TSemicolon #restTransportLayerEmptyBody
	| TOpenBrace TCloseBrace #restTransportLayerNonEmptyBody;

$Symbol(WebSocketTransportBindingElement) 
webSocketTransportLayer : KTransport IWebSocket webSocketTransportLayerBody;

$Body
webSocketTransportLayerBody
	: TSemicolon #webSocketTransportLayerEmptyBody
	| TOpenBrace TCloseBrace #webSocketTransportLayerNonEmptyBody;


httpTransportLayerProperties
	: httpSslProperty
	| httpClientAuthenticationProperty
	;

$Property(Ssl)
httpSslProperty : ISSL TAssign booleanLiteral TSemicolon;
$Property(ClientAuthentication)
httpClientAuthenticationProperty : IClientAuthentication TAssign booleanLiteral TSemicolon;

$Property(Encodings)
encodingLayer 
	: soapEncodingLayer
	| xmlEncodingLayer
	| jsonEncodingLayer
	;

$Symbol(SoapEncodingBindingElement) 
soapEncodingLayer : KEncoding ISOAP soapEncodingLayerBody;

$Body
soapEncodingLayerBody
	: TSemicolon #soapEncodingLayerEmptyBody
	| TOpenBrace soapEncodingProperties* TCloseBrace #soapEncodingLayerNonEmptyBody;

$Symbol(XmlEncodingBindingElement) 
xmlEncodingLayer : KEncoding IXML xmlEncodingLayerBody;

$Body
xmlEncodingLayerBody
	: TSemicolon #xmlEncodingLayerEmptyBody
	| TOpenBrace TCloseBrace #xmlEncodingLayerNonEmptyBody;

$Symbol(JsonEncodingBindingElement) 
jsonEncodingLayer : KEncoding IJSON jsonEncodingLayerBody;

$Body
jsonEncodingLayerBody
	: TSemicolon #jsonEncodingLayerEmptyBody
	| TOpenBrace TCloseBrace #jsonEncodingLayerNonEmptyBody;

soapEncodingProperties
	: soapVersionProperty
	| soapMtomProperty
	| soapStyleProperty
	;

$Property(Version)
soapVersionProperty : IVersion TAssign $EnumValue(SoapVersion) identifier TSemicolon;

$Property(Mtom)
soapMtomProperty : IMTOM TAssign booleanLiteral TSemicolon;

$Property(Style)
soapStyleProperty : IStyle TAssign $EnumValue(SoapEncodingStyle) identifier TSemicolon;

$Property(Protocols)
$Symbol
protocolLayer : KProtocol protocolLayerKind TSemicolon;

protocolLayerKind : 
	$SymbolType(name='WsAddressing',symbolType=WsAddressingBindingElement) 
	identifier;

// Endpoint:

$NameDef(Endpoint)
endpointDeclaration : KEndpoint name TColon $Property(Interface) $TypeUse(Interface) qualifier endpointBody;

$Body
endpointBody : TOpenBrace endpointProperties? TCloseBrace;

endpointProperties : endpointProperty+;

endpointProperty
	: endpointBindingProperty
	| endpointAddressProperty
	;

endpointBindingProperty : KBinding $Property(Binding) $NameUse(Binding) qualifier TSemicolon;
endpointAddressProperty : KAddress $Property(Address) stringLiteral TSemicolon;

// Types

returnType 
	: typeReference
	| voidType
	;

typeReference 
	: nonNullableArrayType
	| arrayType
	| simpleType
	| nulledType
	;

simpleType : valueType | objectType | $TypeUse qualifier;

nulledType : nullableType | nonNullableType;

referenceType : objectType | $TypeUse qualifier;

$TypeUse
objectType 
	: KObject 
	| KString
	;

$TypeUse
valueType 
	: KInt 
	| KLong 
	| KFloat 
	| KDouble 
	| KByte 
	| KBool
	| IDate
	| ITime
	| IDateTime
	| ITimeSpan
	;

$TypeUse
voidType 
	: KVoid
	;

$TypeUse
onewayType
	: KOneway
	;

operationReturnType
	: $Property(Type) returnType
	| $Property(name=Type,value=SoalInstance.Void) $Property(name=IsOneway,value=true) onewayType
	;

$TypeCtr(NullableType)
nullableType : $Property(InnerType) valueType TQuestion;

$TypeCtr(NonNullableType)
nonNullableType : $Property(InnerType) referenceType TExclamation;

$TypeCtr(NonNullableType)
nonNullableArrayType : $Property(InnerType) arrayType TExclamation;

arrayType
	: simpleArrayType
	| nulledArrayType
	;

$TypeCtr(ArrayType)
simpleArrayType : $Property(InnerType) simpleType TOpenBracket TCloseBracket;

$TypeCtr(ArrayType)
nulledArrayType : $Property(InnerType) nulledType TOpenBracket TCloseBracket;


constantValue
	: literal
	| identifier
	;

typeofValue : KTypeof TOpenParen returnType TCloseParen;

// Identifiers
$Identifier
identifier 
	: identifiers
	| contextualKeywords;

identifiers
	: IdentifierNormal 
	| IdentifierVerbatim
	;

// Literals
literal 
    : nullLiteral
	| booleanLiteral
	| integerLiteral
	| decimalLiteral
	| scientificLiteral
    | stringLiteral
	;

// Null literal
$Constant
nullLiteral : KNull;

// Boolean literals
$Constant
booleanLiteral : KTrue | KFalse;

// Number literals
$Constant
integerLiteral : LInteger;
$Constant
decimalLiteral : LDecimal;
$Constant
scientificLiteral : LScientific;

// String literals
$Constant
stringLiteral 
	: LRegularString
	| LSingleQuoteVerbatimString 
	| LDoubleQuoteVerbatimString;

contextualKeywords
	: IDate
	| ITime
	| IDateTime
	| ITimeSpan
	| IVersion
	| IStyle
	| IMTOM
	| ISSL
	| IHTTP
	| IREST
	| IWebSocket
	| ISOAP
	| IXML
	| IJSON
	| IClientAuthentication
	;
