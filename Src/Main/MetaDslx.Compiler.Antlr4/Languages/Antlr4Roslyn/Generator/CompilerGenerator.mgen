namespace MetaDslx.Languages.Antlr4Roslyn.Compiler;
generator CompilerGenerator for Antlr4Grammar;

using MetaDslx.Compiler;
using MetaDslx.Compiler.MetaModel;

properties Properties
	string DefaultNamespace;
	string LanguageName;
end properties

template GenerateLanguage()
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MetaDslx.Compiler;
using MetaDslx.Compiler.Diagnostics;
using MetaDslx.Compiler.Syntax;
using MetaDslx.Compiler.Syntax.InternalSyntax;
using [Properties.DefaultNamespace].Syntax.InternalSyntax;
^
namespace [Properties.DefaultNamespace]
{
    public sealed class [Properties.LanguageName]Language : Language
    {
        internal const string LanguageName = "[Properties.LanguageName]";
^
        internal static readonly [Properties.LanguageName]Language Instance = new [Properties.LanguageName]Language();
^
        private [Properties.LanguageName]Language()
        {
        }
^
        public override string Name
        {
            get { return [Properties.LanguageName]Language.LanguageName; }
        }
^
        protected override SyntaxFacts SyntaxFactsCore
        {
            get { return [Properties.LanguageName]SyntaxFacts.Instance; }
        }
^
        public new [Properties.LanguageName]SyntaxFacts SyntaxFacts
        {
            get { return ([Properties.LanguageName]SyntaxFacts)base.SyntaxFacts; }
        }
^
        protected override InternalSyntaxFactory InternalSyntaxFactoryCore
        {
            get { return [Properties.LanguageName]GreenFactory.Instance; }
        }
^
        internal [Properties.LanguageName]GreenFactory InternalSyntaxFactory
        {
            get { return ([Properties.LanguageName]GreenFactory)this.InternalSyntaxFactoryCore; }
        }
^
        protected override SyntaxFactory SyntaxFactoryCore
        {
            get { return [Properties.LanguageName]SyntaxFactory.Instance; }
        }
^
        public new [Properties.LanguageName]SyntaxFactory SyntaxFactory
        {
            get { return ([Properties.LanguageName]SyntaxFactory)base.SyntaxFactory; }
        }
^
        protected override CompilationFactory CompilationFactoryCore
        {
            get { return [Properties.LanguageName]CompilationFactory.Instance; }
        }
^
        internal [Properties.LanguageName]CompilationFactory CompilationFactory
        {
            get { return ([Properties.LanguageName]CompilationFactory)this.CompilationFactoryCore; }
        }
    }
}
end template

template GenerateParseOptions()
// !!!!!!!
// WARNING: This is an auto-generated file. Any manual changes will be lost when the file is regenerated.
// !!!!!!!
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MetaDslx.Compiler;
using MetaDslx.Compiler.Syntax;
using MetaDslx.Compiler.Utilities;
^
namespace [Properties.DefaultNamespace]
{
    /// <summary>
    /// This class stores several source parsing related options and offers access to their values.
    /// </summary>
    public sealed class [Properties.LanguageName]ParseOptions : ParseOptions, IEquatable<[Properties.LanguageName]ParseOptions>
    {
        /// <summary>
        /// The default parse options.
        /// </summary>
        public static [Properties.LanguageName]ParseOptions Default { get; } = new [Properties.LanguageName]ParseOptions();
^
        private ImmutableDictionary<string, string> _features;
^
        /// <summary>
        /// Gets the language version.
        /// </summary>
        public LanguageVersion LanguageVersion { get; private set; }
^
        public [Properties.LanguageName]ParseOptions(
            LanguageVersion languageVersion = LanguageVersion.[Properties.LanguageName]1,
            DocumentationMode documentationMode = DocumentationMode.Parse,
            SourceCodeKind kind = SourceCodeKind.Regular)
            : base(kind, documentationMode)
        {
            if (!languageVersion.IsValid())
            {
                throw new ArgumentOutOfRangeException(nameof(languageVersion));
            }
            if (!kind.IsValid())
            {
                throw new ArgumentOutOfRangeException(nameof(kind));
            }
            this.LanguageVersion = languageVersion;
            _features = ImmutableDictionary<string, string>.Empty;
        }
^
        internal [Properties.LanguageName]ParseOptions(
            LanguageVersion languageVersion,
            DocumentationMode documentationMode,
            SourceCodeKind kind,
            ImmutableDictionary<string, string> features)
            : this(languageVersion, documentationMode, kind)
        {
            if (features == null)
            {
                throw new ArgumentNullException(nameof(features));
            }
            _features = features;
        }
^
        private [Properties.LanguageName]ParseOptions([Properties.LanguageName]ParseOptions other) : this(
            languageVersion: other.LanguageVersion,
            documentationMode: other.DocumentationMode,
            kind: other.Kind)
        {
        }
^
        public new [Properties.LanguageName]ParseOptions WithKind(SourceCodeKind kind)
        {
            if (kind == this.Kind)
            {
                return this;
            }
^
            if (!kind.IsValid())
            {
                throw new ArgumentOutOfRangeException(nameof(kind));
            }
^
            return new [Properties.LanguageName]ParseOptions(this) { Kind = kind };
        }
^
        public [Properties.LanguageName]ParseOptions WithLanguageVersion(LanguageVersion version)
        {
            if (version == this.LanguageVersion)
            {
                return this;
            }
^
            if (!version.IsValid())
            {
                throw new ArgumentOutOfRangeException(nameof(version));
            }
^
            return new [Properties.LanguageName]ParseOptions(this) { LanguageVersion = version };
        }
^
        public new [Properties.LanguageName]ParseOptions WithDocumentationMode(DocumentationMode documentationMode)
        {
            if (documentationMode == this.DocumentationMode)
            {
                return this;
            }
^
            if (!documentationMode.IsValid())
            {
                throw new ArgumentOutOfRangeException(nameof(documentationMode));
            }
^
            return new [Properties.LanguageName]ParseOptions(this) { DocumentationMode = documentationMode };
        }
^
        public override ParseOptions CommonWithKind(SourceCodeKind kind)
        {
            return WithKind(kind);
        }
^
        protected override ParseOptions CommonWithDocumentationMode(DocumentationMode documentationMode)
        {
            return WithDocumentationMode(documentationMode);
        }
^
        protected override ParseOptions CommonWithFeatures(IEnumerable<KeyValuePair<string, string>> features)
        {
            return WithFeatures(features);
        }
^
        /// <summary>
        /// Enable some experimental language features for testing.
        /// </summary>
        public new [Properties.LanguageName]ParseOptions WithFeatures(IEnumerable<KeyValuePair<string, string>> features)
        {
            if (features == null)
            {
                throw new ArgumentNullException(nameof(features));
            }
^
            return new [Properties.LanguageName]ParseOptions(this) { _features = features.ToImmutableDictionary(StringComparer.OrdinalIgnoreCase) };
        }

        public override IReadOnlyDictionary<string, string> Features
        {
            get
            {
                return _features;
            }
        }

        internal bool IsFeatureEnabled([Properties.LanguageName]Feature feature)
        {
            string featureFlag = feature.RequiredFeature();
            if (featureFlag != null)
            {
                return Features.ContainsKey(featureFlag);
            }
            LanguageVersion availableVersion = LanguageVersion;
            LanguageVersion requiredVersion = feature.RequiredVersion();
            return availableVersion >= requiredVersion;
        }

        public override bool Equals(object obj)
        {
            return this.Equals(obj as [Properties.LanguageName]ParseOptions);
        }
^
        public bool Equals([Properties.LanguageName]ParseOptions other)
        {
            if (object.ReferenceEquals(this, other))
            {
                return true;
            }

            if (!base.EqualsHelper(other))
            {
                return false;
            }

            return this.LanguageVersion == other.LanguageVersion;
        }
^
        public override int GetHashCode()
        {
            return
                Hash.Combine(base.GetHashCodeHelper(),
                Hash.Combine((int)this.LanguageVersion, 0));
        }
    }
}
end template

template GenerateFeature()
// !!!!!!!
// WARNING: This is an auto-generated file. Any manual changes will be lost when the file is regenerated.
// !!!!!!!
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
^
namespace [Properties.DefaultNamespace]
{
    public enum [Properties.LanguageName]Feature
    {
        None
    }
^
    public static partial class [Properties.LanguageName]FeatureExtensions
    {
        internal static string RequiredFeature(this [Properties.LanguageName]Feature feature)
        {
            switch (feature)
            {
                default:
                    return null;
            }
        }
^
        internal static LanguageVersion RequiredVersion(this [Properties.LanguageName]Feature feature)
        {
            switch (feature)
            {
                case [Properties.LanguageName]Feature.None:
                    return LanguageVersion.[Properties.LanguageName]1;

                default:
                    throw new ArgumentOutOfRangeException(nameof(feature), "Unexpected value: "+feature);
            }
        }
    }
^
}
end template

template GenerateLanguageVersion()
// !!!!!!!
// WARNING: This is an auto-generated file. Any manual changes will be lost when the file is regenerated.
// !!!!!!!
using System;
^
namespace [Properties.DefaultNamespace]
{
    /// <summary>
    /// Specifies the language version.
    /// </summary>
    public enum LanguageVersion
    {
        /// <summary>
        /// [Properties.LanguageName] language version 1.0.
        /// </summary>
        [Properties.LanguageName]1 = 1,
    }
^
    internal static partial class LanguageVersionExtensions
    {
        internal static bool IsValid(this LanguageVersion value)
        {
            return value >= LanguageVersion.[Properties.LanguageName]1 && value <= LanguageVersion.[Properties.LanguageName]1;
        }
^
        internal static object Localize(this LanguageVersion value)
        {
            return (int)value;
        }
^
        internal static [Properties.LanguageName]ErrorCode GetErrorCode(this LanguageVersion version)
        {
            switch (version)
            {
                case LanguageVersion.[Properties.LanguageName]1:
                    return [Properties.LanguageName]ErrorCode.ERR_FeatureNotAvailableInVersion1;
                default:
                    throw new ArgumentOutOfRangeException(nameof(version), "Unexpected value: "+version);
            }
        }
    }
}

end template

template GenerateCompilation()
// !!!!!!!
// WARNING: This is an auto-generated file. Any manual changes will be lost when the file is regenerated.
// !!!!!!!
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Collections.Immutable;
using System.Threading;
using System.Diagnostics;
using MetaDslx.Core;
using MetaDslx.Compiler;
using MetaDslx.Compiler.Declarations;
using MetaDslx.Compiler.Diagnostics;
using MetaDslx.Compiler.Syntax;
using MetaDslx.Compiler.References;
using MetaDslx.Compiler.Utilities;
using [Properties.DefaultNamespace].Syntax;
^
namespace [Properties.DefaultNamespace]
{
    public class [Properties.LanguageName]Compilation : CompilationBase
    {
        protected [Properties.LanguageName]Compilation(
            string name,
            CompilationOptions options,
            ImmutableArray<MetadataReference> references,
            Compilation previousSubmission,
            Type submissionReturnType,
            Type hostObjectType,
            bool isSubmission,
            ReferenceManager referenceManager,
            bool reuseReferenceManager,
            SyntaxAndDeclarationManager syntaxAndDeclarations,
            AsyncQueue<CompilationEvent> eventQueue = null) 
            : base(name, options, references, previousSubmission, submissionReturnType, hostObjectType,
                  isSubmission, referenceManager, reuseReferenceManager, syntaxAndDeclarations, eventQueue)
        {
        }
^
        public override bool IsCaseSensitive
        {
            get { return true; }
        }
^
        public override Language Language
        {
            get { return [Properties.LanguageName]Language.Instance; }
        }
^
        public new [Properties.LanguageName]CompilationOptions Options
        {
            get { return ([Properties.LanguageName]CompilationOptions)base.Options; }
        }
^
        internal MutableModelGroup ModelGroupBuilder
        {
            get { return this.ModelGroupBuilderCore; }
        }
^
        internal MutableModel ModelBuilder
        {
            get { return this.ModelBuilderCore; }
        }
^
        internal ModelId ModelId
        {
            get { return this.ModelIdCore; }
        }
^
        protected override ISymbol CommonDynamicType
        {
            get { return null; }
        }
^
        protected override ISymbol CommonObjectType
        {
            get { return null; }
        }
^
        protected override CompilationBase Update(
            ReferenceManager referenceManager,
            bool reuseReferenceManager,
            SyntaxAndDeclarationManager syntaxAndDeclarations)
        {
            return new [Properties.LanguageName]Compilation(
                this.CompilationName,
                this.Options,
                this.ExternalReferences,
                this.PreviousSubmission,
                this.SubmissionReturnType,
                this.HostObjectType,
                this.IsSubmission,
                referenceManager,
                reuseReferenceManager,
                syntaxAndDeclarations);
        }
^
        /// <summary>
        /// Create a duplicate of this compilation with different symbol instances.
        /// </summary>
        public new [Properties.LanguageName]Compilation Clone()
        {
            return new [Properties.LanguageName]Compilation(
                this.CompilationName,
                this.Options,
                this.ExternalReferences,
                this.PreviousSubmission,
                this.SubmissionReturnType,
                this.HostObjectType,
                this.IsSubmission,
                this.GetUnboundReferenceManager(),
                reuseReferenceManager: true,
                syntaxAndDeclarations: this.SyntaxAndDeclarations);
        }
^
        protected override Compilation CommonClone()
        {
            return this.Clone();
        }
^
        private static readonly [Properties.LanguageName]CompilationOptions s_defaultOptions = new [Properties.LanguageName]CompilationOptions();
        private static readonly [Properties.LanguageName]CompilationOptions s_defaultSubmissionOptions = new [Properties.LanguageName]CompilationOptions().WithReferencesSupersedeLowerVersions(true);
^
        /// <summary>
        /// Creates a new compilation from scratch. Methods such as AddSyntaxTrees or AddReferences
        /// on the returned object will allow to continue building up the Compilation incrementally.
        /// </summary>
        /// <param name="name">Simple compilation name.</param>
        /// <param name="syntaxTrees">The syntax trees with the source code for the new compilation.</param>
        /// <param name="references">The references for the new compilation.</param>
        /// <param name="options">The compiler options to use.</param>
        /// <returns>A new compilation.</returns>
        public static [Properties.LanguageName]Compilation Create(
            string name,
            IEnumerable<[Properties.LanguageName]SyntaxTree> syntaxTrees = null,
            IEnumerable<MetadataReference> references = null,
            [Properties.LanguageName]CompilationOptions options = null)
        {
            return Create(
                name,
                options ?? s_defaultOptions,
                syntaxTrees,
                references,
                previousSubmission: null,
                returnType: null,
                hostObjectType: null,
                isSubmission: false);
        }
^
        /// <summary>
        /// Creates a new compilation that can be used in scripting.
        /// </summary>
        public static [Properties.LanguageName]Compilation CreateScriptCompilation(
            string name,
            [Properties.LanguageName]SyntaxTree syntaxTree = null,
            IEnumerable<MetadataReference> references = null,
            [Properties.LanguageName]CompilationOptions options = null,
            [Properties.LanguageName]Compilation previousScriptCompilation = null,
            Type returnType = null,
            Type globalsType = null)
        {
            ValidateScriptCompilationParameters(previousScriptCompilation, returnType, ref globalsType);
^
            return Create(
                name,
                options?.WithReferencesSupersedeLowerVersions(true) ?? s_defaultSubmissionOptions,
                (syntaxTree != null) ? new["[]"] { syntaxTree } : EmptyCollections.Enumerable<[Properties.LanguageName]SyntaxTree>(),
                references,
                previousScriptCompilation,
                returnType,
                globalsType,
                isSubmission: true);
        }
^
        private static [Properties.LanguageName]Compilation Create(
            string name,
            [Properties.LanguageName]CompilationOptions options,
            IEnumerable<[Properties.LanguageName]SyntaxTree> syntaxTrees,
            IEnumerable<MetadataReference> references,
            [Properties.LanguageName]Compilation previousSubmission,
            Type returnType,
            Type hostObjectType,
            bool isSubmission)
        {
            Debug.Assert(options != null);
            Debug.Assert(!isSubmission || options.ReferencesSupersedeLowerVersions);
^
            var validatedReferences = ValidateReferences<CompilationReference>(references);
^
            var compilation = new [Properties.LanguageName]Compilation(
                name,
                options,
                validatedReferences,
                previousSubmission,
                returnType,
                hostObjectType,
                isSubmission,
                referenceManager: null,
                reuseReferenceManager: false,
                syntaxAndDeclarations: SyntaxAndDeclarationManager.Create(
                    ImmutableArray<SyntaxTree>.Empty,
                    options.ScriptClassName,
                    options.SourceReferenceResolver,
                    isSubmission));
^
            if (syntaxTrees != null)
            {
                compilation = compilation.AddSyntaxTrees(syntaxTrees);
            }
^
            return compilation;
        }
^
        public new [Properties.LanguageName]Compilation AddReferences(params MetadataReference["[]"] references)
        { 
            return ([Properties.LanguageName]Compilation)base.AddReferences(references);
        }
^
        public new [Properties.LanguageName]Compilation AddReferences(IEnumerable<MetadataReference> references)
        {
            return ([Properties.LanguageName]Compilation)base.AddReferences(references);
        }
^
        public new [Properties.LanguageName]Compilation RemoveReferences(params MetadataReference["[]"] references)
        {
            return ([Properties.LanguageName]Compilation)base.RemoveReferences(references);
        }
^
        public new [Properties.LanguageName]Compilation RemoveReferences(IEnumerable<MetadataReference> references)
        {
            return ([Properties.LanguageName]Compilation)base.RemoveReferences(references);
        }
^
        public new [Properties.LanguageName]Compilation RemoveAllReferences()
        {
            return ([Properties.LanguageName]Compilation)base.RemoveAllReferences();
        }
^
        public new [Properties.LanguageName]Compilation AddSyntaxTrees(params SyntaxTree["[]"] trees)
        {
            return ([Properties.LanguageName]Compilation)base.AddSyntaxTrees(trees);
        }
^
        public new [Properties.LanguageName]Compilation AddSyntaxTrees(IEnumerable<SyntaxTree> trees)
        {
            return ([Properties.LanguageName]Compilation)base.AddSyntaxTrees(trees);
        }
^
        public new [Properties.LanguageName]Compilation RemoveSyntaxTrees(params SyntaxTree["[]"] trees)
        {
            return ([Properties.LanguageName]Compilation)base.RemoveSyntaxTrees(trees);
        }
^
        public new [Properties.LanguageName]Compilation RemoveSyntaxTrees(IEnumerable<SyntaxTree> trees)
        {
            return ([Properties.LanguageName]Compilation)base.RemoveSyntaxTrees(trees);
        }
^
        public new [Properties.LanguageName]Compilation RemoveAllSyntaxTrees()
        {
            return ([Properties.LanguageName]Compilation)base.RemoveAllSyntaxTrees();
        }
^
        public new [Properties.LanguageName]Compilation ReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree newTree)
        {
            return ([Properties.LanguageName]Compilation)base.ReplaceSyntaxTree(oldTree, newTree);
        }
^
        protected override ISymbol CommonGetEntryPoint(CancellationToken cancellationToken)
        {
            throw new NotImplementedException();
        }
^
        protected override ISymbol CommonGetSpecialType(Type specialType)
        {
            throw new NotImplementedException();
        }
^
        protected override ISymbol CommonGetTypeByMetadataName(string metadataName)
        {
            throw new NotImplementedException();
        }
^
        /// <summary>
        /// Creates a new compilation with the specified name.
        /// </summary>
        public new [Properties.LanguageName]Compilation WithCompilationName(string compilationName)
        {
            // Can't reuse references since the source assembly name changed and the referenced symbols might 
            // have internals-visible-to relationship with this compilation or they might had a circular reference 
            // to this compilation.
            return new [Properties.LanguageName]Compilation(
                compilationName,
                this.Options,
                this.ExternalReferences,
                this.PreviousSubmission,
                this.SubmissionReturnType,
                this.HostObjectType,
                this.IsSubmission,
                this.GetUnboundReferenceManager(),
                reuseReferenceManager: this.CompilationName == compilationName,
                syntaxAndDeclarations: this.SyntaxAndDeclarations);
        }
^
        protected override Compilation CommonWithCompilationName(string compilationName)
        {
            return this.WithCompilationName(compilationName);
        }
^
        /// <summary>
        /// Returns a new compilation with a given event queue.
        /// </summary>
        public new [Properties.LanguageName]Compilation WithEventQueue(AsyncQueue<CompilationEvent> eventQueue)
        {
            return new [Properties.LanguageName]Compilation(
                this.CompilationName,
                this.Options,
                this.ExternalReferences,
                this.PreviousSubmission,
                this.SubmissionReturnType,
                this.HostObjectType,
                this.IsSubmission,
                this.GetUnboundReferenceManager(),
                reuseReferenceManager: true,
                syntaxAndDeclarations: this.SyntaxAndDeclarations,
                eventQueue: eventQueue);
        }
^
        protected override Compilation CommonWithEventQueue(AsyncQueue<CompilationEvent> eventQueue)
        {
            return this.WithEventQueue(eventQueue);
        }
^
        /// <summary>
        /// Creates a new compilation with the specified compilation options.
        /// </summary>
        public [Properties.LanguageName]Compilation WithOptions([Properties.LanguageName]CompilationOptions options)
        {
            var oldOptions = this.Options;
            bool reuseReferenceManager = oldOptions.CanReuseCompilationReferenceManager(options);
            bool reuseSyntaxAndDeclarationManager = oldOptions.ScriptClassName == options.ScriptClassName &&
                oldOptions.SourceReferenceResolver == options.SourceReferenceResolver;
^
            return new [Properties.LanguageName]Compilation(
                this.CompilationName,
                options,
                this.ExternalReferences,
                this.PreviousSubmission,
                this.SubmissionReturnType,
                this.HostObjectType,
                this.IsSubmission,
                this.GetUnboundReferenceManager(),
                reuseReferenceManager,
                reuseSyntaxAndDeclarationManager ?
                    this.SyntaxAndDeclarations :
                    SyntaxAndDeclarationManager.Create(
                        this.SyntaxAndDeclarations.ExternalSyntaxTrees,
                        options.ScriptClassName,
                        options.SourceReferenceResolver,
                        this.SyntaxAndDeclarations.IsSubmission));
        }
^
        protected override Compilation CommonWithOptions(CompilationOptions options)
        {
            return this.WithOptions(options);
        }
^
        /// <summary>
        /// Creates a new compilation with the specified references.
        /// </summary>
        /// <remarks>
        /// The new <see cref="[Properties.LanguageName]Compilation"/> will query the given <see cref="MetadataReference"/> for the underlying 
        /// metadata as soon as the are needed. 
        /// 
        /// The new compilation uses whatever metadata is currently being provided by the <see cref="MetadataReference"/>.
        /// E.g. if the current compilation references a metadata file that has changed since the creation of the compilation
        /// the new compilation is going to use the updated version, while the current compilation will be using the previous (it doesn't change).
        /// </remarks>
        public new [Properties.LanguageName]Compilation WithReferences(IEnumerable<MetadataReference> references)
        {
            // References might have changed, don't reuse reference manager.
            // Don't even reuse observed metadata - let the manager query for the metadata again.
^
            return new [Properties.LanguageName]Compilation(
                this.CompilationName,
                this.Options,
                ValidateReferences<CompilationReference>(references),
                this.PreviousSubmission,
                this.SubmissionReturnType,
                this.HostObjectType,
                this.IsSubmission,
                referenceManager: null,
                reuseReferenceManager: false,
                syntaxAndDeclarations: this.SyntaxAndDeclarations);
        }
^
        protected override Compilation CommonWithReferences(IEnumerable<MetadataReference> newReferences)
        {
            return this.WithReferences(newReferences);
        }
^
        /// <summary>
        /// Returns a new compilation with the given compilation set as the previous submission.
        /// </summary>
        public [Properties.LanguageName]Compilation WithScriptCompilationInfo([Properties.LanguageName]ScriptCompilationInfo info)
        {
            if (info == ScriptCompilationInfo)
            {
                return this;
            }
^
            // Reference binding doesn't depend on previous submission so we can reuse it.
^
            return new [Properties.LanguageName]Compilation(
                this.CompilationName,
                this.Options,
                this.ExternalReferences,
                info?.PreviousScriptCompilation,
                info?.ReturnType,
                info?.GlobalsType,
                info != null,
                this.GetUnboundReferenceManager(),
                reuseReferenceManager: true,
                syntaxAndDeclarations: this.SyntaxAndDeclarations);
        }
^
        protected override Compilation CommonWithScriptCompilationInfo(ScriptCompilationInfo info)
        {
            return this.WithScriptCompilationInfo(info);
        }
^
        public override bool HasCodeToEmit()
        {
            if (this.IsSubmission) return false;
^
            foreach (var syntaxTree in this.SyntaxTrees)
            {
                var root = syntaxTree.GetRoot();
                if (root.HasErrors)
                {
                    return false;
                }
            }
^
            return true;
        }
^
        public override bool HasSubmissionResult()
        {
            if (!this.IsSubmission) return false;
^
            // A submission may be empty or comprised of a single script file.
            var tree = this.SyntaxAndDeclarations.ExternalSyntaxTrees.SingleOrDefault();
            if (tree == null)
            {
                return false;
            }
^
            var root = tree.GetRoot();
            if (root.HasErrors)
            {
                return false;
            }
^
            return true;
        }
^
        public override bool IsAttributeType(ISymbol type)
        {
            throw new NotImplementedException();
        }
^
        public override bool IsSystemTypeReference(ISymbol type)
        {
            throw new NotImplementedException();
        }
    }
}
end template

template GenerateCompilationFactory()
// !!!!!!!
// WARNING: This is an auto-generated file. Any manual changes will be lost when the file is regenerated.
// !!!!!!!
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Collections.Immutable;
using MetaDslx.Compiler;
using MetaDslx.Compiler.Binding;
using MetaDslx.Compiler.Binding.Binders;
using MetaDslx.Compiler.Declarations;
using MetaDslx.Compiler.Syntax;
using [Properties.DefaultNamespace].Syntax;
using [Properties.DefaultNamespace].Binding;
^
namespace [Properties.DefaultNamespace]
{
    internal class [Properties.LanguageName]CompilationFactory : CompilationFactory
    {
        internal static readonly [Properties.LanguageName]CompilationFactory Instance = new [Properties.LanguageName]CompilationFactory();
^
        private [Properties.LanguageName]CompilationFactory()
        {
        }
^
        public override RootSingleDeclaration CreateDeclarationTree(SyntaxTree syntaxTree, string scriptClassName, bool isSubmission)
        {
            return [Properties.LanguageName]DeclarationTreeBuilderVisitor.ForTree(([Properties.LanguageName]SyntaxTree)syntaxTree, scriptClassName, isSubmission);
        }
^
        public override BinderFactoryVisitor CreateBinderFactoryVisitor(BinderFactory binderFactory)
        {
            return new [Properties.LanguageName]BinderFactoryVisitor(binderFactory);
        }
^
        public override ScriptCompilationInfo CreateScriptCompilationInfo(CompilationBase previousSubmission, Type submissionReturnType, Type hostObjectType)
        {
            return new [Properties.LanguageName]ScriptCompilationInfo(([Properties.LanguageName]Compilation)previousSubmission, submissionReturnType, hostObjectType);
        }
^
        public override SymbolBuilder CreateSymbolBuilder(CompilationBase compilation)
        {
            return new [Properties.LanguageName]SymbolBuilder(([Properties.LanguageName]Compilation)compilation);
        }
    }
}
end template

template GenerateCompilationOptions()
// !!!!!!!
// WARNING: This is an auto-generated file. Any manual changes will be lost when the file is regenerated.
// !!!!!!!
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MetaDslx.Compiler;
using MetaDslx.Compiler.Diagnostics;
using MetaDslx.Compiler.References;
using MetaDslx.Compiler.Utilities;
^
namespace [Properties.DefaultNamespace]
{
    public class [Properties.LanguageName]CompilationOptions : CompilationOptions, IEquatable<[Properties.LanguageName]CompilationOptions>
    {
        // Defaults correspond to the compiler's defaults or indicate that the user did not specify when that is significant.
        // That's significant when one option depends on another's setting.
        public [Properties.LanguageName]CompilationOptions(
            bool reportSuppressedDiagnostics = false,
            string scriptClassName = null,
            ReportDiagnostic generalDiagnosticOption = ReportDiagnostic.Default,
            int warningLevel = 4,
            IEnumerable<KeyValuePair<string, ReportDiagnostic>> specificDiagnosticOptions = null,
            bool concurrentBuild = true,
            bool deterministic = false,
            SourceReferenceResolver sourceReferenceResolver = null,
            MetadataReferenceResolver metadataReferenceResolver = null)
            : this(reportSuppressedDiagnostics, scriptClassName,
                   generalDiagnosticOption, warningLevel,
                   specificDiagnosticOptions != null ? specificDiagnosticOptions.ToImmutableDictionary() : ImmutableDictionary<string, ReportDiagnostic>.Empty, 
                   concurrentBuild, deterministic,
                   sourceReferenceResolver: sourceReferenceResolver,
                   metadataReferenceResolver: metadataReferenceResolver,
                   referencesSupersedeLowerVersions: false)
        {
        }
^
        // Expects correct arguments.
        public [Properties.LanguageName]CompilationOptions(
            bool reportSuppressedDiagnostics,
            string scriptClassName,
            ReportDiagnostic generalDiagnosticOption,
            int warningLevel,
            ImmutableDictionary<string, ReportDiagnostic> specificDiagnosticOptions,
            bool concurrentBuild,
            bool deterministic,
            SourceReferenceResolver sourceReferenceResolver,
            MetadataReferenceResolver metadataReferenceResolver,
            bool referencesSupersedeLowerVersions)
            : base(reportSuppressedDiagnostics, 
                  scriptClassName,
                  generalDiagnosticOption,
                  warningLevel,
                  specificDiagnosticOptions,
                  concurrentBuild,
                  deterministic,
                  sourceReferenceResolver,
                  metadataReferenceResolver, 
                  referencesSupersedeLowerVersions)
        {
        }
^
        private [Properties.LanguageName]CompilationOptions([Properties.LanguageName]CompilationOptions other) : this(
            scriptClassName: other.ScriptClassName,
            generalDiagnosticOption: other.GeneralDiagnosticOption,
            warningLevel: other.WarningLevel,
            specificDiagnosticOptions: other.SpecificDiagnosticOptions,
            concurrentBuild: other.ConcurrentBuild,
            deterministic: other.Deterministic,
            sourceReferenceResolver: other.SourceReferenceResolver,
            metadataReferenceResolver: other.MetadataReferenceResolver,
            reportSuppressedDiagnostics: other.ReportSuppressedDiagnostics,
            referencesSupersedeLowerVersions: other.ReferencesSupersedeLowerVersions)
        {
        }
^
        public new [Properties.LanguageName]CompilationOptions WithDeterministic(bool deterministic)
        {
            if (this.Deterministic == deterministic)
            {
                return this;
            }
            return new [Properties.LanguageName]CompilationOptions(this) { Deterministic = deterministic };
        }
^
        public new [Properties.LanguageName]CompilationOptions WithReferencesSupersedeLowerVersions(bool value)
        {
            if (this.ReferencesSupersedeLowerVersions == value)
            {
                return this;
            }
            return new [Properties.LanguageName]CompilationOptions(this) { ReferencesSupersedeLowerVersions = value };
        }
^
        public new [Properties.LanguageName]CompilationOptions WithGeneralDiagnosticOption(ReportDiagnostic generalDiagnosticOption)
        {
            if (this.GeneralDiagnosticOption == generalDiagnosticOption)
            {
                return this;
            }
            return new [Properties.LanguageName]CompilationOptions(this) { GeneralDiagnosticOption = generalDiagnosticOption };
        }
^
        public new [Properties.LanguageName]CompilationOptions WithMetadataReferenceResolver(MetadataReferenceResolver resolver)
        {
            if (this.MetadataReferenceResolver == resolver)
            {
                return this;
            }
            return new [Properties.LanguageName]CompilationOptions(this) { MetadataReferenceResolver = resolver };
        }
^
        public new [Properties.LanguageName]CompilationOptions WithReportSuppressedDiagnostics(bool reportSuppressedDiagnostics)
        {
            if (this.ReportSuppressedDiagnostics == reportSuppressedDiagnostics)
            {
                return this;
            }
            return new [Properties.LanguageName]CompilationOptions(this) { ReportSuppressedDiagnostics = reportSuppressedDiagnostics };
        }
^
        public new [Properties.LanguageName]CompilationOptions WithSourceReferenceResolver(SourceReferenceResolver resolver)
        {
            if (this.SourceReferenceResolver == resolver)
            {
                return this;
            }
            return new [Properties.LanguageName]CompilationOptions(this) { SourceReferenceResolver = resolver };
        }
^
        public new [Properties.LanguageName]CompilationOptions WithSpecificDiagnosticOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>> specificDiagnosticOptions)
        {
            return new [Properties.LanguageName]CompilationOptions(this) { SpecificDiagnosticOptions = specificDiagnosticOptions != null ? specificDiagnosticOptions.ToImmutableDictionary() : ImmutableDictionary<string, ReportDiagnostic>.Empty };
        }
^
        public new [Properties.LanguageName]CompilationOptions WithSpecificDiagnosticOptions(ImmutableDictionary<string, ReportDiagnostic> specificDiagnosticOptions)
        {
            if (specificDiagnosticOptions == null)
            {
                specificDiagnosticOptions = ImmutableDictionary<string, ReportDiagnostic>.Empty;
            }
^
            if (this.SpecificDiagnosticOptions == specificDiagnosticOptions)
            {
                return this;
            }
^
            return new [Properties.LanguageName]CompilationOptions(this) { SpecificDiagnosticOptions = specificDiagnosticOptions };
        }
^
        protected override CompilationOptions CommonWithDeterministic(bool deterministic)
        {
            return this.WithDeterministic(deterministic);
        }
^
        protected override CompilationOptions CommonWithReferencesSupersedeLowerVersions(bool value)
        {
            return this.CommonWithDeterministic(value);
        }
^
        protected override CompilationOptions CommonWithGeneralDiagnosticOption(ReportDiagnostic generalDiagnosticOption)
        {
            return this.WithGeneralDiagnosticOption(generalDiagnosticOption);
        }
^
        protected override CompilationOptions CommonWithMetadataReferenceResolver(MetadataReferenceResolver resolver)
        {
            return this.WithMetadataReferenceResolver(resolver);
        }
^
        protected override CompilationOptions CommonWithReportSuppressedDiagnostics(bool reportSuppressedDiagnostics)
        {
            return this.WithReportSuppressedDiagnostics(reportSuppressedDiagnostics);
        }
^
        protected override CompilationOptions CommonWithSourceReferenceResolver(SourceReferenceResolver resolver)
        {
            return this.WithSourceReferenceResolver(resolver);
        }
^
        protected override CompilationOptions CommonWithSpecificDiagnosticOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>> specificDiagnosticOptions)
        {
            return this.WithSpecificDiagnosticOptions(specificDiagnosticOptions);
        }
^
        protected override CompilationOptions CommonWithSpecificDiagnosticOptions(ImmutableDictionary<string, ReportDiagnostic> specificDiagnosticOptions)
        {
            return this.WithSpecificDiagnosticOptions(specificDiagnosticOptions);
        }
^
        public override Diagnostic FilterDiagnostic(Diagnostic diagnostic)
        {
            return diagnostic;
        }
^
        protected override ImmutableArray<string> GetImports()
        {
            return ImmutableArray<string>.Empty;
        }
^
        protected override void ValidateOptions(ArrayBuilder<Diagnostic> builder)
        {
        }
^
        public bool Equals([Properties.LanguageName]CompilationOptions other)
        {
            if (object.ReferenceEquals(this, other))
            {
                return true;
            }
^
            if (!base.EqualsHelper(other))
            {
                return false;
            }
^
            return true;
        }
^
        public override bool Equals(object obj)
        {
            return this.Equals(obj as [Properties.LanguageName]CompilationOptions);
        }
^
        public override int GetHashCode()
        {
            return base.GetHashCodeHelper();
        }
    }
}
end template

template GenerateScriptCompilationInfo()
// !!!!!!!
// WARNING: This is an auto-generated file. Any manual changes will be lost when the file is regenerated.
// !!!!!!!
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MetaDslx.Compiler;
^
namespace [Properties.DefaultNamespace]
{
    public class [Properties.LanguageName]ScriptCompilationInfo : ScriptCompilationInfo
    {
        public new [Properties.LanguageName]Compilation PreviousScriptCompilation { get; }
^
        internal [Properties.LanguageName]ScriptCompilationInfo([Properties.LanguageName]Compilation previousCompilationOpt, Type returnType, Type globalsType)
            : base(returnType, globalsType)
        {
            Debug.Assert(previousCompilationOpt == null || previousCompilationOpt.HostObjectType == globalsType);
^
            PreviousScriptCompilation = previousCompilationOpt;
        }
^
        protected override Compilation CommonPreviousScriptCompilation => PreviousScriptCompilation;
^
        public [Properties.LanguageName]ScriptCompilationInfo WithPreviousScriptCompilation([Properties.LanguageName]Compilation compilation) =>
            (compilation == PreviousScriptCompilation) ? this : new [Properties.LanguageName]ScriptCompilationInfo(compilation, ReturnType, GlobalsType);
^
        protected override ScriptCompilationInfo CommonWithPreviousScriptCompilation(Compilation compilation) =>
            WithPreviousScriptCompilation(([Properties.LanguageName]Compilation)compilation);
    }
}
end template


template GenerateErrorCode()
// !!!!!!!
// WARNING: This is an auto-generated file. Any manual changes will be lost when the file is regenerated.
// !!!!!!!
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
^
namespace [Properties.DefaultNamespace]
{
    internal enum [Properties.LanguageName]ErrorCode
    {
        ERR_FeatureNotAvailableInVersion1
    }
}
end template

template GenerateSyntaxParser()
// !!!!!!!
// WARNING: This is an auto-generated file. Any manual changes will be lost when the file is regenerated.
// !!!!!!!
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Antlr4.Runtime;
using Antlr4.Runtime.Tree;
using MetaDslx.Compiler.Antlr4Roslyn;
using MetaDslx.Compiler.Syntax;
using MetaDslx.Compiler.Syntax.InternalSyntax;
using MetaDslx.Compiler.Text;
using MetaDslx.Compiler.MetaModel;
using MetaDslx.Compiler.Utilities;

namespace [Properties.DefaultNamespace].Syntax.InternalSyntax
{
    public class [Properties.LanguageName]SyntaxParser : Antlr4SyntaxParser<[Properties.LanguageName]Lexer, [Properties.LanguageName]Parser>
    {
        public [Properties.LanguageName]SyntaxParser(
            SourceText text,
            [Properties.LanguageName]ParseOptions options,
            SyntaxNode oldTree, 
            IEnumerable<TextChangeRange> changes,
            CancellationToken cancellationToken = default(CancellationToken))
            : base(text, [Properties.LanguageName]Language.Instance, options, oldTree, changes, cancellationToken)
        {
        }

        public override DirectiveStack Directives
        {
            get
            {
                return DirectiveStack.Empty;
            }
        }

        protected override [Properties.LanguageName]Lexer CreateLexer(AntlrInputStream inputStream)
        {
            return new [Properties.LanguageName]Lexer(inputStream);
        }

        protected override [Properties.LanguageName]Parser CreateParser(CommonTokenStream tokenStream)
        {
            return new [Properties.LanguageName]Parser(tokenStream);
        }

        public override GreenNode Parse()
        {
            return this.Parse[Instances.MainRule().PlainName()]();
        }

        internal [Instances.MainRule().GreenName()] Parse[Instances.MainRule().PlainName()]()
        {
            Antlr4ToRoslynVisitor visitor = new Antlr4ToRoslynVisitor(this);
            var tree = this.Parser.[Instances.MainRule().PlainName().ToCamelCase()]();
            return ([Instances.MainRule().GreenName()])visitor.Visit(tree);
        }

        private class Antlr4ToRoslynVisitor : [Properties.LanguageName]ParserBaseVisitor<GreenNode>
        {
            private [Properties.LanguageName]Language language;
			private [Properties.LanguageName]GreenFactory factory;
            private [Properties.LanguageName]SyntaxParser syntaxParser;
			private IList<IToken> tokens;
            private IToken lastToken;

            public Antlr4ToRoslynVisitor([Properties.LanguageName]SyntaxParser syntaxParser)
            {
                this.language = [Properties.LanguageName]Language.Instance;
				this.factory = language.InternalSyntaxFactory;
                this.syntaxParser = syntaxParser;
				this.tokens = this.syntaxParser.CommonTokenStream.GetTokens();
                this.lastToken = null;
            }

            public override GreenNode VisitTerminal(ITerminalNode node)
            {
                GreenNode result = this.syntaxParser.VisitTerminal(node, this.lastToken);
                if (result != null && !result.IsMissing)
                {
                    this.lastToken = node.Symbol;
                }
                return result;
            }
			[loop(rule:Instances.ParserRules)]
			[GenerateAntlr4ToRoslynVisitorRule(rule, null)]
			[end loop]
        }
    }

}
end template

template GenerateAntlr4ToRoslynVisitorRule(Antlr4ParserRule rule, Antlr4ParserRule superRule)
[if (rule.Alternatives.Count > 0)]
	[loop(alt:rule.Alternatives)]
[GenerateAntlr4ToRoslynVisitorRule(alt, rule)]
	[end loop]
[else]
^
public override GreenNode Visit[rule.PlainName()]([Properties.LanguageName]Parser.[rule.PlainName()]Context context)
{
	if (context == null) return null;
	[if (rule.IsSimpleAlt)]
		[loop(elem:rule.Elements)]
	[Properties.LanguageName]Parser.[elem.PlainType(false)]Context [elem.FieldName()]Context = context.[elem.GetAccessorName()];
			[if (elem.IsSimplified && elem.IsList && elem.IsSeparated)]
	if ([elem.FieldName()]Context != null) 
	{
		return this.factory.[rule.PlainName()]((([elem.GreenType(TypeKind.Public, false)])this.Visit([elem.FieldName()]Context))?.[elem.Grammar.FindParserRule(elem.OriginalType).Elements[0].GreenName()], true);
	}
			[else]
	if ([elem.FieldName()]Context != null) 
	{
		return this.factory.[rule.PlainName()](([elem.GreenType(TypeKind.Public, false)])this.Visit([elem.FieldName()]Context), true);
	}
			[end if]
		[end loop]
	return null;
	[else]
	[loop(elem:rule.AllElements)]
		[if(elem.IsSimplified)]
	[Properties.LanguageName]Parser.[elem.PlainType(false)]Context [elem.FieldName()]Context = context.[elem.GetAccessorName()];
	[elem.GreenType(TypeKind.Public, false)] [elem.FieldName()] = null;
	if ([elem.FieldName()]Context != null)
	{
		[elem.FieldName()] = ([elem.GreenType(TypeKind.Public, false)])this.Visit([elem.FieldName()]Context);
	}
		[else]
		[if(elem.IsBlock)]
			[if(elem.IsFixedTokenAltBlock)]
	InternalSyntaxToken [elem.FieldName()] = null;
				[loop(item:elem.BlockItems; separator delim = "else ")]
	if (context.[item.GetAccessorName()] != null)
	{
		[elem.FieldName()] = (InternalSyntaxToken)this.VisitTerminal(context.[item.GetAccessorName()]);
	}
	[delim]\
				[end loop]
			[else]
	// ERROR, unhandled element: [elem.GreenType(TypeKind.Field)] [elem.FieldName()]
			[end if]
		[else]
			[if(elem.IsList)]
				[if(elem.IsSeparated)]
    [Properties.LanguageName]Parser.[elem.PlainType()]Context["[]"] [elem.FieldName()]Context = context.[elem.GetAccessorName()];
    ITerminalNode["[]"] [elem.Separator.FieldName()]Context = context.[elem.Separator.GetAccessorName()];
    ArrayBuilder<GreenNode> [elem.FieldName()]Builder = ArrayBuilder<GreenNode>.GetInstance([elem.FieldName()]Context.Length+[elem.Separator.FieldName()]Context.Length);
    for (int i = 0; i < [elem.FieldName()]Context.Length; i++)
    {
        [elem.FieldName()]Builder.Add(([elem.GreenInnerType()])this.Visit([elem.FieldName()]Context["[i]"]));
        if (i < [elem.Separator.FieldName()]Context.Length)
        {
            [elem.FieldName()]Builder.Add((InternalSyntaxToken)this.VisitTerminal([elem.Separator.FieldName()]Context["[i]"]));
        }
    }
	[elem.GreenType(TypeKind.Public)] [elem.FieldName()] = [elem.GreenType(TypeKind.Public)].Create([elem.FieldName()]Builder.ToArrayAndFree());
				[else]
					[if(elem.IsToken)]
    ITerminalNode["[]"] [elem.FieldName()]Context = context.[elem.GetAccessorName()];
    ArrayBuilder<[elem.GreenInnerType()]> [elem.FieldName()]Builder = ArrayBuilder<[elem.GreenInnerType()]>.GetInstance([elem.FieldName()]Context.Length);
    for (int i = 0; i < [elem.FieldName()]Context.Length; i++)
    {
        [elem.FieldName()]Builder.Add(([elem.GreenInnerType()])this.VisitTerminal([elem.FieldName()]Context["[i]"]));
    }
    [elem.GreenType(TypeKind.Public)] [elem.FieldName()] = [elem.GreenType(TypeKind.Public)].Create([elem.FieldName()]Builder.ToArrayAndFree());
					[else]
    [Properties.LanguageName]Parser.[elem.PlainType()]Context["[]"] [elem.FieldName()]Context = context.[elem.GetAccessorName()];
    ArrayBuilder<[elem.GreenInnerType()]> [elem.FieldName()]Builder = ArrayBuilder<[elem.GreenInnerType()]>.GetInstance([elem.FieldName()]Context.Length);
    for (int i = 0; i < [elem.FieldName()]Context.Length; i++)
    {
        [elem.FieldName()]Builder.Add(([elem.GreenInnerType()])this.Visit([elem.FieldName()]Context["[i]"]));
    }
	[elem.GreenType(TypeKind.Public)] [elem.FieldName()] = [elem.GreenType(TypeKind.Public)].Create([elem.FieldName()]Builder.ToArrayAndFree());
					[end if]
				[end if]
			[else]
				[if(elem.IsToken)]
	InternalSyntaxToken [elem.FieldName()] = (InternalSyntaxToken)this.VisitTerminal(context.[elem.Antlr4Name()]);
				[else]
	[Properties.LanguageName]Parser.[elem.PlainType()]Context [elem.FieldName()]Context = context.[elem.GetAccessorName()];
	[elem.GreenType(TypeKind.Field)] [elem.FieldName()] = null;
	if ([elem.FieldName()]Context != null)
	{
		[elem.FieldName()] = ([elem.GreenType(TypeKind.Field)])this.Visit([elem.FieldName()]Context);
	}
				[end if]
			[end if]
		[end if]
		[end if]
	[end loop]
	return this.factory.[rule.PlainName()]([GetRoslynVisitorElemParamList(rule, false, false)], true);
	[end if]
}
[end if]
end template


template GenerateSyntaxTree()
// !!!!!!!
// WARNING: This is an auto-generated file. Any manual changes will be lost when the file is regenerated.
// !!!!!!!
using MetaDslx.Compiler;
using MetaDslx.Compiler.Diagnostics;
using MetaDslx.Compiler.Syntax;
using MetaDslx.Compiler.Syntax.InternalSyntax;
using MetaDslx.Compiler.Text;
using MetaDslx.Compiler.Utilities;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace [Properties.DefaultNamespace].Syntax
{
    /// <summary>
    /// The parsed representation of a [Properties.LanguageName] source document.
    /// </summary>
    public abstract class [Properties.LanguageName]SyntaxTree : SyntaxTree
    {
        internal static readonly SyntaxTree Dummy = new DummySyntaxTree();

        public override Language Language => [Properties.LanguageName]Language.Instance;

        /// <summary>
        /// The options used by the parser to produce the syntax tree.
        /// </summary>
        public new abstract [Properties.LanguageName]ParseOptions Options { get; }
        /// <summary>
        /// Gets the root node of the syntax tree.
        /// </summary>
        public new abstract [Properties.LanguageName]SyntaxNode GetRoot(CancellationToken cancellationToken = default(CancellationToken));
        /// <summary>
        /// Gets the root node of the syntax tree if it is already available.
        /// </summary>
        public abstract bool TryGetRoot(out [Properties.LanguageName]SyntaxNode root);
        /// <summary>
        /// Gets the root node of the syntax tree asynchronously.
        /// </summary>
        /// <remarks>
        /// By default, the work associated with this method will be executed immediately on the current thread.
        /// Implementations that wish to schedule this work differently should override <see cref="GetRootAsync(CancellationToken)"/>.
        /// </remarks>
        public new virtual Task<[Properties.LanguageName]SyntaxNode> GetRootAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            [Properties.LanguageName]SyntaxNode node;
            return Task.FromResult(this.TryGetRoot(out node) ? node : this.GetRoot(cancellationToken));
        }
        /// <summary>
        /// Gets the root of the syntax tree statically typed as <see cref="CompilationUnitSyntax"/>.
        /// </summary>
        /// <remarks>
        /// Ensure that <see cref="SyntaxTree.HasCompilationUnitRoot"/> is true for this tree prior to invoking this method.
        /// </remarks>
        /// <exception cref="InvalidCastException">Throws this exception if <see cref="SyntaxTree.HasCompilationUnitRoot"/> is false.</exception>
        public [Instances.MainRule().RedName()] GetCompilationUnitRoot(CancellationToken cancellationToken = default(CancellationToken))
        {
            return ([Instances.MainRule().RedName()])this.GetRoot(cancellationToken);
        }
        /// <summary>
        /// Creates a new syntax based off this tree using a new source text.
        /// </summary>
        /// <remarks>
        /// If the new source text is a minor change from the current source text an incremental parse will occur
        /// reusing most of the current syntax tree internal data.  Otherwise, a full parse will occur using the new
        /// source text.
        /// </remarks>
        public override SyntaxTree WithChangedText(SourceText newText)
        {
            // try to find the changes between the old text and the new text.
            SourceText oldText;
            if (this.TryGetText(out oldText))
            {
                var changes = newText.GetChangeRanges(oldText);
                if (changes.Count == 0 && newText == oldText)
                {
                    return this;
                }
                return this.WithChanges(newText, changes);
            }
            // if we do not easily know the old text, then specify entire text as changed so we do a full reparse.
            return this.WithChanges(newText, new["[]"] { new TextChangeRange(new TextSpan(0, this.Length), newText.Length) });
        }
        private SyntaxTree WithChanges(SourceText newText, IReadOnlyList<TextChangeRange> changes)
        {
            if (changes == null)
            {
                throw new ArgumentNullException(nameof(changes));
            }
            var oldTree = this;
            // if changes is entire text do a full reparse
            if (changes.Count == 1 && new TextSpan(0, this.Length).Equals(changes["[0]"].Span) && changes["[0]"].NewLength == newText.Length)
            {
                // parser will do a full parse if we give it no changes
                changes = null;
                oldTree = null;
            }
            using (var parser = [Properties.LanguageName]Language.Instance.SyntaxFactory.MakeParser(newText, this.Options, oldTree?.GetRoot(), changes))
            {
                var compilationUnit = ([Instances.MainRule().RedName()])parser.Parse().CreateRed();
                var tree = new ParsedSyntaxTree(newText, newText.Encoding, newText.ChecksumAlgorithm, this.FilePath, this.Options, compilationUnit, parser.Directives);
                tree.VerifySource(changes);
                return tree;
            }
        }
        public abstract [Properties.LanguageName]SyntaxTree WithRootAndOptions(SyntaxNode root, ParseOptions options);
        public abstract [Properties.LanguageName]SyntaxTree WithFilePath(string path);
        #region Factories
        /// <summary>
        /// Creates a new syntax tree from a syntax node.
        /// </summary>
        public static [Properties.LanguageName]SyntaxTree Create([Properties.LanguageName]SyntaxNode root, [Properties.LanguageName]ParseOptions options = null, string path = "", Encoding encoding = null)
        {
            if (root == null)
            {
                throw new ArgumentNullException(nameof(root));
            }
            var directives = DirectiveStack.Empty;
            return new ParsedSyntaxTree(
                textOpt: null,
                encodingOpt: encoding,
                checksumAlgorithm: SourceHashAlgorithm.Sha1,
                path: path,
                options: options ?? [Properties.LanguageName]ParseOptions.Default,
                root: root,
                directives: directives);
        }
        /// <summary>
        /// Creates a new syntax tree from a syntax node with text that should correspond to the syntax node.
        /// </summary>
        /// <remarks>This is used by the ExpressionEvaluator.</remarks>
        internal static [Properties.LanguageName]SyntaxTree CreateForDebugger([Properties.LanguageName]SyntaxNode root, SourceText text)
        {
            Debug.Assert(root != null);
            return new DebuggerSyntaxTree(root, text);
        }
        /// <summary>
        /// <para>
        /// Internal helper for <see cref="[Properties.LanguageName]SyntaxNode"/> class to create a new syntax tree rooted at the given root node.
        /// This method does not create a clone of the given root, but instead preserves it's reference identity.
        /// </para>
        /// <para>NOTE: This method is only intended to be used from <see cref="[Properties.LanguageName]SyntaxNode.SyntaxTree"/> property.</para>
        /// <para>NOTE: Do not use this method elsewhere, instead use <see cref="Create([Properties.LanguageName]SyntaxNode, [Properties.LanguageName]ParseOptions, string, Encoding)"/> method for creating a syntax tree.</para>
        /// </summary>
        internal static [Properties.LanguageName]SyntaxTree CreateWithoutClone([Properties.LanguageName]SyntaxNode root)
        {
            Debug.Assert(root != null);
            return new ParsedSyntaxTree(
                textOpt: null,
                encodingOpt: null,
                checksumAlgorithm: SourceHashAlgorithm.Sha1,
                path: "",
                options: [Properties.LanguageName]ParseOptions.Default,
                root: root,
                directives: DirectiveStack.Empty,
                cloneRoot: false);
        }
        /// <summary>
        /// Produces a syntax tree by parsing the source text.
        /// </summary>
        public static [Properties.LanguageName]SyntaxTree ParseText(
            string text,
            [Properties.LanguageName]ParseOptions options = null,
            string path = "",
            Encoding encoding = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            return ParseText(SourceText.From(text, encoding), options, path, cancellationToken);
        }
        /// <summary>
        /// Produces a syntax tree by parsing the source text.
        /// </summary>
        public static [Properties.LanguageName]SyntaxTree ParseText(
            SourceText text,
            [Properties.LanguageName]ParseOptions options = null,
            string path = "",
            CancellationToken cancellationToken = default(CancellationToken))
        {
            if (text == null)
            {
                throw new ArgumentNullException(nameof(text));
            }
            if (path == null)
            {
                throw new ArgumentNullException(nameof(path));
            }
            options = options ?? [Properties.LanguageName]ParseOptions.Default;
            using (var parser = [Properties.LanguageName]Language.Instance.SyntaxFactory.MakeParser(text, options, oldTree: null, changes: null))
            {
                var compilationUnit = ([Instances.MainRule().RedName()])parser.Parse().CreateRed();
                var tree = new ParsedSyntaxTree(text, text.Encoding, text.ChecksumAlgorithm, path, options, compilationUnit, parser.Directives);
                tree.VerifySource();
                return tree;
            }
        }
        #endregion
        #region SyntaxTree
        protected override SyntaxNode GetRootCore(CancellationToken cancellationToken)
        {
            return this.GetRoot(cancellationToken);
        }
        protected override async Task<SyntaxNode> GetRootAsyncCore(CancellationToken cancellationToken)
        {
            return await this.GetRootAsync(cancellationToken).ConfigureAwait(false);
        }
        protected override bool TryGetRootCore(out SyntaxNode root)
        {
            [Properties.LanguageName]SyntaxNode node;
            if (this.TryGetRoot(out node))
            {
                root = node;
                return true;
            }
            else
            {
                root = null;
                return false;
            }
        }
        protected override ParseOptions OptionsCore
        {
            get
            {
                return this.Options;
            }
        }
        #endregion
        private class DebuggerSyntaxTree : ParsedSyntaxTree
        {
            public DebuggerSyntaxTree([Properties.LanguageName]SyntaxNode root, SourceText text)
                : base(
                    text,
                    text.Encoding,
                    text.ChecksumAlgorithm,
                    path: "",
                    options: [Properties.LanguageName]ParseOptions.Default,
                    root: root,
                    directives: DirectiveStack.Empty)
            {
            }
            public override bool SupportsLocations
            {
                get { return true; }
            }
        }
        private sealed class DummySyntaxTree : [Properties.LanguageName]SyntaxTree
        {
            private readonly [Instances.MainRule().RedName()] _node;
            public DummySyntaxTree()
            {
                _node = new [Instances.MainRule().RedName()]([Properties.LanguageName]Language.Instance.InternalSyntaxFactory.[Instances.MainRule().PlainName()]([GetElemNullParamList(Instances.MainRule(), false, true)]true), this, 0);
            }
            public override string ToString()
            {
                return string.Empty;
            }
            public override SourceText GetText(CancellationToken cancellationToken)
            {
                return SourceText.From(string.Empty, Encoding.UTF8);
            }
            public override bool TryGetText(out SourceText text)
            {
                text = SourceText.From(string.Empty, Encoding.UTF8);
                return true;
            }
            public override Encoding Encoding
            {
                get { return Encoding.UTF8; }
            }
            public override int Length
            {
                get { return 0; }
            }
            public override [Properties.LanguageName]ParseOptions Options
            {
                get { return [Properties.LanguageName]ParseOptions.Default; }
            }
            public override string FilePath
            {
                get { return string.Empty; }
            }
            public override [Properties.LanguageName]SyntaxNode GetRoot(CancellationToken cancellationToken)
            {
                return _node;
            }
            public override bool TryGetRoot(out [Properties.LanguageName]SyntaxNode root)
            {
                root = _node;
                return true;
            }
            public override bool HasCompilationUnitRoot
            {
                get { return true; }
            }
            public override [Properties.LanguageName]SyntaxTree WithRootAndOptions(SyntaxNode root, ParseOptions options)
            {
                return [Properties.LanguageName]Language.Instance.SyntaxFactory.SyntaxTree(root, options: ([Properties.LanguageName]ParseOptions)options, path: FilePath, encoding: null);
            }
            public override [Properties.LanguageName]SyntaxTree WithFilePath(string path)
            {
                return [Properties.LanguageName]Language.Instance.SyntaxFactory.SyntaxTree(_node, options: this.Options, path: path, encoding: null);
            }
        }
        private class ParsedSyntaxTree : [Properties.LanguageName]SyntaxTree
        {
            private readonly [Properties.LanguageName]ParseOptions _options;
            private readonly string _path;
            private readonly [Properties.LanguageName]SyntaxNode _root;
            private readonly bool _hasCompilationUnitRoot;
            private readonly Encoding _encodingOpt;
            private readonly SourceHashAlgorithm _checksumAlgorithm;
            private SourceText _lazyText;
            internal ParsedSyntaxTree(SourceText textOpt, Encoding encodingOpt, SourceHashAlgorithm checksumAlgorithm, string path, [Properties.LanguageName]ParseOptions options, [Properties.LanguageName]SyntaxNode root, DirectiveStack directives, bool cloneRoot = true)
            {
                Debug.Assert(root != null);
                Debug.Assert(options != null);
                Debug.Assert(path != null);
                Debug.Assert(textOpt == null || textOpt.Encoding == encodingOpt && textOpt.ChecksumAlgorithm == checksumAlgorithm);
                _lazyText = textOpt;
                _encodingOpt = encodingOpt ?? textOpt?.Encoding;
                _checksumAlgorithm = checksumAlgorithm;
                _options = options;
                _path = path;
                _root = cloneRoot ? new [Instances.MainRule().RedName()]((InternalSyntaxNode)root.Green, this, 0) : root;
                _hasCompilationUnitRoot = root.Kind == [Properties.LanguageName]SyntaxKind.Main;
                this.SetDirectiveStack(directives);
            }
            public override string FilePath
            {
                get { return _path; }
            }
            public override SourceText GetText(CancellationToken cancellationToken)
            {
                if (_lazyText == null)
                {
                    Interlocked.CompareExchange(ref _lazyText, this.GetRoot(cancellationToken).GetText(_encodingOpt, _checksumAlgorithm), null);
                }
                return _lazyText;
            }
            public override bool TryGetText(out SourceText text)
            {
                text = _lazyText;
                return text != null;
            }
            public override Encoding Encoding
            {
                get { return _encodingOpt; }
            }
            public override int Length
            {
                get { return _root.FullSpan.Length; }
            }
            public override [Properties.LanguageName]SyntaxNode GetRoot(CancellationToken cancellationToken)
            {
                return _root;
            }
            public override bool TryGetRoot(out [Properties.LanguageName]SyntaxNode root)
            {
                root = _root;
                return true;
            }
            public override bool HasCompilationUnitRoot
            {
                get
                {
                    return _hasCompilationUnitRoot;
                }
            }
            public override [Properties.LanguageName]ParseOptions Options
            {
                get
                {
                    return _options;
                }
            }

            public override [Properties.LanguageName]SyntaxTree WithRootAndOptions(SyntaxNode root, ParseOptions options)
            {
                if (ReferenceEquals(_root, root) && ReferenceEquals(_options, options))
                {
                    return this;
                }
                return new ParsedSyntaxTree(
                    null,
                    _encodingOpt,
                    _checksumAlgorithm,
                    _path,
                    ([Properties.LanguageName]ParseOptions)options,
                    ([Properties.LanguageName]SyntaxNode)root,
                    this.GetDirectives());
            }
            public override [Properties.LanguageName]SyntaxTree WithFilePath(string path)
            {
                if (_path == path)
                {
                    return this;
                }
                return new ParsedSyntaxTree(
                    _lazyText,
                    _encodingOpt,
                    _checksumAlgorithm,
                    path,
                    _options,
                    _root,
                    this.GetDirectives());
            }
        }
    }
}
end template

template GenerateInternalSyntax()
// !!!!!!!
// WARNING: This is an auto-generated file. Any manual changes will be lost when the file is regenerated.
// !!!!!!!
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MetaDslx.Compiler;
using MetaDslx.Compiler.Diagnostics;
using MetaDslx.Compiler.Syntax;
using MetaDslx.Compiler.Syntax.InternalSyntax;
using MetaDslx.Compiler.Text;
using MetaDslx.Compiler.Utilities;
^
namespace [Properties.DefaultNamespace].Syntax.InternalSyntax
{
    internal abstract class [Properties.LanguageName]GreenNode : InternalSyntaxNode
    {
        public [Properties.LanguageName]GreenNode([Properties.LanguageName]SyntaxKind kind, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
            : base((int)kind, 0, diagnostics, annotations)
        {
        }
^
        public [Properties.LanguageName]SyntaxKind Kind
        {
            get { return ([Properties.LanguageName]SyntaxKind)base.RawKind; }
        }
^
        public override Language Language
        {
            get { return [Properties.LanguageName]Language.Instance; }
        }
    }
^
    internal class [Properties.LanguageName]GreenTrivia : InternalSyntaxTrivia
    {
        public [Properties.LanguageName]GreenTrivia([Properties.LanguageName]SyntaxKind kind, string text, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
            : base((int)kind, text, diagnostics, annotations)
        {
        }
^
        public [Properties.LanguageName]SyntaxKind Kind
        {
            get { return ([Properties.LanguageName]SyntaxKind)base.RawKind; }
        }
^
        public override Language Language
        {
            get { return [Properties.LanguageName]Language.Instance; }
        }
^
        public override SyntaxTrivia CreateRed(SyntaxToken parent, int position, int index)
        {
            return new [Properties.LanguageName]SyntaxTrivia(this, parent, position, index);
        }
^
        public override GreenNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
        {
            return new [Properties.LanguageName]GreenTrivia(this.Kind, this.Text, diagnostics, this.GetAnnotations());
        }
^
        public override GreenNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
        {
            return new [Properties.LanguageName]GreenTrivia(this.Kind, this.Text, this.GetDiagnostics(), annotations);
        }
    }
^
	[GenerateGreenToken()]
	[loop(rule:Instances.ParserRules)]
	[GenerateInternalSyntaxRule(rule, null)]
	[end loop]
^
	[GenerateInternalSyntaxFactory()]
}
end template


function string GetCompilationUnitInternal(Antlr4ParserRule rule)
	/*if (rule.HasEof())
		return ", ICompilationUnitInternalSyntax";
	else*/
		return "";
	//end if
end function

function string GetCompilationUnit(Antlr4ParserRule rule)
	if (rule.HasEof())
		return ", ICompilationUnitSyntax";
	else
		return "";
	end if
end function

function string GetInternalElemTypedParamList(Antlr4ParserRule rule, TypeKind kind, bool leadingComma = false, bool trailingComma = false)
	string result = "";
	if (rule.AllElements.Count == 0)
		return result;
	end if
	if (leadingComma)
		result = ", ";
	end if
	loop(elem:rule.AllElements; separator delim = ", ")
		result += elem.GreenType(kind) + " " + elem.FieldName() + delim;
	end loop
	if (trailingComma)
		result += ", ";
	end if
	return result;
end function

function string GetRoslynVisitorElemParamList(Antlr4ParserRule rule, bool leadingComma = false, bool trailingComma = false)
	string result = "";
	if (rule.AllElements.Count == 0)
		return result;
	end if
	if (leadingComma)
		result = ", ";
	end if
	loop(elem:rule.AllElements; separator delim = ", ")
		result += elem.FieldName();
		if (elem.IsList && elem.IsSeparated && elem.IsSimplified) 
			result += "?."+elem.Grammar.FindParserRule(elem.OriginalType).Elements[0].GreenName();
		end if
		result += delim;
	end loop
	if (trailingComma)
		result += ", ";
	end if
	return result;
end function

function string GetElemTypedParamList(Antlr4ParserRule rule, bool leadingComma = false, bool trailingComma = false, bool optional = false)
	string result = "";
	if (rule.AllElements.Count == 0)
		return result;
	end if
	if (leadingComma)
		result = ", ";
	end if
	loop(elem:rule.AllElements where !optional || !(elem.IsOptional || (elem.IsToken && elem.IsFixedToken && !elem.IsList)); separator delim = ", ")
		result += elem.RedType() + " " + elem.FieldName() + delim;
	end loop
	if (trailingComma)
		result += ", ";
	end if
	return result;
end function

function string GetInternalElemParamList(Antlr4ParserRule rule, bool listAsNode = false, bool leadingComma = false, bool trailingComma = false, string prefix = "this.", Antlr4ParserRuleElement skip = null)
	string result = "";
	if (rule.AllElements.Count == 0)
		return result;
	end if
	if (leadingComma)
		result = ", ";
	end if
	loop(elem:rule.AllElements; separator delim = ", ")
		string fieldName = elem.FieldName();
		if (elem.IsList && listAsNode)
			fieldName = fieldName;//+".Node";
		end if
		if (elem == skip)
			result += fieldName+delim;
		else
			result += prefix+fieldName+delim;
		end if
	end loop
	if (trailingComma)
		result += ", ";
	end if
	return result;
end function

function string GetElemNullParamList(Antlr4ParserRule rule, bool leadingComma = false, bool trailingComma = false)
	string result = "";
	if (rule.AllElements.Count == 0)
		return result;
	end if
	if (leadingComma)
		result = ", ";
	end if
	loop(elem:rule.AllElements; separator delim = ", ")
		result += "null"+delim;
	end loop
	if (trailingComma)
		result += ", ";
	end if
	return result;
end function

function string GetElemParamList(Antlr4ParserRule rule, bool leadingComma = false, bool trailingComma = false, string prefix = "this.", Antlr4ParserRuleElement skip = null)
	string result = "";
	if (rule.AllElements.Count == 0)
		return result;
	end if
	if (leadingComma)
		result = ", ";
	end if
	loop(elem:rule.AllElements; separator delim = ", ")
		if (elem == skip)
			result += elem.RedName()+delim;
		else
			result += prefix+elem.RedName()+delim;
		end if
	end loop
	if (trailingComma)
		result += ", ";
	end if
	return result;
end function

function string GetGreenConstructorSimpleAltParamList(Antlr4ParserRule rule, bool leadingComma = false, bool trailingComma = false, Antlr4ParserRuleElement include = null)
	string result = "";
	if (rule.AllElements.Count == 0)
		return result;
	end if
	if (leadingComma)
		result = ", ";
	end if
	loop(elem:rule.AllElements; separator delim = ", ")
		if (elem == include)
			result += elem.FieldName();
			if (elem.IsList)
				//result += ".Node";
			end if
		else
			result += "null";
		end if
		result += delim;
	end loop
	if (trailingComma)
		result += ", ";
	end if
	return result;
end function

function string GetRedToGreenParamElem(Antlr4ParserRuleElement elem, string delim = "")
	string result = "";
	if (elem.IsOptional)
		result += elem.FieldName() + " == null ? null : ";
	end if
	if (elem.IsList)
		if (elem.IsToken)
			result += elem.FieldName()+".Green"+delim;
		else
			if (elem.IsSeparated)
				result += elem.FieldName()+".Green"+delim;
			else
				result += elem.FieldName()+".Green"+delim;
			end if
		end if
	else
		if (elem.IsToken || (elem.IsBlock && elem.IsFixedTokenAltBlock))
			result += "(InternalSyntaxToken)"+elem.FieldName()+".Green"+delim;
		else
			result += "(Syntax.InternalSyntax."+elem.GreenType(TypeKind.Public)+")"+elem.FieldName()+".Green"+delim;
		end if
	end if
	return result;
end function

function string GetRedToGreenParamList(Antlr4ParserRule rule, bool leadingComma = false, bool trailingComma = false, bool optional = false)
	string result = "";
	if (rule.AllElements.Count == 0)
		return result;
	end if
	if (leadingComma)
		result = ", ";
	end if
	loop(elem:rule.AllElements; separator delim = ", ")
		if (optional && (elem.IsOptional || (elem.IsToken && elem.IsFixedToken && !elem.IsList)))
			if (elem.IsToken && elem.IsFixedToken && !elem.IsOptional)
				result += "this.Token("+Properties.LanguageName+"SyntaxKind."+elem.SyntaxKind()+")"+delim;
			else
				result += "null"+delim;
			end if
		else
			if (optional)
				result += elem.FieldName()+delim;
			else
				result += GetRedToGreenParamElem(elem, delim);
			end if
		end if
	end loop
	if (trailingComma)
		result += ", ";
	end if
	return result;
end function

function string GetInternalElemUpdateList(Antlr4ParserRule rule)
	string result = "";
	loop(elem:rule.AllElements; separator delim = " ||\n\t\t\t")
		if (elem.IsList)
			result += "this."+elem.FieldName()+" != "+elem.FieldName()/*+".Node"*/+delim;
		else
			result += "this."+elem.FieldName()+" != "+elem.FieldName()+delim;
		end if
	end loop
	return result;
end function

function string GetElemUpdateList(Antlr4ParserRule rule)
	string result = "";
	loop(elem:rule.AllElements; separator delim = " ||\n\t\t\t")
		if (elem.IsList && !elem.IsToken)
			result += "this."+elem.RedName()+".Node != "+elem.FieldName()+".Node"+delim;
		else
			result += "this."+elem.RedName()+" != "+elem.FieldName()+delim;
		end if
	end loop
	return result;
end function

template GenerateInternalSyntaxRule(Antlr4ParserRule rule, Antlr4ParserRule superRule)
[if (rule.Alternatives.Count > 0)]
^
internal abstract class [rule.GreenName()] : [Properties.LanguageName]GreenNode
{
^
    public [rule.GreenName()]([Properties.LanguageName]SyntaxKind kind, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
        : base(kind, diagnostics, annotations)
    {
    }
}
	[loop(alt:rule.Alternatives)]
[GenerateInternalSyntaxRule(alt, rule)]
	[end loop]
[else]
^
	[if (superRule != null)]
internal class [rule.GreenName()] : [superRule.GreenName()][GetCompilationUnitInternal(rule)]
	[else]
internal class [rule.GreenName()] : [Properties.LanguageName]GreenNode[GetCompilationUnitInternal(rule)]
	[end if]
{
	[loop(elem:rule.AllElements)]
    private [elem.GreenType(TypeKind.Field)] [elem.FieldName()];
	[end loop]
^
    public [rule.GreenName()]([Properties.LanguageName]SyntaxKind kind[GetInternalElemTypedParamList(rule, TypeKind.Field, true)])
        : base(kind, null, null)
    {
		[loop(elem:rule.AllElements)]
		if ([elem.FieldName()] != null)
		{
			this.AdjustFlagsAndWidth([elem.FieldName()]);
			this.[elem.FieldName()] = [elem.FieldName()];
		}
		[end loop]
    }
^
    public [rule.GreenName()]([Properties.LanguageName]SyntaxKind kind[GetInternalElemTypedParamList(rule, TypeKind.Field, true)], DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
        : base(kind, diagnostics, annotations)
    {
		[loop(elem:rule.AllElements)]
		if ([elem.FieldName()] != null)
		{
			this.AdjustFlagsAndWidth([elem.FieldName()]);
			this.[elem.FieldName()] = [elem.FieldName()];
		}
		[end loop]
    }
^
	public override int SlotCount { get { return [rule.AllElements.Count]; } }
^
	[loop(elem:rule.AllElements)]
    public [elem.GreenType(TypeKind.Public)] [elem.GreenName()] { get { return this.[elem.FieldName()]; } }
	[end loop]
^
    public override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
        return new global::[Properties.DefaultNamespace].Syntax.[rule.RedName()](this, parent, position);
    }
^
    public override GreenNode GetSlot(int index)
    {
        switch (index)
        {
			[loop(i:CompilerGeneratorUtils.Range(rule.AllElements.Count))]
            case [i]: return this.[rule.AllElements[i].FieldName()];
			[end loop]
            default: return null;
        }
    }
^
    public override GreenNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
    {
        return new [rule.GreenName()](this.Kind, [GetInternalElemParamList(rule, false, false, true)]diagnostics, this.GetAnnotations());
    }
^
    public override GreenNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
    {
        return new [rule.GreenName()](this.Kind, [GetInternalElemParamList(rule, false, false, true)]this.GetDiagnostics(), annotations);
    }
	[if (rule.IsSimpleAlt)]
		[loop(elem:rule.Elements)]
^
    public [rule.GreenName()] Update([elem.GreenType(TypeKind.Public)] [elem.FieldName()])
    {
        if (this.[elem.FieldName()] != [elem.FieldName()])
        {
            GreenNode newNode = [Properties.LanguageName]Language.Instance.InternalSyntaxFactory.[rule.PlainName()]([elem.FieldName()]);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
			return ([rule.GreenName()])newNode;
        }
        return this;
    }
		[end loop]
	[else]
^
    public [rule.GreenName()] Update([GetInternalElemTypedParamList(rule, TypeKind.Public)])
    {
        if ([GetInternalElemUpdateList(rule)])
        {
            GreenNode newNode = [Properties.LanguageName]Language.Instance.InternalSyntaxFactory.[rule.PlainName()]([GetInternalElemParamList(rule, false, false, false, "")]);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
			return ([rule.GreenName()])newNode;
        }
        return this;
    }
	[end if]
}
[end if]
end template

template GenerateInternalSyntaxFactory()
internal class [Properties.LanguageName]GreenFactory : InternalSyntaxFactory
{
    internal static readonly [Properties.LanguageName]GreenFactory Instance = new [Properties.LanguageName]GreenFactory();
^
	public new [Properties.LanguageName]Language Language
	{
		get { return [Properties.LanguageName]Language.Instance; }
	}
^
	protected override Language LanguageCore
	{
		get { return this.Language; }
	}
^
	public [Properties.LanguageName]GreenTrivia Trivia([Properties.LanguageName]SyntaxKind kind, string text)
	{
	    return new [Properties.LanguageName]GreenTrivia(kind, text, null, null);
	}
^
	public override InternalSyntaxTrivia Trivia(int kind, string text)
	{
	    return new [Properties.LanguageName]GreenTrivia(([Properties.LanguageName]SyntaxKind)kind, text, null, null);
	}
^
	public [Properties.LanguageName]GreenToken MissingToken([Properties.LanguageName]SyntaxKind kind)
	{
	    return [Properties.LanguageName]GreenToken.CreateMissing(kind, null, null);
	}
^
	public override InternalSyntaxToken MissingToken(int kind)
	{
	    return [Properties.LanguageName]GreenToken.CreateMissing(([Properties.LanguageName]SyntaxKind)kind, null, null);
	}
^
	public [Properties.LanguageName]GreenToken MissingToken(GreenNode leading, [Properties.LanguageName]SyntaxKind kind, GreenNode trailing)
	{
	    return [Properties.LanguageName]GreenToken.CreateMissing(kind, leading, trailing);
	}
^
	public override InternalSyntaxToken MissingToken(GreenNode leading, int kind, GreenNode trailing)
	{
	    return [Properties.LanguageName]GreenToken.CreateMissing(([Properties.LanguageName]SyntaxKind)kind, leading, trailing);
	}
^
	public [Properties.LanguageName]GreenToken Token([Properties.LanguageName]SyntaxKind kind)
	{
	    return [Properties.LanguageName]GreenToken.Create(kind);
	}
^
	public override InternalSyntaxToken Token(int kind)
	{
	    return [Properties.LanguageName]GreenToken.Create(([Properties.LanguageName]SyntaxKind)kind);
	}
^
    public [Properties.LanguageName]GreenToken Token(GreenNode leading, [Properties.LanguageName]SyntaxKind kind, GreenNode trailing)
	{
	    return [Properties.LanguageName]GreenToken.Create(kind, leading, trailing);
	}
^
    public override InternalSyntaxToken Token(GreenNode leading, int kind, GreenNode trailing)
	{
	    return [Properties.LanguageName]GreenToken.Create(([Properties.LanguageName]SyntaxKind)kind, leading, trailing);
	}
^
    public [Properties.LanguageName]GreenToken Token(GreenNode leading, [Properties.LanguageName]SyntaxKind kind, string text, GreenNode trailing)
	{
	    Debug.Assert([Properties.LanguageName]Language.Instance.SyntaxFacts.IsToken(kind));
	    string defaultText = [Properties.LanguageName]Language.Instance.SyntaxFacts.GetText(kind);
	    return kind >= [Properties.LanguageName]GreenToken.FirstTokenWithWellKnownText && kind <= [Properties.LanguageName]GreenToken.LastTokenWithWellKnownText && text == defaultText
	        ? this.Token(leading, kind, trailing)
	        : [Properties.LanguageName]GreenToken.WithText(kind, leading, text, trailing);
	}
^
    public override InternalSyntaxToken Token(GreenNode leading, int kind, string text, GreenNode trailing)
    {
        return this.Token(leading, ([Properties.LanguageName]SyntaxKind)kind, text, trailing);
    }
^
    public [Properties.LanguageName]GreenToken Token(GreenNode leading, [Properties.LanguageName]SyntaxKind kind, string text, string valueText, GreenNode trailing)
	{
	    Debug.Assert([Properties.LanguageName]Language.Instance.SyntaxFacts.IsToken(kind));
	    string defaultText = [Properties.LanguageName]Language.Instance.SyntaxFacts.GetText(kind);
	    return kind >= [Properties.LanguageName]GreenToken.FirstTokenWithWellKnownText && kind <= [Properties.LanguageName]GreenToken.LastTokenWithWellKnownText && text == defaultText && defaultText.Equals(valueText)
	        ? this.Token(leading, kind, trailing)
	        : [Properties.LanguageName]GreenToken.WithValue(kind, leading, text, valueText, trailing);
	}
^
    public override InternalSyntaxToken Token(GreenNode leading, int kind, string text, string valueText, GreenNode trailing)
    {
        return this.Token(leading, ([Properties.LanguageName]SyntaxKind)kind, text, valueText, trailing);
    }
^
    public [Properties.LanguageName]GreenToken Token(GreenNode leading, [Properties.LanguageName]SyntaxKind kind, string text, object value, GreenNode trailing)
	{
	    Debug.Assert([Properties.LanguageName]Language.Instance.SyntaxFacts.IsToken(kind));
	    string defaultText = [Properties.LanguageName]Language.Instance.SyntaxFacts.GetText(kind);
	    return kind >= [Properties.LanguageName]GreenToken.FirstTokenWithWellKnownText && kind <= [Properties.LanguageName]GreenToken.LastTokenWithWellKnownText && text == defaultText && defaultText.Equals(value)
	        ? this.Token(leading, kind, trailing)
	        : [Properties.LanguageName]GreenToken.WithValue(kind, leading, text, value, trailing);
	}
^
    public override InternalSyntaxToken Token(GreenNode leading, int kind, string text, object value, GreenNode trailing)
    {
        return this.Token(leading, ([Properties.LanguageName]SyntaxKind)kind, text, value, trailing);
    }
^
    public [Properties.LanguageName]GreenToken BadToken(GreenNode leading, string text, GreenNode trailing)
	{
	    return [Properties.LanguageName]GreenToken.WithText([Properties.LanguageName]SyntaxKind.BadToken, leading, text, trailing);
	}
^
[loop(rule:Instances.LexerRules where rule.FixedToken == null)]
^
    internal [Properties.LanguageName]GreenToken [rule.PlainName()](string text)
    {
        return Token(null, [Properties.LanguageName]SyntaxKind.[rule.PlainName()], text, null);
    }
^
    internal [Properties.LanguageName]GreenToken [rule.PlainName()](string text, object value)
    {
        return Token(null, [Properties.LanguageName]SyntaxKind.[rule.PlainName()], text, value, null);
    }
[end loop]
[loop(rule:Instances.ParserRules)]
	[if (rule.Alternatives.Count > 0)]
		[loop(alt:rule.Alternatives)]
[GenerateInternalSyntaxFactoryCreate(alt)]
		[end loop]
	[else]
[GenerateInternalSyntaxFactoryCreate(rule)]
	[end if]
[end loop]
^
    internal IEnumerable<Type> GetNodeTypes()
    {
        return new Type["[]"] {
[loop(rule:Instances.ParserRules)]
	[if (rule.Alternatives.Count > 0)]
		[loop(alt:rule.Alternatives)]
			typeof([alt.GreenName()]),
		[end loop]
	[else]
			typeof([rule.GreenName()]),
	[end if]
[end loop]
		};
	}
}
end template

template GenerateInternalSyntaxFactoryCreate(Antlr4ParserRule rule)
[if (rule.IsSimpleAlt)]
	[loop(elem:rule.Elements)]
^
	public [rule.GreenName()] [rule.PlainName()]([elem.GreenType(TypeKind.Public)] [elem.FieldName()], bool errorNode = false)
    {
#if DEBUG
		if (!errorNode)
		{
		[if (!elem.IsOptional)]
			[if (!elem.IsList)]
	        if ([elem.FieldName()] == null) throw new ArgumentNullException(nameof([elem.FieldName()]));
			[end if]
			[if (elem.IsToken && !elem.IsList)]
			if ([elem.FieldName()].RawKind != (int)[Properties.LanguageName]SyntaxKind.[elem.SyntaxKind()]) throw new ArgumentException(nameof([elem.FieldName()]));
			[end if]
		[else]
			[if (elem.IsToken && !elem.IsList)]
			if ([elem.FieldName()] != null && [elem.FieldName()].RawKind != (int)[Properties.LanguageName]SyntaxKind.[elem.SyntaxKind()]) throw new ArgumentException(nameof([elem.FieldName()]));
			[end if]
		[end if]
		}
#endif
		[if (rule.Elements.Count <= 3)]
		int hash;
		[if (elem.IsList)]
		var cached = SyntaxNodeCache.TryGetNode((int)[Properties.LanguageName]SyntaxKind.[rule.PlainName()], [elem.FieldName()].Name, out hash);
		[else]
		var cached = SyntaxNodeCache.TryGetNode((int)[Properties.LanguageName]SyntaxKind.[rule.PlainName()], [elem.FieldName()], out hash);
		[end if]
		if (cached != null) return ([rule.GreenName()])cached;
		
		var result = new [rule.GreenName()]([Properties.LanguageName]SyntaxKind.[rule.PlainName()][GetGreenConstructorSimpleAltParamList(rule, true, false, elem)]);
		if (hash >= 0)
		{
			SyntaxNodeCache.AddNode(result, hash);
		}
		return result;
		[else]
		return new [rule.GreenName()]([Properties.LanguageName]SyntaxKind.[rule.PlainName()][GetGreenConstructorSimpleAltParamList(rule, true, false, elem)]);
		[end if]
    }
	[end loop]
[else]
^
	public [rule.GreenName()] [rule.PlainName()]([GetInternalElemTypedParamList(rule, TypeKind.Public, false, true)]bool errorNode = false)
    {
#if DEBUG
		if (!errorNode)
		{
		[loop(elem:rule.AllElements)]
			[if (!elem.IsOptional)]
				[if (!elem.IsList)]
			if ([elem.FieldName()] == null) throw new ArgumentNullException(nameof([elem.FieldName()]));
				[end if]
				[if (elem.IsToken && !elem.IsList)]
			if ([elem.FieldName()].RawKind != (int)[Properties.LanguageName]SyntaxKind.[elem.SyntaxKind()]) throw new ArgumentException(nameof([elem.FieldName()]));
				[end if]
			[else]
				[if (elem.IsToken && !elem.IsList)]
			if ([elem.FieldName()] != null && [elem.FieldName()].RawKind != (int)[Properties.LanguageName]SyntaxKind.[elem.SyntaxKind()]) throw new ArgumentException(nameof([elem.FieldName()]));
				[end if]
			[end if]
		[end loop]
		}
#endif
		[if (rule.AllElements.Count <= 3)]
		int hash;
		var cached = SyntaxNodeCache.TryGetNode((int)[Properties.LanguageName]SyntaxKind.[rule.PlainName()][GetInternalElemParamList(rule, true, true, false, "")], out hash);
		if (cached != null) return ([rule.GreenName()])cached;
		
		var result = new [rule.GreenName()]([Properties.LanguageName]SyntaxKind.[rule.PlainName()][GetInternalElemParamList(rule, true, true, false, "")]);
		if (hash >= 0)
		{
			SyntaxNodeCache.AddNode(result, hash);
		}
		
		return result;
		[else]
        return new [rule.GreenName()]([Properties.LanguageName]SyntaxKind.[rule.PlainName()][GetInternalElemParamList(rule, true, true, false, "")]);
		[end if]
    }
[end if]
end template

template GenerateSyntax()
// !!!!!!!
// WARNING: This is an auto-generated file. Any manual changes will be lost when the file is regenerated.
// !!!!!!!
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MetaDslx.Compiler.Diagnostics;
using MetaDslx.Compiler.Syntax;
using MetaDslx.Compiler.Syntax.InternalSyntax;
^
namespace [Properties.DefaultNamespace].Syntax
{
	public enum [Properties.LanguageName]SyntaxKind : int
	{
        None                          = SyntaxKind.None,
        List                          = SyntaxKind.List,
        BadToken                      = SyntaxKind.BadToken,
        Eof                           = SyntaxKind.Eof,
^
		// Tokens:
		[loop(rule:Instances.LexerRules)]
			[if (Instances.LexerRules[0] == rule)]
		[rule.PlainName()] = [rule.Kind],
			[else]
		[rule.PlainName()],
			[end if]
		[end loop]
^
		// Rules:
		[loop(rule:Instances.ParserRules)]
		[if (rule.Alternatives.Count > 0)]
			[loop(alt:rule.Alternatives)]
		[alt.PlainName()],
			[end loop]
		[else]
		[rule.PlainName()],
		[end if]
		[end loop]
	}
^
    public abstract class [Properties.LanguageName]SyntaxNode : SyntaxNode
    {
        protected [Properties.LanguageName]SyntaxNode(InternalSyntaxNode green, SyntaxTree syntaxTree, int position)
            : base(green, syntaxTree, position)
        {
        }
^
        protected [Properties.LanguageName]SyntaxNode(InternalSyntaxNode green, SyntaxNode parent, int position)
            : base(green, parent, position)
        {
        }
^
        public [Properties.LanguageName]SyntaxKind Kind
        {
            get { return ([Properties.LanguageName]SyntaxKind)base.RawKind; }
        }
^
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            I[Properties.LanguageName]SyntaxVisitor<TResult> typedVisitor = visitor as I[Properties.LanguageName]SyntaxVisitor<TResult>;
            if (typedVisitor != null)
            {
                return this.Accept(typedVisitor);
            }
            return default(TResult);
        }
^
        public abstract TResult Accept<TResult>(I[Properties.LanguageName]SyntaxVisitor<TResult> visitor);
^
        public override void Accept(SyntaxVisitor visitor)
        {
            I[Properties.LanguageName]SyntaxVisitor typedVisitor = visitor as I[Properties.LanguageName]SyntaxVisitor;
            if (typedVisitor != null)
            {
                this.Accept(typedVisitor);
            }
        }

        public abstract void Accept(I[Properties.LanguageName]SyntaxVisitor visitor);
    }
^
    public class [Properties.LanguageName]SyntaxTrivia : SyntaxTrivia
    {
        public [Properties.LanguageName]SyntaxTrivia(InternalSyntaxTrivia green, SyntaxToken token, int position, int index)
            : base(green, token, position, index)
        {
        }
^
        public [Properties.LanguageName]SyntaxKind Kind
        {
            get { return ([Properties.LanguageName]SyntaxKind)base.RawKind; }
        }
    }
^
    public class [Properties.LanguageName]SyntaxToken : SyntaxToken
    {
        public [Properties.LanguageName]SyntaxToken(InternalSyntaxToken green, SyntaxNode parent, int position, int index)
            : base(green, parent, position, index)
        {
        }
^
        public [Properties.LanguageName]SyntaxKind Kind
        {
            get { return ([Properties.LanguageName]SyntaxKind)base.RawKind; }
        }
^
        protected override SyntaxToken WithLeadingTriviaCore(InternalSyntaxTrivia["[]"] leading)
        {
            return new [Properties.LanguageName]SyntaxToken(this.GreenToken.WithLeadingTrivia(new InternalSyntaxTriviaList(leading, null, null)), null, 0, 0);
        }
^
        protected override SyntaxToken WithTrailingTriviaCore(InternalSyntaxTrivia["[]"] trailing)
        {
            return new [Properties.LanguageName]SyntaxToken(this.GreenToken.WithTrailingTrivia(new InternalSyntaxTriviaList(trailing, null, null)), null, 0, 0);
        }
    }
	[loop(rule:Instances.ParserRules)]
	[GenerateSyntaxRule(rule, null)]
	[end loop]
}
^
namespace [Properties.DefaultNamespace]
{
    using System.Threading;
    using MetaDslx.Compiler;
    using MetaDslx.Compiler.Text;
	using [Properties.DefaultNamespace].Syntax;
    using [Properties.DefaultNamespace].Syntax.InternalSyntax;
^
	[GenerateSyntaxVisitor()]
^
	[GenerateDetailedSyntaxVisitor()]
^
	[GenerateSyntaxTypedVisitor()]
^
	[GenerateSyntaxRewriter()]
^
	[GenerateSyntaxFactory()]
}
end template

template GenerateSyntaxRule(Antlr4ParserRule rule, Antlr4ParserRule superRule)
[if (rule.Alternatives.Count > 0)]
^
public abstract class [rule.RedName()] : [Properties.LanguageName]SyntaxNode
{
    protected [rule.RedName()](InternalSyntaxNode green, SyntaxTree syntaxTree, int position)
        : base(green, syntaxTree, position)
    {
    }
^
    protected [rule.RedName()](InternalSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }
}
	[loop(alt:rule.Alternatives)]
[GenerateSyntaxRule(alt, rule)]
	[end loop]
[else]
^
	[if (superRule != null)]
public sealed class [rule.RedName()] : [superRule.RedName()][GetCompilationUnit(rule)]
	[else]
public sealed class [rule.RedName()] : [Properties.LanguageName]SyntaxNode[GetCompilationUnit(rule)]
	[end if]
{
	[loop(elem:rule.AllElements)]
		[if (elem.IsParserRule)]
    private [elem.RedFieldType()] [elem.FieldName()];
		[end if]
	[end loop]
^
    public [rule.RedName()](InternalSyntaxNode green, SyntaxTree syntaxTree, int position)
        : base(green, syntaxTree, position)
    {
    }
^
    public [rule.RedName()](InternalSyntaxNode green, SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }
^
	[loop(elem:rule.AllElements)]
		[if (elem.IsList)]
    public [elem.RedType()] [elem.RedName()] 
	{ 
		get
		{
			[if (elem.IsToken)]
			var slot = this.Green.GetSlot([rule.IndexOf(elem)]);
			if (slot != null)
			{
				return new [elem.RedType()](this, slot, this.GetChildPosition([rule.IndexOf(elem)]), this.GetChildIndex([rule.IndexOf(elem)]));
			}
			return SyntaxTokenList.Empty;
			[else]
			var red = this.GetRed(ref this.[elem.FieldName()], [rule.IndexOf(elem)]);
			if (red != null)
			{
				return new [elem.RedType()](red);
			}
			return null;
			[end if]
		} 
	}
		[else]
			[if (elem.IsToken || elem.IsFixedTokenAltBlock)]
    public [elem.RedType()] [elem.RedName()] 
	{ 
		get 
		{ 
			var green = (global::[Properties.DefaultNamespace].Syntax.InternalSyntax.[rule.GreenName()])this.Green;
			var greenToken = green.[elem.GreenName()];
			return greenToken == null ? null : new [Properties.LanguageName]SyntaxToken(greenToken, this, this.GetChildPosition([rule.IndexOf(elem)]), this.GetChildIndex([rule.IndexOf(elem)])); 
		}
	}
			[else]
    public [elem.RedType()] [elem.RedName()] 
	{ 
		get { return this.GetRed(ref this.[elem.FieldName()], [rule.IndexOf(elem)]); } 
	}
			[end if]
		[end if]
	[end loop]
^
    public override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
			[loop(elem:rule.AllElements)]
				[if (elem.IsParserRule)]
			case [rule.IndexOf(elem)]: return this.GetRed(ref this.[elem.FieldName()], [rule.IndexOf(elem)]);
				[end if]
			[end loop]
			default: return null;
        }
    }
^
    public override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
			[loop(elem:rule.AllElements)]
				[if (elem.IsParserRule)]
			case [rule.IndexOf(elem)]: return this.[elem.FieldName()];
				[end if]
			[end loop]
			default: return null;
        }
    }
	[loop(elem:rule.AllElements)]
^
    public [rule.RedName()] With[elem.RedName()]([elem.RedType()] [elem.FieldName()])
	{
		[if (rule.IsSimpleAlt)]
		return this.Update([elem.FieldName()]);
		[else]
		return this.Update([GetElemParamList(rule, false, false, "this.", elem)]);
		[end if]
	}
		[if (elem.IsList && !elem.IsToken)]
^
    public [rule.RedName()] Add[elem.RedName()](params [elem.RedInnerType()]["[]"] [elem.FieldName()])
	{
		return this.With[elem.RedName()](this.[elem.RedName()].AddRange([elem.FieldName()]));
	}
		[end if]
	[end loop]
	[if (rule.IsSimpleAlt)]
		[loop(elem:rule.Elements)]
^
    public [rule.RedName()] Update([elem.RedType()] [elem.FieldName()])
    {
        if (this.[elem.RedName()] != [elem.FieldName()])
        {
            SyntaxNode newNode = [Properties.LanguageName]Language.Instance.SyntaxFactory.[rule.PlainName()]([elem.FieldName()]);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
			return ([rule.RedName()])newNode;
        }
        return this;
    }
		[end loop]
	[else]
^
    public [rule.RedName()] Update([GetElemTypedParamList(rule)])
    {
        if ([GetElemUpdateList(rule)])
        {
            SyntaxNode newNode = [Properties.LanguageName]Language.Instance.SyntaxFactory.[rule.PlainName()]([GetInternalElemParamList(rule, false, false, false, "")]);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
			return ([rule.RedName()])newNode;
        }
        return this;
    }
	[end if]
^
    public override TResult Accept<TResult>(I[Properties.LanguageName]SyntaxVisitor<TResult> visitor)
    {
        return visitor.Visit[rule.PlainName()](this);
    }
^
    public override void Accept(I[Properties.LanguageName]SyntaxVisitor visitor)
    {
        visitor.Visit[rule.PlainName()](this);
    }
}
[end if]
end template

template GenerateSyntaxFacts()
using System.Threading;
using MetaDslx.Compiler;
using MetaDslx.Compiler.Syntax;
using MetaDslx.Compiler.Text;
using [Properties.DefaultNamespace].Syntax;
using [Properties.DefaultNamespace].Syntax.InternalSyntax;
^
namespace [Properties.DefaultNamespace]
{
	public enum [Properties.LanguageName]TokenKind
	{
		None,
		[loop (kind:Instances.LexerTokenKinds; separator sep=",")]
		[kind.Key][sep]
		[end loop]
	}
^
	public class [Properties.LanguageName]SyntaxFacts : SyntaxFacts
	{
		internal static readonly [Properties.LanguageName]SyntaxFacts Instance = new [Properties.LanguageName]SyntaxFacts();
^
		protected override int DefaultEndOfLineSyntaxKindCore
		{
			get { return (int)[Properties.LanguageName]SyntaxKind.[Instances.DefaultEndOfLine != null ? Instances.DefaultEndOfLine.PlainName() : "None"]; }
		}
^
		protected override int DefaultWhitespaceSyntaxKindCore
		{
			get { return (int)[Properties.LanguageName]SyntaxKind.[Instances.DefaultWhitespace != null ? Instances.DefaultWhitespace.PlainName() : "None"]; }
		}
^
		public override bool IsToken(int rawKind)
		{
			return this.IsToken(([Properties.LanguageName]SyntaxKind)rawKind);
		}
^
		public bool IsToken([Properties.LanguageName]SyntaxKind kind)
		{
			switch (kind)
			{
				case [Properties.LanguageName]SyntaxKind.Eof:
				[loop(literal:Instances.LexerRules)]
				case [Properties.LanguageName]SyntaxKind.[literal.PlainName()]:
				[end loop]
					return true;
				default:
					return false;
			}
		}
^
		public override bool IsFixedToken(int rawKind)
		{
			return this.IsFixedToken(([Properties.LanguageName]SyntaxKind)rawKind);
		}
^
		public bool IsFixedToken([Properties.LanguageName]SyntaxKind kind)
		{
			switch (kind)
			{
				case [Properties.LanguageName]SyntaxKind.Eof:
				[loop(literal:Instances.FixedTokens)]
				case [Properties.LanguageName]SyntaxKind.[literal.PlainName()]:
				[end loop]
					return true;
				default:
					return false;
			}
		}
^
		public override string GetText(int rawKind)
		{
			return this.GetText(([Properties.LanguageName]SyntaxKind)rawKind);
		}
^
		public string GetText([Properties.LanguageName]SyntaxKind kind)
		{
			switch (kind)
			{
				[loop(literal:Instances.FixedTokens)]
				case [Properties.LanguageName]SyntaxKind.[literal.PlainName()]:
					return [literal.FixedToken.FixedTokenToCSharpString()];
				[end loop]
				default:
					return string.Empty;
			}
		}
^
		public [Properties.LanguageName]SyntaxKind GetKind(string text)
		{
			switch (text)
			{
				[loop(literal:Instances.FixedTokens)]
				case [literal.FixedToken.FixedTokenToCSharpString()]:
					return [Properties.LanguageName]SyntaxKind.[literal.PlainName()];
				[end loop]
				default:
					return [Properties.LanguageName]SyntaxKind.None;
			}
		}
^
		public override string GetKindText(int rawKind)
		{
			return this.GetKindText(([Properties.LanguageName]SyntaxKind)rawKind);
		}
^
		public string GetKindText([Properties.LanguageName]SyntaxKind kind)
		{
			return kind.ToString();
		}
^
		public override bool IsTriviaWithEndOfLine(int rawKind)
		{
			return this.IsTriviaWithEndOfLine(([Properties.LanguageName]SyntaxKind)rawKind);
		}
^
		public bool IsTriviaWithEndOfLine([Properties.LanguageName]SyntaxKind kind)
		{
			switch(kind)
			{
			[loop (rule:Instances.LexerRules where rule.Annotations.HasAnnotation("Token"))]
				[MetaCompilerAnnotation annot = rule.Annotations.GetAnnotation("Token")]
				[if (annot.HasProperty("endOfLine") && annot.GetValue("endOfLine") == "true")]
					[if (annot.HasProperty("first") && annot.HasProperty("last"))]
						[loop (child:Instances.LexerRulesBetween(annot.GetValue("first"), annot.GetValue("last")))]
				case [Properties.LanguageName]SyntaxKind.[child.PlainName()]:
						[end loop]
					return true;
					[else]
				case [Properties.LanguageName]SyntaxKind.[rule.PlainName()]:
					return true;
					[end if]
				[end if]
			[end loop]
				default:
					return false;
			}
		}
^
	[loop (kind:Instances.LexerTokenKinds)]
		public bool Is[kind.Key](int rawKind)
		{
			return this.Is[kind.Key](([Properties.LanguageName]SyntaxKind)rawKind);
		}
^
		public bool Is[kind.Key]([Properties.LanguageName]SyntaxKind kind)
		{
			switch(kind)
			{
			[loop (rule:kind.Value)]
				[MetaCompilerAnnotation annot = rule.Annotations.GetAnnotation("Token")]
				[if (annot.HasProperty("first") && annot.HasProperty("last"))]
					[loop (child:Instances.LexerRulesBetween(annot.GetValue("first"), annot.GetValue("last")))]
				case [Properties.LanguageName]SyntaxKind.[child.PlainName()]:
					[end loop]
					return true;
				[else]
				case [Properties.LanguageName]SyntaxKind.[rule.PlainName()]:
					return true;
				[end if]
			[end loop]
				default:
					return false;
			}
		}
	[end loop]
^
		public [Properties.LanguageName]TokenKind GetTokenKind(int rawKind)
		{
			return this.GetTokenKind(([Properties.LanguageName]SyntaxKind)rawKind);
		}
^
		public [Properties.LanguageName]TokenKind GetTokenKind([Properties.LanguageName]SyntaxKind kind)
		{
			switch(kind)
			{
			[loop (rule:Instances.LexerRules where rule.Annotations.HasAnnotation("Token"))]
				[MetaCompilerAnnotation annot = rule.Annotations.GetAnnotation("Token")]
				[if (annot.HasProperty("first") && annot.HasProperty("last"))]
					[loop (child:Instances.LexerRulesBetween(annot.GetValue("first"), annot.GetValue("last")))]
				case [Properties.LanguageName]SyntaxKind.[child.PlainName()]:
					[end loop]
					return [Properties.LanguageName]TokenKind.[annot.GetValue("kind")];
				[else]
				case [Properties.LanguageName]SyntaxKind.[rule.PlainName()]:
					return [Properties.LanguageName]TokenKind.[annot.GetValue("kind")];
				[end if]
			[end loop]
				default:
					return [Properties.LanguageName]TokenKind.None;
			}
		}
	}
}
end template

template GenerateSyntaxVisitor()
public interface I[Properties.LanguageName]SyntaxVisitor
{
   	[loop(rule:Instances.ParserRules)]
		[if (rule.Alternatives.Count > 0)]
			[loop(alt:rule.Alternatives)]
	[GenerateSyntaxVisitorVisit(alt, true)]
			[end loop]
		[else]
	[GenerateSyntaxVisitorVisit(rule, true)]
		[end if]
	[end loop]
}
^
public class [Properties.LanguageName]SyntaxVisitor : SyntaxVisitor, I[Properties.LanguageName]SyntaxVisitor
{
   	[loop(rule:Instances.ParserRules)]
		[if (rule.Alternatives.Count > 0)]
			[loop(alt:rule.Alternatives)]
	[GenerateSyntaxVisitorVisit(alt, false)]
			[end loop]
		[else]
	[GenerateSyntaxVisitorVisit(rule, false)]
		[end if]
	[end loop]
}
end template

template GenerateSyntaxVisitorVisit(Antlr4ParserRule rule, bool intf)
^
[if (intf)]
void Visit[rule.PlainName()]([rule.RedName()] node);
[else]
public virtual void Visit[rule.PlainName()]([rule.RedName()] node)
{
    this.DefaultVisit(node);
}
[end if]
end template

template GenerateSyntaxTypedVisitor()
public interface I[Properties.LanguageName]SyntaxVisitor<TResult> 
{
   	[loop(rule:Instances.ParserRules)]
		[if (rule.Alternatives.Count > 0)]
			[loop(alt:rule.Alternatives)]
	[GenerateSyntaxTypedVisitorVisit(alt, true)]
			[end loop]
		[else]
	[GenerateSyntaxTypedVisitorVisit(rule, true)]
		[end if]
	[end loop]
}
^
public class [Properties.LanguageName]SyntaxVisitor<TResult> : SyntaxVisitor<TResult>, I[Properties.LanguageName]SyntaxVisitor<TResult>
{
   	[loop(rule:Instances.ParserRules)]
		[if (rule.Alternatives.Count > 0)]
			[loop(alt:rule.Alternatives)]
	[GenerateSyntaxTypedVisitorVisit(alt, false)]
			[end loop]
		[else]
	[GenerateSyntaxTypedVisitorVisit(rule, false)]
		[end if]
	[end loop]
}
end template

template GenerateSyntaxTypedVisitorVisit(Antlr4ParserRule rule, bool intf)
^
[if (intf)]
TResult Visit[rule.PlainName()]([rule.RedName()] node);
[else]
public virtual TResult Visit[rule.PlainName()]([rule.RedName()] node)
{
    return this.DefaultVisit(node);
}
[end if]
end template

template GenerateDetailedSyntaxVisitor()
public class [Properties.LanguageName]DetailedSyntaxVisitor : DetailedSyntaxVisitor, I[Properties.LanguageName]SyntaxVisitor
{
    public [Properties.LanguageName]DetailedSyntaxVisitor(bool visitIntoStructuredToken = false, bool visitIntoStructuredTrivia = false)
		: base(visitIntoStructuredToken, visitIntoStructuredTrivia)
    {
    }
   	[loop(rule:Instances.ParserRules)]
		[if (rule.Alternatives.Count > 0)]
			[loop(alt:rule.Alternatives)]
	[GenerateDetailedSyntaxVisitorVisit(alt)]
			[end loop]
		[else]
	[GenerateDetailedSyntaxVisitorVisit(rule)]
		[end if]
	[end loop]
}
end template

template GenerateDetailedSyntaxVisitorVisit(Antlr4ParserRule rule)
^
public virtual void Visit[rule.PlainName()]([rule.RedName()] node)
{
	[if (rule.IsSimpleAlt)]
		[loop(elem:rule.Elements)]
			[if (elem.IsList)]
	this.VisitList(node.[elem.RedName()]);
			[else]
				[if (elem.IsToken || elem.IsFixedTokenAltBlock)]
	this.Visit(node.[elem.RedName()]);
				[else]
	this.Visit(node.[elem.RedName()]);
				[end if]
			[end if]
		[end loop] 
	[else]
		[loop(elem:rule.AllElements)]
			[if (elem.IsList)]
	this.VisitList(node.[elem.RedName()]);
			[else]
				[if (elem.IsToken || elem.IsFixedTokenAltBlock)]
	this.VisitToken(node.[elem.RedName()]);
				[else]
	this.Visit(node.[elem.RedName()]);
				[end if]
			[end if]
		[end loop]    
	[end if]
}
end template

template GenerateSyntaxRewriter()
public class [Properties.LanguageName]SyntaxRewriter : SyntaxRewriter, I[Properties.LanguageName]SyntaxVisitor<SyntaxNode>
{
    public [Properties.LanguageName]SyntaxRewriter(bool visitIntoStructuredToken = false, bool visitIntoStructuredTrivia = false)
		: base(visitIntoStructuredToken, visitIntoStructuredTrivia)
    {
    }
   	[loop(rule:Instances.ParserRules)]
		[if (rule.Alternatives.Count > 0)]
			[loop(alt:rule.Alternatives)]
	[GenerateSyntaxRewriterVisit(alt)]
			[end loop]
		[else]
	[GenerateSyntaxRewriterVisit(rule)]
		[end if]
	[end loop]
}
end template

template GenerateSyntaxRewriterVisit(Antlr4ParserRule rule)
^
public virtual SyntaxNode Visit[rule.PlainName()]([rule.RedName()] node)
{
	[if (rule.IsSimpleAlt)]
		[loop(elem:rule.Elements)]
	var old[elem.RedName()] = node.[elem.RedName()];
	if (old[elem.RedName()] != null)
	{
			[if (elem.IsList)]
		var new[elem.RedName()] = this.VisitList(old[elem.RedName()]);
			[else]
				[if (elem.IsToken || elem.IsFixedTokenAltBlock)]
		var new[elem.RedName()] = (InternalSyntaxToken)this.Visit(old[elem.RedName()]);
				[else]
	    var new[elem.RedName()] = ([elem.RedType()])this.Visit(old[elem.RedName()]);
				[end if]
			[end if]
		return node.Update(new[elem.RedName()]);
	}
		[end loop] 
	return node;   
	[else]
		[loop(elem:rule.AllElements)]
			[if (elem.IsList)]
    var [elem.FieldName()] = this.VisitList(node.[elem.RedName()]);
			[else]
				[if (elem.IsToken || elem.IsFixedTokenAltBlock)]
    var [elem.FieldName()] = this.VisitToken(node.[elem.RedName()]);
				[else]
    var [elem.FieldName()] = ([elem.RedType()])this.Visit(node.[elem.RedName()]);
				[end if]
			[end if]
		[end loop]    
	return node.Update([GetInternalElemParamList(rule, false, false, false, "")]);
	[end if]
}
end template

template GenerateSyntaxFactory()
public class [Properties.LanguageName]SyntaxFactory : SyntaxFactory
{
    internal static readonly [Properties.LanguageName]SyntaxFactory Instance = new [Properties.LanguageName]SyntaxFactory();
^
	public [Properties.LanguageName]SyntaxFactory() 
	{
		this.CarriageReturnLineFeed = ([Properties.LanguageName]SyntaxTrivia)[Properties.LanguageName]GreenFactory.Instance.CarriageReturnLineFeed.CreateRed();
		this.LineFeed = ([Properties.LanguageName]SyntaxTrivia)[Properties.LanguageName]GreenFactory.Instance.LineFeed.CreateRed();
		this.CarriageReturn = ([Properties.LanguageName]SyntaxTrivia)[Properties.LanguageName]GreenFactory.Instance.CarriageReturn.CreateRed();
		this.Space = ([Properties.LanguageName]SyntaxTrivia)[Properties.LanguageName]GreenFactory.Instance.Space.CreateRed();
		this.Tab = ([Properties.LanguageName]SyntaxTrivia)[Properties.LanguageName]GreenFactory.Instance.Tab.CreateRed();
		this.ElasticCarriageReturnLineFeed = ([Properties.LanguageName]SyntaxTrivia)[Properties.LanguageName]GreenFactory.Instance.ElasticCarriageReturnLineFeed.CreateRed();
		this.ElasticLineFeed = ([Properties.LanguageName]SyntaxTrivia)[Properties.LanguageName]GreenFactory.Instance.ElasticLineFeed.CreateRed();
		this.ElasticCarriageReturn = ([Properties.LanguageName]SyntaxTrivia)[Properties.LanguageName]GreenFactory.Instance.ElasticCarriageReturn.CreateRed();
		this.ElasticSpace = ([Properties.LanguageName]SyntaxTrivia)[Properties.LanguageName]GreenFactory.Instance.ElasticSpace.CreateRed();
		this.ElasticTab = ([Properties.LanguageName]SyntaxTrivia)[Properties.LanguageName]GreenFactory.Instance.ElasticTab.CreateRed();
		this.ElasticZeroSpace = ([Properties.LanguageName]SyntaxTrivia)[Properties.LanguageName]GreenFactory.Instance.ElasticZeroSpace.CreateRed();
	}
^
	public new [Properties.LanguageName]Language Language
	{
		get { return [Properties.LanguageName]Language.Instance; }
	}
^
	protected override Language LanguageCore
	{
		get { return this.Language; }
	}
^
    public [Properties.LanguageName]SyntaxTrivia CarriageReturnLineFeed { get; }
    public [Properties.LanguageName]SyntaxTrivia LineFeed { get; }
    public [Properties.LanguageName]SyntaxTrivia CarriageReturn { get; }
    public [Properties.LanguageName]SyntaxTrivia Space { get; }
    public [Properties.LanguageName]SyntaxTrivia Tab { get; }
    public [Properties.LanguageName]SyntaxTrivia ElasticCarriageReturnLineFeed { get; }
    public [Properties.LanguageName]SyntaxTrivia ElasticLineFeed { get; }
    public [Properties.LanguageName]SyntaxTrivia ElasticCarriageReturn { get; }
    public [Properties.LanguageName]SyntaxTrivia ElasticSpace { get; }
    public [Properties.LanguageName]SyntaxTrivia ElasticTab { get; }
    public [Properties.LanguageName]SyntaxTrivia ElasticZeroSpace { get; }
^
	private SyntaxToken defaultToken = null;
    protected override SyntaxToken DefaultToken
    {
        get 
		{
			if (defaultToken != null) return defaultToken;
		    Interlocked.CompareExchange(ref defaultToken, this.Token([Properties.LanguageName]SyntaxKind.None), null);
			return defaultToken;
		}
    }
^
	private SyntaxTrivia defaultTrivia = null;
    protected override SyntaxTrivia DefaultTrivia
    {
        get 
		{
			if (defaultTrivia != null) return defaultTrivia;
		    Interlocked.CompareExchange(ref defaultTrivia, this.Trivia([Properties.LanguageName]SyntaxKind.None, string.Empty), null);
			return defaultTrivia;
		}
    }
^
	private SyntaxToken defaultSeparator = null;
    protected override SyntaxToken DefaultSeparator
    {
        get 
		{
			if (defaultSeparator != null) return defaultSeparator;
		    Interlocked.CompareExchange(ref defaultSeparator, this.Token([Properties.LanguageName]SyntaxKind.TComma), null);
			return defaultSeparator;
		}
    }
^
    protected override SyntaxNode StructuredToken(SyntaxToken token)
    {
        throw new NotImplementedException();
    }
^
    protected override SyntaxNode StructuredTrivia(SyntaxTrivia trivia)
    {
        throw new NotImplementedException();
    }
^
    protected override SyntaxToken Token(SyntaxNode tokenStructure)
    {
        throw new NotImplementedException();
    }
^
    protected override SyntaxTrivia Trivia(SyntaxNode triviaStructure)
    {
        throw new NotImplementedException();
    }
^
	/// <summary>
	/// Creates a token corresponding to a syntax kind. This method can be used for token syntax kinds whose text
	/// can be inferred by the kind alone.
	/// </summary>
	/// <param name="kind">A syntax kind value for a token. These have the suffix Token or Keyword.</param>
	/// <returns></returns>
	public SyntaxToken Token([Properties.LanguageName]SyntaxKind kind)
	{
		return (SyntaxToken)[Properties.LanguageName]Language.Instance.InternalSyntaxFactory.Token(kind).CreateRed();
	}
^
	public SyntaxTrivia Trivia([Properties.LanguageName]SyntaxKind kind, string text)
	{
		return (SyntaxTrivia)[Properties.LanguageName]Language.Instance.InternalSyntaxFactory.Trivia(kind, text).CreateRed();
	}
^
	/// <summary>
	/// Create a new syntax tree from a syntax node.
	/// </summary>
	public [Properties.LanguageName]SyntaxTree SyntaxTree(SyntaxNode root, [Properties.LanguageName]ParseOptions options = null, string path = "", Encoding encoding = null)
	{
	    return [Properties.LanguageName]SyntaxTree.Create(([Properties.LanguageName]SyntaxNode)root, ([Properties.LanguageName]ParseOptions)options, path, encoding);
	}
^
	/// <summary>
	/// Produces a syntax tree by parsing the source text.
	/// </summary>
	public [Properties.LanguageName]SyntaxTree ParseSyntaxTree(
	    string text,
	    [Properties.LanguageName]ParseOptions options = null,
	    string path = "",
	    Encoding encoding = null,
	    CancellationToken cancellationToken = default(CancellationToken))
	{
	    return ([Properties.LanguageName]SyntaxTree)this.ParseSyntaxTreeCore(SourceText.From(text, encoding), options, path, cancellationToken);
	}
^
	/// <summary>
	/// Produces a syntax tree by parsing the source text.
	/// </summary>
	public [Properties.LanguageName]SyntaxTree ParseSyntaxTree(
	    SourceText text,
	    [Properties.LanguageName]ParseOptions options = null,
	    string path = "",
	    CancellationToken cancellationToken = default(CancellationToken))
	{
	    return ([Properties.LanguageName]SyntaxTree)this.ParseSyntaxTreeCore(text, options, path, cancellationToken);
	}
^
	protected override SyntaxTree ParseSyntaxTreeCore(
		SourceText text,
		ParseOptions options = null,
		string path = "",
		CancellationToken cancellationToken = default(CancellationToken))
	{
		return [Properties.LanguageName]SyntaxTree.ParseText(text, ([Properties.LanguageName]ParseOptions)options, path, cancellationToken);
	}
^
    public [Instances.MainRule().RedName()] Parse[Instances.MainRule().PlainName()](string text)
    {
        // note that we do not need a "consumeFullText" parameter, because parsing a compilation unit always must
        // consume input until the end-of-file
        using (var parser = MakeParser(text))
        {
            var node = parser.Parse();
            if (node == null) return null;
            // if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);
            return ([Instances.MainRule().RedName()])node.CreateRed();
        }
    }
^
	public override SyntaxParser MakeParser(SourceText text, ParseOptions options, SyntaxNode oldTree, IReadOnlyList<TextChangeRange> changes)
	{
	    return new [Properties.LanguageName]SyntaxParser(text, ([Properties.LanguageName]ParseOptions)options, oldTree, changes);
	}
^
	public override SyntaxParser MakeParser(string text)
	{
	    return new [Properties.LanguageName]SyntaxParser(SourceText.From(text, Encoding.UTF8), [Properties.LanguageName]ParseOptions.Default, null, null);
	}
[loop(rule:Instances.LexerRules)]
	[if (rule.FixedToken == null)]
^
    public SyntaxToken [rule.PlainName()](string text)
    {
        return (SyntaxToken)[Properties.LanguageName]Language.Instance.InternalSyntaxFactory.[rule.PlainName()](text).CreateRed();
    }
^
    public SyntaxToken [rule.PlainName()](string text, object value)
    {
        return (SyntaxToken)[Properties.LanguageName]Language.Instance.InternalSyntaxFactory.[rule.PlainName()](text, value).CreateRed();
    }
	[end if]
[end loop]
[loop(rule:Instances.ParserRules)]
	[if (rule.Alternatives.Count > 0)]
		[loop(alt:rule.Alternatives)]
	[GenerateSyntaxFactoryCreate(alt)]
		[end loop]
	[else]
	[GenerateSyntaxFactoryCreate(rule)]
	[end if]
[end loop]
^
    internal static IEnumerable<Type> GetNodeTypes()
    {
        return new Type["[]"] {
[loop(rule:Instances.ParserRules)]
	[if (rule.Alternatives.Count > 0)]
		[loop(alt:rule.Alternatives)]
			typeof([alt.RedName()]),
		[end loop]
	[else]
			typeof([rule.RedName()]),
	[end if]
[end loop]
		};
	}
}
end template

template GenerateSyntaxFactoryCreate(Antlr4ParserRule rule)
[if (rule.IsSimpleAlt)]
	[loop(elem:rule.Elements)]
^
public [rule.RedName()] [rule.PlainName()]([elem.RedType()] [elem.FieldName()])
{
		[if (!elem.IsOptional)]
    if ([elem.FieldName()] == null) throw new ArgumentNullException(nameof([elem.FieldName()]));
			[if (elem.IsToken && !elem.IsList)]
    if ([elem.FieldName()].RawKind != (int)[Properties.LanguageName]SyntaxKind.[elem.SyntaxKind()]) throw new ArgumentException(nameof([elem.FieldName()]));
			[end if]
		[else]
			[if (elem.IsToken && !elem.IsList)]
    if ([elem.FieldName()] != null && [elem.FieldName()].RawKind != (int)[Properties.LanguageName]SyntaxKind.[elem.SyntaxKind()]) throw new ArgumentException(nameof([elem.FieldName()]));
			[end if]
		[end if]
    return ([rule.RedName()])[Properties.LanguageName]Language.Instance.InternalSyntaxFactory.[rule.PlainName()]([GetRedToGreenParamElem(elem)]).CreateRed();
}
	[end loop]
[else]
^
public [rule.RedName()] [rule.PlainName()]([GetElemTypedParamList(rule)])
{
	[loop(elem:rule.AllElements)]
		[if (!elem.IsOptional)]
    if ([elem.FieldName()] == null) throw new ArgumentNullException(nameof([elem.FieldName()]));
			[if (elem.IsToken && !elem.IsList)]
    if ([elem.FieldName()].RawKind != (int)[Properties.LanguageName]SyntaxKind.[elem.SyntaxKind()]) throw new ArgumentException(nameof([elem.FieldName()]));
			[end if]
		[else]
			[if (elem.IsToken && !elem.IsList)]
    if ([elem.FieldName()] != null && [elem.FieldName()].RawKind != (int)[Properties.LanguageName]SyntaxKind.[elem.SyntaxKind()]) throw new ArgumentException(nameof([elem.FieldName()]));
			[end if]
		[end if]
	[end loop]
    return ([rule.RedName()])[Properties.LanguageName]Language.Instance.InternalSyntaxFactory.[rule.PlainName()]([GetRedToGreenParamList(rule)]).CreateRed();
}
[if (rule.HasOptionalElements())]
^
public [rule.RedName()] [rule.PlainName()]([GetElemTypedParamList(rule, false, false, true)])
{
	return this.[rule.PlainName()]([GetRedToGreenParamList(rule, false, false, true)]);
}
[end if]
[end if]
end template


template GenerateGreenToken()
public class [Properties.LanguageName]GreenToken : InternalSyntaxToken
{
	public [Properties.LanguageName]GreenToken([Properties.LanguageName]SyntaxKind kind, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
	    : base((int)kind, diagnostics, annotations)
	{
	}
^
    public [Properties.LanguageName]GreenToken([Properties.LanguageName]SyntaxKind kind, int fullWidth, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
        : base((int)kind, fullWidth, diagnostics, annotations)
    {
    }
^
    public [Properties.LanguageName]SyntaxKind Kind
	{
	    get { return ([Properties.LanguageName]SyntaxKind)base.RawKind; }
	}
^
	public virtual [Properties.LanguageName]SyntaxKind ContextualKind
	{
	    get { return this.Kind; }
	}
^
    public override string Text
    {
        get
        {
            return [Properties.LanguageName]Language.Instance.SyntaxFacts.GetText(this.Kind);
        }
    }
^
    public override Language Language
    {
        get { return [Properties.LanguageName]Language.Instance; }
    }
^
    public override SyntaxToken CreateRed(SyntaxNode parent, int position, int index)
    {
        return new [Properties.LanguageName]SyntaxToken(this, parent, position, index);
    }
^
    public override InternalSyntaxToken WithLeadingTrivia(GreenNode trivia)
    {
        return new SyntaxTokenWithTrivia(this.Kind, trivia, null, this.GetDiagnostics(), this.GetAnnotations());
    }
^
    public override InternalSyntaxToken WithTrailingTrivia(GreenNode trivia)
    {
        return new SyntaxTokenWithTrivia(this.Kind, null, trivia, this.GetDiagnostics(), this.GetAnnotations());
    }
^
    public override GreenNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
    {
        return new [Properties.LanguageName]GreenToken(this.Kind, this.GetDiagnostics(), annotations);
    }
^
    public override GreenNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
    {
        return new [Properties.LanguageName]GreenToken(this.Kind, diagnostics, this.GetAnnotations());
    }
^
    internal static [Properties.LanguageName]GreenToken Create([Properties.LanguageName]SyntaxKind kind)
    {
        if (kind < FirstTokenWithWellKnownText || kind > LastTokenWithWellKnownText)
        {
            if (![Properties.LanguageName]Language.Instance.SyntaxFacts.IsToken(kind))
            {
                throw new ArgumentException(string.Format("Invalid token kind '{0}'. This method can only be used to create tokens.", kind), nameof(kind));
            }
^
            return CreateMissing(kind, null, null);
        }
^
        return s_tokensWithNoTrivia["["](int)kind - (int)FirstTokenWithWellKnownText["]"];
    }
^
    internal static [Properties.LanguageName]GreenToken Create([Properties.LanguageName]SyntaxKind kind, GreenNode leading, GreenNode trailing)
    {
        if (kind < FirstTokenWithWellKnownText || kind > LastTokenWithWellKnownText)
        {
            if (![Properties.LanguageName]Language.Instance.SyntaxFacts.IsToken(kind))
            {
                throw new ArgumentException(string.Format("Invalid token kind '{0}'. This method can only be used to create tokens.", kind), nameof(kind));
            }
^
            return CreateMissing(kind, leading, trailing);
        }
^
        if (leading == null)
        {
            if (trailing == null)
            {
                return s_tokensWithNoTrivia["["](int)kind - (int)FirstTokenWithWellKnownText["]"];
            }
            else if (trailing == [Properties.LanguageName]Language.Instance.InternalSyntaxFactory.Space)
            {
                return s_tokensWithSingleTrailingSpace["["](int)kind - (int)FirstTokenWithWellKnownText["]"];
            }
            else if (trailing == [Properties.LanguageName]Language.Instance.InternalSyntaxFactory.CarriageReturnLineFeed)
            {
                return s_tokensWithSingleTrailingCRLF["["](int)kind - (int)FirstTokenWithWellKnownText["]"];
            }
        }
^
        if (leading == [Properties.LanguageName]Language.Instance.InternalSyntaxFactory.ElasticZeroSpace && trailing == [Properties.LanguageName]Language.Instance.InternalSyntaxFactory.ElasticZeroSpace)
        {
            return s_tokensWithElasticTrivia["["](int)kind - (int)FirstTokenWithWellKnownText["]"];
        }
^
        return new SyntaxTokenWithTrivia(kind, leading, trailing, null, null);
    }
^
    internal static [Properties.LanguageName]GreenToken CreateMissing([Properties.LanguageName]SyntaxKind kind, GreenNode leading, GreenNode trailing)
    {
        return new MissingTokenWithTrivia(kind, leading, trailing, null, null);
    }
^
    internal static readonly [Properties.LanguageName]SyntaxKind FirstTokenWithWellKnownText = [Properties.LanguageName]SyntaxKind.[Instances.FirstLiteral().PlainName()];
    internal static readonly [Properties.LanguageName]SyntaxKind LastTokenWithWellKnownText = [Properties.LanguageName]SyntaxKind.[Instances.LastLiteral().PlainName()];
^
    // TODO: eliminate the blank space before the first interesting element?
    private static readonly [Properties.LanguageName]GreenToken["[]"] s_tokensWithNoTrivia = new [Properties.LanguageName]GreenToken["["](int)LastTokenWithWellKnownText - (int)FirstTokenWithWellKnownText + 1["]"];
    private static readonly [Properties.LanguageName]GreenToken["[]"] s_tokensWithElasticTrivia = new [Properties.LanguageName]GreenToken["["](int)LastTokenWithWellKnownText - (int)FirstTokenWithWellKnownText + 1["]"];
    private static readonly [Properties.LanguageName]GreenToken["[]"] s_tokensWithSingleTrailingSpace = new [Properties.LanguageName]GreenToken["["](int)LastTokenWithWellKnownText - (int)FirstTokenWithWellKnownText + 1["]"];
    private static readonly [Properties.LanguageName]GreenToken["[]"] s_tokensWithSingleTrailingCRLF = new [Properties.LanguageName]GreenToken["["](int)LastTokenWithWellKnownText - (int)FirstTokenWithWellKnownText + 1["]"];
^
    static [Properties.LanguageName]GreenToken()
    {
        for (var kind = FirstTokenWithWellKnownText; kind <= LastTokenWithWellKnownText; kind++)
        {
            s_tokensWithNoTrivia["["](int)kind - (int)FirstTokenWithWellKnownText["]"] = new [Properties.LanguageName]GreenToken(kind, null, null);
            s_tokensWithElasticTrivia["["](int)kind - (int)FirstTokenWithWellKnownText["]"] = new SyntaxTokenWithTrivia(kind, [Properties.LanguageName]Language.Instance.InternalSyntaxFactory.ElasticZeroSpace, [Properties.LanguageName]Language.Instance.InternalSyntaxFactory.ElasticZeroSpace, null, null);
            s_tokensWithSingleTrailingSpace["["](int)kind - (int)FirstTokenWithWellKnownText["]"] = new SyntaxTokenWithTrivia(kind, null, [Properties.LanguageName]Language.Instance.InternalSyntaxFactory.Space, null, null);
            s_tokensWithSingleTrailingCRLF["["](int)kind - (int)FirstTokenWithWellKnownText["]"] = new SyntaxTokenWithTrivia(kind, null, [Properties.LanguageName]Language.Instance.InternalSyntaxFactory.CarriageReturnLineFeed, null, null);
        }
    }
^
    internal static IEnumerable<[Properties.LanguageName]GreenToken> GetWellKnownTokens()
    {
        foreach (var element in s_tokensWithNoTrivia)
        {
            if (element.Value != null)
            {
                yield return element;
            }
        }
^
        foreach (var element in s_tokensWithElasticTrivia)
        {
            if (element.Value != null)
            {
                yield return element;
            }
        }
^
        foreach (var element in s_tokensWithSingleTrailingSpace)
        {
            if (element.Value != null)
            {
                yield return element;
            }
        }
^
        foreach (var element in s_tokensWithSingleTrailingCRLF)
        {
            if (element.Value != null)
            {
                yield return element;
            }
        }
    }
^
    internal static [Properties.LanguageName]GreenToken WithText([Properties.LanguageName]SyntaxKind kind, string text)
    {
        return new SyntaxTokenWithText(kind, text, null, null);
    }
^
    internal static [Properties.LanguageName]GreenToken WithText([Properties.LanguageName]SyntaxKind kind, GreenNode leading, string text, GreenNode trailing)
    {
        if (leading == null)
        {
            if (trailing == null)
            {
                return WithText(kind, text);
            }
            else
            {
                return new SyntaxTokenWithTextAndTrailingTrivia(kind, text, trailing, null, null);
            }
        }
^
        return new SyntaxTokenWithTextAndTrivia(kind, text, text, leading, trailing, null, null);
    }
^
    internal static [Properties.LanguageName]GreenToken WithText([Properties.LanguageName]SyntaxKind kind, GreenNode leading, string text, string valueText, GreenNode trailing)
    {
        if (valueText == text)
        {
            return WithText(kind, leading, text, trailing);
        }
^
        return new SyntaxTokenWithTextAndTrivia(kind, text, valueText, leading, trailing, null, null);
    }
^
    internal static [Properties.LanguageName]GreenToken WithValue<T>([Properties.LanguageName]SyntaxKind kind, string text, T value)
    {
        return new SyntaxTokenWithValue<T>(kind, text, value, null, null);
    }
^
    internal static [Properties.LanguageName]GreenToken WithValue<T>([Properties.LanguageName]SyntaxKind kind, GreenNode leading, string text, T value, GreenNode trailing)
    {
        return new SyntaxTokenWithValueAndTrivia<T>(kind, text, value, leading, trailing, null, null);
    }
^
    private class SyntaxTokenWithTrivia : [Properties.LanguageName]GreenToken
    {
        protected readonly GreenNode LeadingField;
        protected readonly GreenNode TrailingField;
^
        internal SyntaxTokenWithTrivia([Properties.LanguageName]SyntaxKind kind, GreenNode leading, GreenNode trailing, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
            : base(kind, diagnostics, annotations)
        {
            if (leading != null)
            {
                this.AdjustFlagsAndWidth(leading);
                this.LeadingField = leading;
            }
            if (trailing != null)
            {
                this.AdjustFlagsAndWidth(trailing);
                this.TrailingField = trailing;
            }
        }
^
        public override GreenNode GetLeadingTrivia()
        {
            return this.LeadingField;
        }
^
        public override GreenNode GetTrailingTrivia()
        {
            return this.TrailingField;
        }
^
        public override InternalSyntaxToken WithLeadingTrivia(GreenNode trivia)
        {
            return new SyntaxTokenWithTrivia(this.Kind, trivia, this.TrailingField, this.GetDiagnostics(), this.GetAnnotations());
        }
^
        public override InternalSyntaxToken WithTrailingTrivia(GreenNode trivia)
        {
            return new SyntaxTokenWithTrivia(this.Kind, this.LeadingField, trivia, this.GetDiagnostics(), this.GetAnnotations());
        }
^
        public override GreenNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
        {
            return new SyntaxTokenWithTrivia(this.Kind, this.LeadingField, this.TrailingField, diagnostics, this.GetAnnotations());
        }
^
        public override GreenNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
        {
            return new SyntaxTokenWithTrivia(this.Kind, this.LeadingField, this.TrailingField, this.GetDiagnostics(), annotations);
        }
    }
^
    private class MissingTokenWithTrivia : SyntaxTokenWithTrivia
    {
        internal MissingTokenWithTrivia([Properties.LanguageName]SyntaxKind kind, GreenNode leading, GreenNode trailing, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
            : base(kind, leading, trailing, diagnostics, annotations)
        {
            this.AddFlags(NodeFlags.IsMissing);
        }
^
        public override string Text
        {
            get { return string.Empty; }
        }
^
        public override object Value
        {
            get { return null; }
        }
^
        public override InternalSyntaxToken WithLeadingTrivia(GreenNode trivia)
        {
            return new MissingTokenWithTrivia(this.Kind, trivia, this.TrailingField, this.GetDiagnostics(), this.GetAnnotations());
        }
^
        public override InternalSyntaxToken WithTrailingTrivia(GreenNode trivia)
        {
            return new MissingTokenWithTrivia(this.Kind, this.LeadingField, trivia, this.GetDiagnostics(), this.GetAnnotations());
        }
^
        public override GreenNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
        {
            return new MissingTokenWithTrivia(this.Kind, this.LeadingField, this.TrailingField, diagnostics, this.GetAnnotations());
        }
^
        public override GreenNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
        {
            return new MissingTokenWithTrivia(this.Kind, this.LeadingField, this.TrailingField, this.GetDiagnostics(), annotations);
        }
    }
^
    private class SyntaxTokenWithText : [Properties.LanguageName]GreenToken
    {
        protected readonly string TextField;
^
        internal SyntaxTokenWithText([Properties.LanguageName]SyntaxKind kind, string text, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
            : base(kind, text.Length, diagnostics, annotations)
        {
            this.TextField = text;
        }
^
        public override string Text
        {
            get { return this.TextField; }
        }
^
        public override object Value
        {
            get { return this.TextField; }
        }
^
        public override string ValueText
        {
            get { return this.TextField; }
        }
^
        public override InternalSyntaxToken WithLeadingTrivia(GreenNode trivia)
        {
            return new SyntaxTokenWithTextAndTrivia(this.Kind, this.TextField, this.TextField, trivia, null, this.GetDiagnostics(), this.GetAnnotations());
        }
^
        public override InternalSyntaxToken WithTrailingTrivia(GreenNode trivia)
        {
            return new SyntaxTokenWithTextAndTrivia(this.Kind, this.TextField, this.TextField, null, trivia, this.GetDiagnostics(), this.GetAnnotations());
        }
^
        public override GreenNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
        {
            return new SyntaxTokenWithText(this.Kind, this.Text, diagnostics, this.GetAnnotations());
        }
^
        public override GreenNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
        {
            return new SyntaxTokenWithText(this.Kind, this.Text, this.GetDiagnostics(), annotations);
        }
    }
^
    private class SyntaxIdentifierExtended : SyntaxTokenWithText
    {
        protected readonly string valueText;
^
        internal SyntaxIdentifierExtended([Properties.LanguageName]SyntaxKind kind, string text, string valueText, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
            : base(kind, text, diagnostics, annotations)
        {
            this.valueText = valueText;
        }
^
        public override string ValueText
        {
            get { return this.valueText; }
        }
^
        public override object Value
        {
            get { return this.valueText; }
        }
^
        public override InternalSyntaxToken WithLeadingTrivia(GreenNode trivia)
        {
            return new SyntaxTokenWithTextAndTrivia(this.Kind, this.TextField, this.valueText, trivia, null, this.GetDiagnostics(), this.GetAnnotations());
        }
^
        public override InternalSyntaxToken WithTrailingTrivia(GreenNode trivia)
        {
            return new SyntaxTokenWithTextAndTrivia(this.Kind, this.TextField, this.valueText, null, trivia, this.GetDiagnostics(), this.GetAnnotations());
        }
^
        public override GreenNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
        {
            return new SyntaxIdentifierExtended(this.Kind, this.TextField, this.valueText, diagnostics, this.GetAnnotations());
        }
^
        public override GreenNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
        {
            return new SyntaxIdentifierExtended(this.Kind, this.TextField, this.valueText, this.GetDiagnostics(), annotations);
        }
    }
^
    private class SyntaxTokenWithTextAndTrailingTrivia : SyntaxTokenWithText
    {
        private readonly GreenNode _trailing;
^
        internal SyntaxTokenWithTextAndTrailingTrivia([Properties.LanguageName]SyntaxKind kind, string text, GreenNode trailing, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
            : base(kind, text, diagnostics, annotations)
        {
            if (trailing != null)
            {
                this.AdjustFlagsAndWidth(trailing);
                _trailing = trailing;
            }
        }
^
        public override GreenNode GetTrailingTrivia()
        {
            return _trailing;
        }
^
        public override InternalSyntaxToken WithLeadingTrivia(GreenNode trivia)
        {
            return new SyntaxTokenWithTextAndTrivia(this.Kind, this.TextField, this.TextField, trivia, _trailing, this.GetDiagnostics(), this.GetAnnotations());
        }
^
        public override InternalSyntaxToken WithTrailingTrivia(GreenNode trivia)
        {
            return new SyntaxTokenWithTextAndTrailingTrivia(this.Kind, this.TextField, trivia, this.GetDiagnostics(), this.GetAnnotations());
        }
^
        public override GreenNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
        {
            return new SyntaxTokenWithTextAndTrailingTrivia(this.Kind, this.TextField, _trailing, diagnostics, this.GetAnnotations());
        }
^
        public override GreenNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
        {
            return new SyntaxTokenWithTextAndTrailingTrivia(this.Kind, this.TextField, _trailing, this.GetDiagnostics(), annotations);
        }
    }
^
    private class SyntaxTokenWithTextAndTrivia : SyntaxIdentifierExtended
    {
        private readonly GreenNode _leading;
        private readonly GreenNode _trailing;
^
        internal SyntaxTokenWithTextAndTrivia(
            [Properties.LanguageName]SyntaxKind kind,
            string text,
            string valueText,
            GreenNode leading,
            GreenNode trailing,
            DiagnosticInfo["[]"] diagnostics,
            SyntaxAnnotation["[]"] annotations)
            : base(kind, text, valueText, diagnostics, annotations)
        {
            if (leading != null)
            {
                this.AdjustFlagsAndWidth(leading);
                _leading = leading;
            }
            if (trailing != null)
            {
                this.AdjustFlagsAndWidth(trailing);
                _trailing = trailing;
            }
        }
^
        public override GreenNode GetLeadingTrivia()
        {
            return _leading;
        }
^
        public override GreenNode GetTrailingTrivia()
        {
            return _trailing;
        }
^
        public override InternalSyntaxToken WithLeadingTrivia(GreenNode trivia)
        {
            return new SyntaxTokenWithTextAndTrivia(this.Kind, this.TextField, this.valueText, trivia, _trailing, this.GetDiagnostics(), this.GetAnnotations());
        }
^
        public override InternalSyntaxToken WithTrailingTrivia(GreenNode trivia)
        {
            return new SyntaxTokenWithTextAndTrivia(this.Kind, this.TextField, this.valueText, _leading, trivia, this.GetDiagnostics(), this.GetAnnotations());
        }
^
        public override GreenNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
        {
            return new SyntaxTokenWithTextAndTrivia(this.Kind, this.TextField, this.valueText, _leading, _trailing, diagnostics, this.GetAnnotations());
        }
^
        public override GreenNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
        {
            return new SyntaxTokenWithTextAndTrivia(this.Kind, this.TextField, this.valueText, _leading, _trailing, this.GetDiagnostics(), annotations);
        }
    }
^
    private class SyntaxTokenWithValue<T> : [Properties.LanguageName]GreenToken
    {
        protected readonly string TextField;
        protected readonly T ValueField;
^
        internal SyntaxTokenWithValue([Properties.LanguageName]SyntaxKind kind, string text, T value, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
            : base(kind, text.Length, diagnostics, annotations)
        {
            this.TextField = text;
            this.ValueField = value;
        }
^
        public override string Text
        {
            get
            {
                return this.TextField;
            }
        }
^
        public override object Value
        {
            get
            {
                return this.ValueField;
            }
        }
^
        public override string ValueText
        {
            get
            {
                return Convert.ToString(this.ValueField, CultureInfo.InvariantCulture);
            }
        }
^
        public override InternalSyntaxToken WithLeadingTrivia(GreenNode trivia)
        {
            return new SyntaxTokenWithValueAndTrivia<T>(this.Kind, this.TextField, this.ValueField, trivia, null, this.GetDiagnostics(), this.GetAnnotations());
        }
^
        public override InternalSyntaxToken WithTrailingTrivia(GreenNode trivia)
        {
            return new SyntaxTokenWithValueAndTrivia<T>(this.Kind, this.TextField, this.ValueField, null, trivia, this.GetDiagnostics(), this.GetAnnotations());
        }
^
        public override GreenNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
        {
            return new SyntaxTokenWithValue<T>(this.Kind, this.TextField, this.ValueField, diagnostics, this.GetAnnotations());
        }
^
        public override GreenNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
        {
            return new SyntaxTokenWithValue<T>(this.Kind, this.TextField, this.ValueField, this.GetDiagnostics(), annotations);
        }
    }
^
    private class SyntaxTokenWithValueAndTrivia<T> : SyntaxTokenWithValue<T>
    {
        private readonly GreenNode _leading;
        private readonly GreenNode _trailing;
^
        internal SyntaxTokenWithValueAndTrivia(
            [Properties.LanguageName]SyntaxKind kind,
            string text,
            T value,
            GreenNode leading,
            GreenNode trailing,
            DiagnosticInfo["[]"] diagnostics,
            SyntaxAnnotation["[]"] annotations)
            : base(kind, text, value, diagnostics, annotations)
        {
            if (leading != null)
            {
                this.AdjustFlagsAndWidth(leading);
                _leading = leading;
            }
            if (trailing != null)
            {
                this.AdjustFlagsAndWidth(trailing);
                _trailing = trailing;
            }
        }
^
        public override GreenNode GetLeadingTrivia()
        {
            return _leading;
        }
^
        public override GreenNode GetTrailingTrivia()
        {
            return _trailing;
        }
^
        public override InternalSyntaxToken WithLeadingTrivia(GreenNode trivia)
        {
            return new SyntaxTokenWithValueAndTrivia<T>(this.Kind, this.TextField, this.ValueField, trivia, _trailing, this.GetDiagnostics(), this.GetAnnotations());
        }
^
        public override InternalSyntaxToken WithTrailingTrivia(GreenNode trivia)
        {
            return new SyntaxTokenWithValueAndTrivia<T>(this.Kind, this.TextField, this.ValueField, _leading, trivia, this.GetDiagnostics(), this.GetAnnotations());
        }
^
        public override GreenNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
        {
            return new SyntaxTokenWithValueAndTrivia<T>(this.Kind, this.TextField, this.ValueField, _leading, _trailing, diagnostics, this.GetAnnotations());
        }
^
        public override GreenNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
        {
            return new SyntaxTokenWithValueAndTrivia<T>(this.Kind, this.TextField, this.ValueField, _leading, _trailing, this.GetDiagnostics(), annotations);
        }
    }
}
end template


template GenerateDeclarationTreeBuilder()
// !!!!!!!
// WARNING: This is an auto-generated file. Any manual changes will be lost when the file is regenerated.
// !!!!!!!
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MetaDslx.Compiler.Syntax;
using MetaDslx.Compiler.Binding;
using MetaDslx.Compiler.Declarations;
using [Properties.DefaultNamespace].Syntax;
^
namespace [Properties.DefaultNamespace].Binding
{
	public class [Properties.LanguageName]DeclarationTreeBuilderVisitor : DeclarationTreeBuilderVisitor, I[Properties.LanguageName]SyntaxVisitor
	{
        protected [Properties.LanguageName]DeclarationTreeBuilderVisitor([Properties.LanguageName]SyntaxTree syntaxTree, string scriptClassName, bool isSubmission)
            : base(syntaxTree, scriptClassName, isSubmission)
        {
        }
^
        public static RootSingleDeclaration ForTree(
            [Properties.LanguageName]SyntaxTree syntaxTree,
            string scriptClassName,
            bool isSubmission)
        {
            var builder = new [Properties.LanguageName]DeclarationTreeBuilderVisitor(syntaxTree, scriptClassName, isSubmission);
            return builder.CreateRoot(syntaxTree.GetRoot(), [Instances.MainRule().Annotations.GetSymbolType(MetaCompilerAnnotationInfo.Root)]);
        }
   		[loop(rule:Instances.ParserRules)]
			[if (rule.Alternatives.Count > 0)]
				[loop(alt:rule.Alternatives)]
		[GenerateDeclarationTreeBuilderVisit(alt)]
				[end loop]
			[else]
		[GenerateDeclarationTreeBuilderVisit(rule)]
			[end if]
		[end loop]
	}
}
end template


template GenerateDeclarationTreeBuilderVisit(Antlr4ParserRule rule)
^
public virtual void Visit[rule.PlainName()]([rule.RedName()] node)
{
	[GetDeclarationTreeBuilderVisitBody(rule)]
}
end template

template GenerateDeclarationTreeBuilderVisitBody(Antlr4ParserRule rule)
[if (rule.ContainsAnnotations && !rule.Annotations.IsDeclarationBoundary())]
[if (rule.IsSimpleAlt)]
	[loop(elem:rule.Elements where elem.ContainsAnnotations && !elem.Annotations.IsDeclarationBoundary())]
[GenerateDeclarationTreeBuilderVisitElement(rule, elem)]
	[end loop] 
[else]
	[loop(elem:rule.AllElements where elem.ContainsAnnotations && !elem.Annotations.IsDeclarationBoundary())]
[GenerateDeclarationTreeBuilderVisitElement(rule, elem)]
	[end loop]    
[end if]
[end if]
end template

template GenerateDeclarationTreeBuilderVisitElementBody(Antlr4ParserRuleElement elem)
	[if (elem.IsList)]
if (node.[elem.RedName()] != null)
{
	foreach (var child in node.[elem.RedName()])
	{
		this.Visit(child);
	}
}
	[else]
		[if (elem.IsToken || elem.IsFixedTokenAltBlock)]
		[else]
this.Visit(node.[elem.RedName()]);
		[end if]
	[end if]
end template

template GenerateDeclarationTreeBuilderDeclaration(MetaCompilerAnnotations annots, string name, string body)
this.BeginDeclaration([annots.GetSymbolType()], [name]);
try
{
	[if (annots.HasProperty("nestingProperty"))]
	this.RegisterNestingProperty([annots.GetNestingProperty()]);
	[end if]
	[if (annots.HasProperty("merge"))]
	this.RegisterCanMerge([annots.GetCanMerge()]);
	[end if]
	[body]
}
finally
{
	this.EndDeclaration();
}
end template

template GenerateDeclarationTreeBuilderQualifier(MetaCompilerAnnotations annots, string name, string body)
this.BeginQualifier();
try
{
	[body]
}
finally
{
	this.EndQualifier();
}
end template

template GenerateDeclarationTreeBuilderName(MetaCompilerAnnotations annots, string name, string body)
this.BeginName();
try
{
	[body]
}
finally
{
	this.EndName();
}
end template

template GenerateDeclarationTreeBuilderProperty(MetaCompilerAnnotations annots, string name, string body)
this.BeginProperty("[annots.GetPropertyWithNoValue().GetValue("name")]");
try
{
	[body]
}
finally
{
	this.EndProperty();
}
end template

template GenerateDeclarationTreeBuilderIdentifier(MetaCompilerAnnotations annots, string name, string body)
if ([name] != null) this.RegisterIdentifier([name]);
[body]
end template

function string GetDeclarationTreeBuilderVisitBody(Antlr4ParserRule rule)
	string body = GenerateDeclarationTreeBuilderVisitBody(rule);
	if (rule.Annotations.IsIdentifier())
		body = GenerateDeclarationTreeBuilderIdentifier(rule.Annotations, "node", body);
	end if
	if (rule.Annotations.IsQualifier())
		body = GenerateDeclarationTreeBuilderQualifier(rule.Annotations, "node", body);
	end if
	if (rule.Annotations.IsName())
		body = GenerateDeclarationTreeBuilderName(rule.Annotations, "node", body);
	end if
	if (rule.Annotations.IsDeclaration())
		body = GenerateDeclarationTreeBuilderDeclaration(rule.Annotations, "node", body);
	end if
	if (rule.Annotations.IsPropertyWithNoValue())
		body = GenerateDeclarationTreeBuilderProperty(rule.Annotations, "node", body);
	end if
	return body;
end function

function string GetDeclarationTreeBuilderVisitElement(Antlr4ParserRule rule, Antlr4ParserRuleElement elem)
	string body = GenerateDeclarationTreeBuilderVisitElementBody(elem);
	if (elem.Annotations.IsIdentifier())
		body = GenerateDeclarationTreeBuilderIdentifier(elem.Annotations, "node."+elem.RedName(), body);
	end if
	if (elem.Annotations.IsQualifier())
		body = GenerateDeclarationTreeBuilderQualifier(elem.Annotations, "node."+elem.RedName(), body);
	end if
	if (elem.Annotations.IsName())
		body = GenerateDeclarationTreeBuilderName(elem.Annotations, "node."+elem.RedName(), body);
	end if
	if (elem.Annotations.IsPropertyWithNoValue())
		body = GenerateDeclarationTreeBuilderProperty(elem.Annotations, "node."+elem.RedName(), body);
	end if
	return body;
end function

template GenerateDeclarationTreeBuilderVisitElement(Antlr4ParserRule rule, Antlr4ParserRuleElement elem)
	[if (elem.IsToken || elem.IsFixedTokenAltBlock)]
if (node.[elem.RedName()] != null)
{
	switch ((([Properties.LanguageName]SyntaxToken)node.[elem.RedName()]).Kind)
	{
		[loop (alt:elem.BlockItems)]
		case [Properties.LanguageName]SyntaxKind.[alt.RedName()]:
			[GetDeclarationTreeBuilderVisitElement(rule, alt)]
			break;
		[end loop]
		default:
			break;
	}
}
	[else]
[GetDeclarationTreeBuilderVisitElement(rule, elem)]
	[end if]
end template

template GenerateBinderFactoryVisitor()
// !!!!!!!
// WARNING: This is an auto-generated file. Any manual changes will be lost when the file is regenerated.
// !!!!!!!
using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MetaDslx.Compiler.Binding;
using MetaDslx.Compiler.Binding.Binders;
using MetaDslx.Compiler.Declarations;
using MetaDslx.Compiler.Syntax;
using MetaDslx.Compiler.Utilities;
using MetaDslx.Core;
using [Properties.DefaultNamespace].Syntax;
using [Properties.DefaultNamespace].Symbols;
^
namespace [Properties.DefaultNamespace].Binding
{
    public class [Properties.LanguageName]BinderFactoryVisitor : BinderFactoryVisitor, I[Properties.LanguageName]SyntaxVisitor<Binder>
    {
		[loop (use:Instances.ParserRuleElemUses)]
		public static object Use[use] = new object();
		[end loop]
^
        public [Properties.LanguageName]BinderFactoryVisitor(BinderFactory symbolBuilder)
			: base(symbolBuilder)
        {
^
        }
		[loop(annot:Instances.CustomAnnotations)]
^
        protected virtual Binder Create[annot.Name]Binder(Binder parentBinder, RedNode node)
        {
            return this.Create[annot.Name]BinderCore(parentBinder, node);
        }
^
        protected virtual Binder Create[annot.Name]BinderCore(Binder parentBinder, RedNode node)
        {
            return new [annot.Name]Binder(parentBinder, node);
        }
		[end loop]
   		[loop(rule:Instances.ParserRules)]
			[if (rule.Alternatives.Count > 0)]
				[loop(alt:rule.Alternatives)]
		[GenerateBinderFactoryVisit(alt)]
				[end loop]
			[else]
		[GenerateBinderFactoryVisit(rule)]
			[end if]
		[end loop]
    }
}
end template


template GenerateBinderFactoryVisit(Antlr4ParserRule rule)
^
public Binder Visit[rule.PlainName()]([rule.RedName()] node)
{
    Debug.Assert(node.SyntaxTree == this.SyntaxTree);
    if (!node.FullSpan.Contains(this.Position))
    {
        return this.GetParentBinder(node);
    }
	object use = null;
	[GenerateBinderFactoryVisitElemUses(rule)]
	Binder resultBinder = null;
	if (!this.BinderFactory.TryGetBinder(node, use, out resultBinder))
	{
		resultBinder = this.GetParentBinder(node);
		[loop (annot:rule.Annotations.Annotations)]
		resultBinder = this.Create[annot.Name]Binder(resultBinder, node[GetAnnotationParams(annot)]);
		[end loop]
		this.BinderFactory.TryAddBinder(node, null, ref resultBinder);
		[GenerateBinderFactoryVisitBody(rule)]
	}
	return resultBinder;
}
end template

function string GetAnnotationParams(MetaCompilerAnnotation annot)
    string result = "";
	if (annot.Name == MetaCompilerAnnotationInfo.SymbolDef || annot.Name == MetaCompilerAnnotationInfo.SymbolCtr)
		if (annot.HasProperty("symbolType"))
			result = ", typeof(Symbols." + annot.GetValue("symbolType") + ")";
		else
			result = ", null";
		end if
	end if
	if (annot.Name == MetaCompilerAnnotationInfo.SymbolUse)
		if (annot.HasProperty("symbolType"))
			result = ", ImmutableArray.Create(typeof(Symbols." + annot.GetValue("symbolType") + "))";
		else
			result = ", ImmutableArray<Type>.Empty";
		end if
	end if
	if (annot.Name == MetaCompilerAnnotationInfo.Property)
	    result = ", \"" + annot.GetValue("name") + "\"";
		if (annot.HasProperty("value"))
		    result = result + ", " + annot.GetValue("value");
		end if
	end if
	if (annot.Name == MetaCompilerAnnotationInfo.Value && annot.HasProperty("value"))
	    result = ", "+annot.GetValue("value");
	end if
	if (annot.Name == MetaCompilerAnnotationInfo.EnumValue)
		if (annot.HasProperty("enumType"))
			result = ", typeof(Symbols." + annot.GetValue("enumType") + ")";
		else
			result = ", null";
		end if
	end if
	return result;
end function


template GenerateBinderFactoryVisitBody(Antlr4ParserRule rule)
[if (rule.ContainsAnnotations && hasloop(elem:rule.Elements where elem.HasAnnotations))]
[if (rule.IsSimpleAlt)]
	[loop(elem:rule.Elements where elem.ContainsAnnotations)]
[GenerateBinderFactoryVisitElement(rule, elem)]
	[end loop] 
[else]
	[loop(elem:rule.AllElements where elem.ContainsAnnotations)]
[GenerateBinderFactoryVisitElement(rule, elem)]
	[end loop]    
[end if]
[end if]
end template

template GenerateBinderFactoryVisitElementBody(Antlr4ParserRule rule, Antlr4ParserRuleElement elem)
	[if (elem.HasAnnotations)]
if (use == Use[elem.RedName()])
{
    [loop (annot:elem.Annotations.Annotations)]
		[if (elem.IsList)]
	resultBinder = this.Create[annot.Name]Binder(resultBinder, node.[elem.RedName()].Node[GetAnnotationParams(annot)]);
		[else]
	resultBinder = this.Create[annot.Name]Binder(resultBinder, node.[elem.RedName()][GetAnnotationParams(annot)]);
		[end if]
	[end loop]
	this.BinderFactory.TryAddBinder(node, use, ref resultBinder);
}
	[end if]
end template

template GenerateBinderFactoryVisitTokenAltBody(Antlr4ParserRule rule, Antlr4ParserRuleElement elem)
	[if (elem.HasAnnotations)]
if (use == Use[elem.RedName()])
{
	switch ((([Properties.LanguageName]SyntaxToken)node.[elem.RedName()]).Kind)
	{
			[loop (alt:elem.BlockItems)]
		case [Properties.LanguageName]SyntaxKind.[alt.RedName()]:
				[loop (annot:alt.Annotations.Annotations)]
			resultBinder = this.Create[annot.Name]Binder(resultBinder, node.[elem.RedName()][GetAnnotationParams(annot)]);
				[end loop]
			break;
			[end loop]
		default:
			break;
	}
	this.BinderFactory.TryAddBinder(node, use, ref resultBinder);
}
	[end if]
end template

template GenerateBinderFactoryVisitElemUses(Antlr4ParserRule rule)
[if (rule.ContainsAnnotations && hasloop(elem:rule.Elements where elem.HasAnnotations))]
if (this.ForChild)
{
[if (rule.IsSimpleAlt)]
	[loop(elem:rule.Elements where elem.HasAnnotations)]
		[if (elem.IsList)]
	if (LookupPosition.IsInNode(this.Position, node.[elem.RedName()].Node)) use = Use[elem.RedName()];
		[else]
	if (LookupPosition.IsInNode(this.Position, node.[elem.RedName()])) use = Use[elem.RedName()];
		[end if]
	[end loop] 
[else]
	[loop(elem:rule.AllElements where elem.HasAnnotations)]
		[if (elem.IsList)]
	if (LookupPosition.IsInNode(this.Position, node.[elem.RedName()].Node)) use = Use[elem.RedName()];
		[else]
	if (LookupPosition.IsInNode(this.Position, node.[elem.RedName()])) use = Use[elem.RedName()];
		[end if]
	[end loop]    
[end if]
}
[end if]
end template

template GenerateBinderFactoryVisitElement(Antlr4ParserRule rule, Antlr4ParserRuleElement elem)
	[if (elem.IsFixedTokenAltBlock)]
[GenerateBinderFactoryVisitTokenAltBody(rule, elem)]
	[else]
[GenerateBinderFactoryVisitElementBody(rule, elem)]
	[end if]
end template
