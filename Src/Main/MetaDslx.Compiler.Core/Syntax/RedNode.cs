using MetaDslx.Compiler.Syntax.InternalSyntax;
using MetaDslx.Compiler.Text;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace MetaDslx.Compiler.Syntax
{
    /// <summary>
    /// Represents a node in the syntax tree.
    /// </summary>
    [DebuggerDisplay("{GetDebuggerDisplay(), nq}")]
    public abstract class RedNode
    {
        private string GetDebuggerDisplay()
        {
            return GetType().Name + " " + RawKind + " " + ToString();
        }

        private readonly GreenNode _green;
        private readonly SyntaxNode _parent;
        private readonly int _position;

        internal RedNode(GreenNode green, SyntaxNode parent, int position)
        {
            Debug.Assert(green != null, "green cannot be null");
            Debug.Assert(position >= 0, "position cannot be negative");
            Debug.Assert(parent?.Green.IsList != true, "list cannot be a parent");

            _position = position;
            _green = green;
            _parent = parent;
        }

        public GreenNode Green { get { return this._green; } }
        internal int Position { get { return this._position; } }

        /// <summary>
        /// An integer representing the language specific kind of this node.
        /// </summary>
        public int RawKind => Green.RawKind;
        public string KindText => Green.KindText;

        /// <summary>
        /// The language that this node is syntax of.
        /// </summary>
        public Language Language => Green.Language;

        internal int EndPosition => Position + Green.FullWidth;

        public bool IsStructuredToken => this.Green.IsStructuredToken;
        public bool IsStructuredTrivia => this.Green.IsStructuredTrivia;
        public bool IsList => this.Green.IsList;
        public bool IsNode => this.Green.IsNode;
        public bool IsToken => this.Green.IsToken;
        public bool IsTrivia => this.Green.IsTrivia;


        /// <summary>
        /// Determines whether this node is a descendant of a structured token.
        /// </summary>
        public bool IsPartOfStructuredToken()
        {
            for (var node = this; node != null; node = node.Parent)
            {
                if (node.IsStructuredToken)
                    return true;
            }

            return false;
        }

        /// <summary>
        /// Determines whether a descendant token of this node is structured.
        /// </summary>
        public bool HasStructuredToken
        {
            get
            {
                return this.Green.ContainsStructuredToken && !this.Green.IsStructuredToken;
            }
        }


        /// <summary>
        /// Determines whether this node is a descendant of a structured trivia.
        /// </summary>
        public bool IsPartOfStructuredTrivia()
        {
            for (var node = this; node != null; node = node.Parent)
            {
                if (node.IsStructuredTrivia)
                    return true;
            }

            return false;
        }

        /// <summary>
        /// Determines whether a descendant trivia of this node is structured.
        /// </summary>
        public bool HasStructuredTrivia
        {
            get
            {
                return this.Green.ContainsStructuredTrivia && !this.Green.IsStructuredTrivia;
            }
        }

        /// <summary>
        /// Returns the child non-terminal node representing the syntax tree structure under this structured element.
        /// </summary>
        /// <returns>The child non-terminal node representing the syntax tree structure under this structured
        /// element.</returns>
        public virtual SyntaxNode GetStructure()
        {
            return null;
        }

        /// <summary>
        /// Determines whether this trivia represents a preprocessor directive.
        /// </summary>
        public bool IsDirective => this.Green.IsDirective;

        /// <summary>
        /// Determines whether the node represents a language construct that was actually parsed
        /// from the source code. Missing nodes are generated by the parser in error scenarios to
        /// represent constructs that should have been present in the source code in order to
        /// compile successfully but were actually missing.
        /// </summary>
        public bool IsMissing => this.Green.IsMissing;

        /// <summary>
        /// The absolute span of this node in characters, including its leading and trailing trivia.
        /// </summary>
        public TextSpan FullSpan => new TextSpan(this.Position, this.Green.FullWidth);

        public int SlotCount => this.Green.SlotCount;

        /// <summary>
        /// The absolute span of this node in characters, not including its leading and trailing trivia.
        /// </summary>
        public TextSpan Span
        {
            get
            {
                // Start with the full span.
                var start = Position;
                var width = this.Green.FullWidth;

                // adjust for preceding trivia (avoid calling this twice, do not call Green.Width)
                var precedingWidth = this.Green.GetLeadingTriviaWidth();
                start += precedingWidth;
                width -= precedingWidth;

                // adjust for following trivia width
                width -= this.Green.GetTrailingTriviaWidth();

                Debug.Assert(width >= 0);
                return new TextSpan(start, width);
            }
        }

        /// <summary>
        /// Same as accessing <see cref="TextSpan.Start"/> on <see cref="Span"/>.
        /// </summary>
        /// <remarks>
        /// Slight performance improvement.
        /// </remarks>
        public int SpanStart => Position + Green.GetLeadingTriviaWidth();

        /// <summary>
        /// The width of the node in characters, not including leading and trailing trivia.
        /// </summary>
        /// <remarks>
        /// The Width property returns the same value as Span.Length, but is somewhat more efficient.
        /// </remarks>
        internal int Width => this.Green.Width;

        /// <summary>
        /// The complete width of the node in characters, including leading and trailing trivia.
        /// </summary>
        /// <remarks>The FullWidth property returns the same value as FullSpan.Length, but is
        /// somewhat more efficient.</remarks>
        internal int FullWidth => this.Green.FullWidth;

        /// <summary>
        /// The node that contains this node in its <see cref="ChildNodes"/> collection.
        /// </summary>
        public SyntaxNode Parent
        {
            get
            {
                return _parent;
            }
        }

        /// <summary>
        /// Determines if the specified node is a descendant of this node.
        /// </summary>
        public bool Contains(RedNode node)
        {
            if (node == null || !this.FullSpan.Contains(node.FullSpan))
            {
                return false;
            }

            while (node != null)
            {
                if (node == this)
                {
                    return true;
                }

                if (node.Parent != null)
                {
                    node = node.Parent;
                }
                else
                {
                    node = null;
                }
            }

            return false;
        }

        public int GetChildIndex(int slot)
        {
            int index = 0;
            for (int i = 0; i < slot; i++)
            {
                var item = this.Green.GetSlot(i);
                if (item != null)
                {
                    if (item.IsList)
                    {
                        index += item.SlotCount;
                    }
                    else
                    {
                        index++;
                    }
                }
            }

            return index;
        }

        /// <summary>
        /// This function calculates the offset of a child at given position. It is very common that
        /// some children to the left of the given index already know their positions so we first
        /// check if that is the case. In a worst case the cost is O(n), but it is not generally an
        /// issue because number of children in regular nodes is fixed and small. In a case where
        /// the number of children could be large (lists) this function is overridden with more
        /// efficient implementations.
        /// </summary>
        public virtual int GetChildPosition(int index)
        {
            int offset = 0;
            var green = this.Green;
            while (index > 0)
            {
                index--;
                var prevSibling = this.GetCachedSlot(index);
                if (prevSibling != null)
                {
                    return prevSibling.EndPosition + offset;
                }
                var greenChild = green.GetSlot(index);
                if (greenChild != null)
                {
                    offset += greenChild.FullWidth;
                }
            }

            return this.Position + offset;
        }


        // this is used in cases where we know that a child is a node of particular type.
        public RedNode GetRed(ref RedNode field, int slot)
        {
            var result = field;

            if (result == null)
            {
                var green = this.Green.GetSlot(slot);
                if (green != null)
                {
                    result = green.CreateRed(this, this.GetChildPosition(slot));
                    result = Interlocked.CompareExchange(ref field, result, null) ?? result;
                }
            }

            return result;
        }

        // special case of above function where slot = 0, does not need GetChildPosition 
        public RedNode GetRedAtZero(ref RedNode field)
        {
            var result = field;

            if (result == null)
            {
                var green = this.Green.GetSlot(0);
                if (green != null)
                {
                    result = green.CreateRed(this, this.Position);
                    result = Interlocked.CompareExchange(ref field, result, null) ?? result;
                }
            }

            return result;
        }

        public T GetRed<T>(ref T field, int slot) where T : RedNode
        {
            var result = field;

            if (result == null)
            {
                var green = this.Green.GetSlot(slot);
                if (green != null)
                {
                    result = (T)green.CreateRed(this, this.GetChildPosition(slot));
                    result = Interlocked.CompareExchange(ref field, result, null) ?? result;
                }
            }

            return result;
        }

        // special case of above function where slot = 0, does not need GetChildPosition 
        public T GetRedAtZero<T>(ref T field) where T : RedNode
        {
            var result = field;

            if (result == null)
            {
                var green = this.Green.GetSlot(0);
                if (green != null)
                {
                    result = (T)green.CreateRed(this, this.Position);
                    result = Interlocked.CompareExchange(ref field, result, null) ?? result;
                }
            }

            return result;
        }


        /// <summary>
        /// This works the same as GetRed, but intended to be used in lists
        /// The only difference is that the public parent of the node is not the list, 
        /// but the list's parent. (element's grand parent).
        /// </summary>
        internal RedNode GetRedElement(ref RedNode element, int slot)
        {
            var result = element;

            if (result == null)
            {
                var green = this.Green.GetSlot(slot);
                result = green.CreateRed(this.Parent, this.GetChildPosition(slot)); // <- passing list's parent
                if (Interlocked.CompareExchange(ref element, result, null) != null)
                {
                    result = element;
                }
            }

            return result;
        }

        internal RedNode GetWeakRedElement(ref WeakReference<RedNode> slot, int index)
        {
            RedNode value = null;
            if (slot?.TryGetTarget(out value) == true)
            {
                return value;
            }

            return CreateWeakItem(ref slot, index);
        }

        // handle a miss
        private RedNode CreateWeakItem(ref WeakReference<RedNode> slot, int index)
        {
            var greenChild = this.Green.GetSlot(index);
            if (greenChild == null) return null;
            var newNode = greenChild.CreateRed(this.Parent, GetChildPosition(index));
            var newWeakReference = new WeakReference<RedNode>(newNode);

            while (true)
            {
                RedNode previousNode = null;
                WeakReference<RedNode> previousWeakReference = slot;
                if (previousWeakReference?.TryGetTarget(out previousNode) == true)
                {
                    return previousNode;
                }

                if (Interlocked.CompareExchange(ref slot, newWeakReference, previousWeakReference) == previousWeakReference)
                {
                    return newNode;
                }
            }
        }

        /// <summary>
        /// Returns SyntaxTree that owns the node or null if node does not belong to a
        /// SyntaxTree
        /// </summary>
        public virtual SyntaxTree SyntaxTree
        {
            get { return this._parent?.SyntaxTree; }
        }

        /// <summary>
        /// Determines whether this node has any descendant skipped text.
        /// </summary>
        public bool ContainsSkippedText => this.Green.ContainsSkippedText;
        
        /// <summary>
        /// Determines whether this node or any sub node, token or trivia has diagnostics.
        /// </summary>
        public bool ContainsDiagnostics => this.Green.ContainsDiagnostics;

        /// <summary>
        /// Determines whether this node or any sub node, token or trivia has annotations.
        /// </summary>
        public bool ContainsAnnotations => this.Green.ContainsAnnotations;
        
        /// <summary>
        /// Determines whether this node has any annotations with the specific annotation kind.
        /// </summary>
        public bool HasAnnotations(string annotationKind)
        {
            return this.Green.HasAnnotations(annotationKind);
        }

        /// <summary>
        /// Determines whether this node has any annotations with any of the specific annotation kinds.
        /// </summary>
        public bool HasAnnotations(IEnumerable<string> annotationKinds)
        {
            return this.Green.HasAnnotations(annotationKinds);
        }

        /// <summary>
        /// Determines whether this node has the specific annotation.
        /// </summary>
        public bool HasAnnotation(SyntaxAnnotation annotation)
        {
            return this.Green.HasAnnotation(annotation);
        }

        /// <summary>
        /// Gets all the annotations with the specified annotation kind. 
        /// </summary>
        public IEnumerable<SyntaxAnnotation> GetAnnotations(string annotationKind)
        {
            return this.Green.GetAnnotations(annotationKind);
        }

        /// <summary>
        /// Gets all the annotations with the specified annotation kinds. 
        /// </summary>
        public IEnumerable<SyntaxAnnotation> GetAnnotations(IEnumerable<string> annotationKinds)
        {
            return this.Green.GetAnnotations(annotationKinds);
        }

        /// <summary>
        /// Get all the annotations of the specified annotation kinds.
        /// </summary>
        public IEnumerable<SyntaxAnnotation> GetAnnotations(params string[] annotationKinds)
        {
            return this.Green.GetAnnotations(annotationKinds);
        }

        public SyntaxAnnotation[] GetAnnotations()
        {
            return this.Green.GetAnnotations();
        }

        /// <summary>
        /// Returns the string representation of this node, not including its leading and trailing trivia.
        /// </summary>
        /// <returns>The string representation of this node, not including its leading and trailing trivia.</returns>
        /// <remarks>The length of the returned string is always the same as Span.Length</remarks>
        public override string ToString()
        {
            return this.Green.ToString();
        }

        /// <summary>
        /// Returns full string representation of this node including its leading and trailing trivia.
        /// </summary>
        /// <returns>The full string representation of this node including its leading and trailing trivia.</returns>
        /// <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
        public virtual string ToFullString()
        {
            return this.Green.ToFullString();
        }

        /// <summary>
        /// Writes the full text of this node to the specified <see cref="TextWriter"/>.
        /// </summary>
        public virtual void WriteTo(TextWriter writer)
        {
            this.Green.WriteTo(writer);
        }

        /// <summary>
        /// Writes the full text of this node to the specified <see cref="TextWriter"/>.
        /// </summary>
        public virtual void WriteTo(TextWriter writer, bool leading, bool trailing)
        {
            this.Green.WriteTo(writer, leading, trailing);
        }

        /// <summary>
        /// Gets the full text of this node as an new <see cref="SourceText"/> instance.
        /// </summary>
        /// <param name="encoding">
        /// Encoding of the file that the text was read from or is going to be saved to.
        /// <c>null</c> if the encoding is unspecified.
        /// If the encoding is not specified the <see cref="SourceText"/> isn't debuggable.
        /// If an encoding-less <see cref="SourceText"/> is written to a file a <see cref="Encoding.UTF8"/> shall be used as a default.
        /// </param>
        /// <param name="checksumAlgorithm">
        /// Hash algorithm to use to calculate checksum of the text that's saved to PDB.
        /// </param>
        /// <exception cref="ArgumentException"><paramref name="checksumAlgorithm"/> is not supported.</exception>
        public SourceText GetText(Encoding encoding = null, SourceHashAlgorithm checksumAlgorithm = SourceHashAlgorithm.Sha1)
        {
            var builder = new StringBuilder();
            this.WriteTo(new StringWriter(builder));
            return new StringBuilderText(builder, encoding, checksumAlgorithm);
        }
        /// <summary>
        /// Gets node at given node index. 
        /// This WILL force node creation if node has not yet been created.
        /// </summary>
        public abstract SyntaxNode GetNodeSlot(int slot);

        /// <summary>
        /// Gets a node at given node index without forcing its creation.
        /// If node was not created it would return null.
        /// </summary>
        public abstract SyntaxNode GetCachedSlot(int index);

    }
}
