namespace MetaDslx.Core;
generator ImmutableMetaModelGenerator for IEnumerable<ModelObject>;

template Generate()
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using MetaDslx.Core;
^
	[loop(Instances->mm:typeof(MetaModel))]
[GenerateMetamodel(mm)]
	[end loop]
end template

template GenerateMetamodel(MetaModel model)
namespace [model.Namespace.CSharpName()]
{
    [GenerateMetaModelDescriptor(model)]
	[loop(model->Namespace->Declarations->enm:typeof(MetaEnum))]
    [GenerateEnum(enm)]
	[end loop]
	[loop(model->Namespace->Declarations->cls:typeof(MetaClass))]
    [GenerateImmutableInterface(cls)]
	[end loop]
	[loop(model->Namespace->Declarations->cls:typeof(MetaClass))]
    [GenerateBuilderInterface(cls)]
	[end loop]
	[loop(model->Namespace->Declarations->cls:typeof(MetaClass))]
    [GenerateImmutableInterfaceImpl(model, cls)]
	[end loop]
	[loop(model->Namespace->Declarations->cls:typeof(MetaClass))]
    [GenerateBuilderInterfaceImpl(model, cls)]
	[end loop]
    [GenerateFactory(model)]
    [GenerateImplementationProvider(model)]
}
end template

template GenerateAnnotations(MetaAnnotatedElement elem)
[loop(elem->annot:Annotations)]
["["][annot.Name]["]"]
[end loop]
end template

template GenerateEnum(MetaEnum enm)
[GenerateAnnotations(enm)]
public enum [enm.CSharpName()]
{
    [loop(enm->value:EnumLiterals)]
    [value.Name],
	[end loop]
}
^
end template

function string GetAncestors(MetaClass cls, ClassKind classKind)
	string result = "";
	loop(cls->super:SuperClasses; string delim = " : "; delim = ", ")
		result += delim+super.CSharpFullName(classKind);
	end loop
	if (result == "") 
		result = "global::MetaDslx.Core.Immutable.RedSymbol";
	end if
	return result;
end function

template GenerateImmutableInterface(MetaClass cls)
[GenerateAnnotations(cls)]
public interface [cls.CSharpName(ClassKind.Immutable)][GetAncestors(cls, ClassKind.Immutable)]
{
    [loop(cls->prop:Properties)]
    [GenerateImmutableProperty(prop)]
	[end loop]
^
    [loop(cls->op:Operations)]
    [GenerateOperation(op)]
	[end loop]
}
^
end template

template GenerateBuilderInterface(MetaClass cls)
public interface [cls.CSharpName(ClassKind.Builder)][GetAncestors(cls, ClassKind.Builder)]
{
    [loop(cls->prop:Properties)]
    [GenerateBuilderProperty(prop)]
	[end loop]
}
^
end template

template GenerateImmutableProperty(MetaProperty prop)
[if (prop.Class.GetAllSuperPropertyNames().Contains(prop.Name))]
new \
[end if]
[prop.Type.CSharpFullPublicName(ClassKind.Immutable)] [prop.Name] { get; }
end template

template GenerateImmutableField(MetaProperty prop)
["[DebuggerBrowsable(DebuggerBrowsableState.Never)]"]
private [prop.Type.CSharpFullPublicName(ClassKind.Immutable)] _[prop.Name];
end template

template GenerateBuilderProperty(MetaProperty prop)
[if (prop.Class.GetAllSuperPropertyNames().Contains(prop.Name))]
new \
[end if]
	[if((prop.Kind == MetaPropertyKind.Normal || prop.Kind == MetaPropertyKind.Containment) && !(prop.Type is MetaCollectionType))]
[prop.Type.CSharpFullPublicName(ClassKind.Builder)] [prop.Name] { get; set; }
	[else]
[prop.Type.CSharpFullPublicName(ClassKind.Builder)] [prop.Name] { get; }
	[end if]
end template

template GenerateBuilderField(MetaProperty prop)
private [prop.Type.CSharpFullPublicName(ClassKind.Builder)] _[prop.Name];
end template

function string GetParameters(MetaOperation op, bool defaultValues)
	string result = "";
	loop(op->param:Parameters; string delim = ""; delim = ", ")
		result += delim+param.Type.CSharpFullPublicName(ClassKind.Immutable)+" "+param.Name;
	end loop
	return result;
end function

function string GetImplParameters(MetaClass cls, MetaOperation op)
	string result = cls.CSharpFullName(ClassKind.Immutable)+" @this";
	string delim = ", ";
	loop(op->param:Parameters)
		result += delim+param.Type.CSharpFullPublicName(ClassKind.Immutable)+" "+param.Name;
	end loop
	return result;
end function

function string GetImplParameters(MetaEnum enm, MetaOperation op)
	string result = enm.CSharpFullName()+" @this";
	string delim = ", ";
	loop(op->param:Parameters)
		result += delim+param.Type.CSharpFullPublicName(ClassKind.Immutable)+" "+param.Name;
	end loop
	return result;
end function

function string GetEnumImplParameters(MetaEnum enm, MetaOperation op)
	string result = "this "+enm.CSharpFullName()+" @this";
	string delim = ", ";
	loop(op->param:Parameters)
		result += delim+param.Type.CSharpFullPublicName(ClassKind.Immutable)+" "+param.Name;
	end loop
	return result;
end function

function string GetEnumImplCallParameterNames(MetaOperation op)
	string result = "@this";
	string delim = ", ";
	loop(op->param:Parameters)
		result += delim+param.Name;
	end loop
	return result;
end function

function string GetImplCallParameterNames(MetaOperation op)
	string result = "this";
	string delim = ", ";
	loop(op->param:Parameters)
		result += delim+param.Name;
	end loop
	return result;
end function

template GenerateOperation(MetaOperation op)
[op.ReturnType.CSharpFullPublicName(ClassKind.Immutable)] [op.Name]([GetParameters(op, true)]);
end template

template GenerateImmutableInterfaceImpl(MetaModel model, MetaClass cls)
internal class [cls.CSharpImplName(ClassKind.Immutable)] : global::MetaDslx.Core.Immutable.ImmutableRedSymbolBase, [cls.CSharpFullName(ClassKind.Immutable)]
{
    [loop(cls->prop:Properties)]
    [GenerateImmutableField(prop)]
	[end loop]
^
    internal [cls.CSharpImplName()](global::MetaDslx.Core.Immutable.SymbolId id, global::MetaDslx.Core.Immutable.ImmutableRedModelPart model)
		: base(id, model)
    {
    }
^
    public override global::MetaDslx.Core.Immutable.MetaModel MMetaModel
    {
        get { return null;/*[cls.Model.CSharpFullInstanceName()];*/ }
    }
^
    public override global::MetaDslx.Core.Immutable.ImmutableRedSymbol MMetaClass
    {
        get { return null; /*[cls.CSharpFullInstanceName()];*/ }
    }
^
    [loop(cls->prop:GetAllProperties())]
    [GenerateImmutablePropertyImpl(model, cls, prop)]
	[end loop]
    [loop(cls->op:GetAllOperations())]
    [GenerateOperationImpl(model, op)]
	[end loop]
}
^
end template

template GenerateBuilderInterfaceImpl(MetaModel model, MetaClass cls)
internal class [cls.CSharpImplName(ClassKind.Builder)] : global::MetaDslx.Core.Immutable.MutableRedSymbolBase, [cls.CSharpFullName(ClassKind.Builder)]
{
    [loop(cls->prop:Properties where prop.Type is MetaCollectionType)]
    [GenerateBuilderField(prop)]
	[end loop]
^
    internal [cls.CSharpImplName(ClassKind.Builder)](global::MetaDslx.Core.Immutable.SymbolId id, global::MetaDslx.Core.Immutable.MutableRedModelPart model)
		: base(id, model)
    {
		[loop(cls->prop:GetAllProperties())]
        this.MAttachProperty([prop.CSharpFullDescriptorName()]);
		[end loop]
        this.MInit();
    }
^
    protected override void MDoInit()
    {
    }
^
    public override global::MetaDslx.Core.MetaModel MMetaModel
    {
        get { return null;/*[cls.Model.CSharpFullInstanceName()];*/ }
    }
^
    public override global::MetaDslx.Core.Immutable.MutableRedSymbol MMetaClass
    {
        get { return null;/*[cls.CSharpFullInstanceName()];*/ }
    }
^
    [loop(cls->prop:GetAllProperties())]
    [GenerateBuilderPropertyImpl(model, cls, prop)]
	[end loop]
}
^
end template

template GeneratePropertyDeclaration(MetaModel model, MetaClass cls, MetaProperty prop)
[if(prop.Class == cls)]
[GenerateAnnotations(prop)]
[if(prop.Kind == MetaPropertyKind.Containment)]
["[ContainmentAttribute]"]
[end if]
[if(prop.Kind != MetaPropertyKind.Normal && prop.Kind != MetaPropertyKind.Containment)]
["[ReadonlyAttribute]"]
[end if]
[loop(p:prop.OppositeProperties)]
["[OppositeAttribute(typeof("][p.Class.CSharpFullDescriptorName()]["), \""][p.Name]["\")]"]
[end if]
[loop(p:prop.SubsettedProperties)]
	[if(cls.GetAllSuperClasses(false).Contains(p.Class))]
["[SubsetsAttribute(typeof("][p.Class.CSharpFullDescriptorName()]["), \""][p.Name]["\")]"]
	[else]
// ERROR: subsetted property '[p.CSharpFullDescriptorName()]' must be a property of an ancestor class
	[end if]
[end if]
[loop(p:prop.RedefinedProperties)]
	[if(cls.GetAllSuperClasses(false).Contains(p.Class))]
["[RedefinesAttribute(typeof("][p.Class.CSharpFullDescriptorName()]["), \""][p.Name]["\")]"]
	[else]
// ERROR: redefined property '[p.CSharpFullDescriptorName()]' must be a property of an ancestor class
	[end if]
[end if]
[if (prop.Type is MetaCollectionType)]
	[MetaCollectionType collType = (MetaCollectionType)prop.Type]
public static readonly global::MetaDslx.Core.Immutable.ModelProperty [prop.Name]Property =
    global::MetaDslx.Core.Immutable.ModelProperty.Register("[prop.Name]", typeof([prop.Class.Model.CSharpFullName()]Descriptor.[prop.Class.CSharpName()])
        new global::MetaDslx.Core.Immutable.ModelPropertyTypeInfo(typeof([collType.InnerType.CSharpFullPublicName(ClassKind.Immutable)]), typeof([prop.Type.CSharpFullPublicName(ClassKind.Immutable)]), typeof([prop.Class.CSharpFullName(ClassKind.Immutable)])),
        new global::MetaDslx.Core.Immutable.ModelPropertyTypeInfo(typeof([collType.InnerType.CSharpFullPublicName(ClassKind.Builder)]), typeof([prop.Type.CSharpFullPublicName(ClassKind.Builder)]), typeof([prop.Class.CSharpFullName(ClassKind.Builder)])),
		() => [prop.Class.Model.CSharpFullName()]Instance.[prop.Class.CSharpName()]_[prop.Name]Property);
[else]
public static readonly global::MetaDslx.Core.Immutable.ModelProperty [prop.Name]Property =
    global::MetaDslx.Core.Immutable.ModelProperty.Register("[prop.Name]", typeof([prop.Class.Model.CSharpFullName()]Descriptor.[prop.Class.CSharpName()])
        new global::MetaDslx.Core.Immutable.ModelPropertyTypeInfo(typeof([prop.Type.CSharpFullPublicName()]), null, typeof([prop.Class.CSharpFullName(ClassKind.Immutable)])),
        new global::MetaDslx.Core.Immutable.ModelPropertyTypeInfo(typeof([prop.Type.CSharpFullPublicName()]), null, typeof([prop.Class.CSharpFullName(ClassKind.Builder)])),
		() => [prop.Class.Model.CSharpFullName()]Instance.[prop.Class.CSharpName()]_[prop.Name]Property);
[end if]
[end if]
^
end template

template GenerateImmutablePropertyImpl(MetaModel model, MetaClass cls, MetaProperty prop)
^
[if (cls.Properties.Contains(prop))]
[prop.Type.CSharpFullPublicName(ClassKind.Immutable)] [prop.Name]
[else]
["[DebuggerBrowsable(DebuggerBrowsableState.Never)]"]
[prop.Type.CSharpFullPublicName(ClassKind.Immutable)] [prop.Class.CSharpFullName(ClassKind.Immutable)].[prop.Name]
[end if]
{
    get { return this.GetValue([prop.CSharpFullDescriptorName()], ref _[prop.Name]); }
}
end template

template GenerateBuilderPropertyImpl(MetaModel model, MetaClass cls, MetaProperty prop)
^
[if (cls.Properties.Contains(prop))]
[prop.Type.CSharpFullPublicName()] [prop.Name]
[else]
["[DebuggerBrowsable(DebuggerBrowsableState.Never)]"]
[prop.Type.CSharpFullPublicName()] [prop.Class.CSharpFullName(ClassKind.Builder)].[prop.Name]
[end if]
{
    [if(prop.Type is MetaCollectionType)]
    get { return this.GetList([prop.CSharpFullDescriptorName()], ref [prop.Name]); }
	[else]
    get { return this.GetValue<[prop.Type.CSharpFullPublicName()]>([prop.CSharpFullDescriptorName()]); }
	[end if]
	[if((prop.Kind == MetaPropertyKind.Normal || prop.Kind == MetaPropertyKind.Containment) && !(prop.Type is MetaCollectionType))]
    set { this.SetValue([prop.CSharpFullDescriptorName()], value); }
	[end if]
}
end template

function string GetReturn(MetaOperation op)
    if (op.ReturnType.CSharpName() == "void") 
		return "";
	else 
		return "return ";
	end if
end function

template GenerateOperationImpl(MetaModel model, MetaOperation op)
^
[op.ReturnType.CSharpFullPublicName(ClassKind.Immutable)] [op.Parent.CSharpFullName(ClassKind.Immutable)].[op.Name]([GetParameters(op, false)])
{
    [GetReturn(op)][model.CSharpFullImplementationName()].[op.Parent.CSharpName()]_[op.Name]([GetImplCallParameterNames(op)]);
}
end template

function string GetSuperClasses(MetaClass cls)
	string result = "";
    loop(cls->sup:SuperClasses; string delim = ""; delim = ", ")
		result += delim+sup.CSharpFullName();
	end loop
	return result;
end function

function string GetAllSuperClasses(MetaClass cls)
	string result = "";
    loop(cls->sup:GetAllSuperClasses(false); string delim = ""; delim = ", ")
		result += delim+sup.CSharpFullName();
	end loop
	return result;
end function

template GenerateMetaModelDescriptor(MetaModel model)
public static class [model.CSharpDescriptorName()]
{
	private static global::System.Collections.Generic.List<global::MetaDslx.Core.Immutable.ModelProperty> properties = new global::System.Collections.Generic.List<global::MetaDslx.Core.Immutable.ModelProperty>();

    static [model.CSharpDescriptorName()]()
    {
    [loop(model->Namespace->Declarations->cls:typeof(MetaClass)->prop:Properties)]
        properties.Add([cls.CSharpName()].[prop.Name]Property);
    [end loop]

        foreach (var property in properties)
        {
            property.Init();
        }
    }

    public static void Init()
    {

    }
^
	public const string Uri = "[model.Uri]";
^
    [loop(model->Namespace->Declarations->cls:typeof(MetaClass))]
    [GenerateMetaModelClass(cls)]
    [end loop]
}
^
end template


template GenerateMetaModelClass(MetaClass cls)
^
public static class [cls.CSharpName()]
{
^
[if (cls.CSharpName() == "MetaClass")]
    public static global::MetaDslx.Core.Immutable.MetaClass _MetaClass
[else]
    public static global::MetaDslx.Core.Immutable.MetaClass MetaClass
[end if]
    {
        get { return null;/*[cls.CSharpFullInstanceName()];*/ }
    }
^
    [loop(cls->prop:Properties)]
    [GeneratePropertyDeclaration(cls.Model, cls, prop)]
    [end loop]
}
end template


function MetaSynthetizedPropertyInitializer GetSynthetizedInitializerFor(MetaClass cls, MetaProperty prop)
	MetaSynthetizedPropertyInitializer lastInit = null;
	loop(cls->sup:GetAllSuperClasses(true)->Constructor->Initializers->init:typeof(MetaSynthetizedPropertyInitializer))
		if (init.Property == prop)
			lastInit = init;
		end if
	end loop
	return lastInit;
end function


template GenerateImplementationProvider(MetaModel model)
internal static class [model.Name]ImplementationProvider
{
    // If there is a compile error at this line, create a new class called [model.Name]Implementation
	// which is a subclass of [model.Name]ImplementationBase:
    private static [model.Name]Implementation implementation = new [model.Name]Implementation();
^
    public static [model.Name]Implementation Implementation
    {
        get { return [model.Name]ImplementationProvider.implementation; }
    }
}
	[loop(model->Namespace->Declarations->enm:typeof(MetaEnum))]
^
public static class [enm.Name]Extensions
{
    [loop(enm->op:Operations)]
    public static [op.ReturnType.CSharpFullPublicName()] [op.Name]([GetEnumImplParameters(enm, op)])
    {
        [GetReturn(op)][model.Name]ImplementationProvider.Implementation.[op.Parent.CSharpName()]_[op.Name]([GetEnumImplCallParameterNames(op)]);
    }
	[end loop]
}
	[end loop]
^
/// <summary>
/// Base class for implementing the behavior of the model elements.
/// This class has to be be overriden in [model.Name]Implementation to provide custom
/// implementation for the constructors, operations and property values.
/// </summary>
internal abstract class [model.Name]ImplementationBase
{
	[loop(model->Namespace->Declarations->cls:typeof(MetaClass))]
    /// <summary>
	/// Implements the constructor: [cls.CSharpName()]()
	[if (hasloop(cls->sup:SuperClasses))]
	/// Direct superclasses: [GetSuperClasses(cls)]
	/// All superclasses: [GetAllSuperClasses(cls)]
	[end if]
	[if (hasloop(cls->prop:GetAllProperties() where prop.Kind == MetaPropertyKind.Readonly))]
    /// Initializes the following readonly properties:
	[end if]
    [loop(cls->prop:GetAllProperties())]
	[if (prop.Kind == MetaPropertyKind.Readonly)]
    ///    [prop.Class.Name].[prop.Name]
	[end if]
	[end loop]
    /// </summary>
    public virtual void [cls.CSharpName()]_[cls.CSharpName()]([cls.CSharpName()] @this)
    {
		[loop(cls->sup:SuperClasses)]
        this.[sup.CSharpName()]_[sup.CSharpName()](@this);
		[end loop]
    }
    [loop(cls->prop:Properties)]
		[MetaSynthetizedPropertyInitializer synInit = GetSynthetizedInitializerFor(cls, prop)]
		[if (synInit == null)]
			[if (prop.Kind == MetaPropertyKind.Derived)]
^
    /// <summary>
    /// Returns the value of the derived property: [cls.CSharpName()].[prop.Name]
    /// </summary>
    public virtual [prop.Type.CSharpFullPublicName()] [cls.CSharpName()]_[prop.Name]([cls.CSharpName()] @this)
    {
        throw new NotImplementedException();
    }
			[else if (prop.Kind == MetaPropertyKind.Lazy)]
^
    /// <summary>
    /// Returns the value of the lazy property: [cls.CSharpName()].[prop.Name]
    /// </summary>
    public virtual [prop.Type.CSharpFullPublicName()] [cls.CSharpName()]_[prop.Name]([cls.CSharpName()] @this)
    {
        throw new NotImplementedException();
    }
			[end if]
		[end if]
	[end loop]
    [loop(cls->op:Operations)]
^
    /// <summary>
    /// Implements the operation: [cls.CSharpName()].[op.Name]()
    /// </summary>
    public virtual [op.ReturnType.CSharpFullPublicName()] [cls.CSharpName()]_[op.Name]([GetImplParameters(cls, op)])
    {
        throw new NotImplementedException();
    }
	[end loop]
^
	[end loop]
	[loop(model->Namespace->Declarations->enm:typeof(MetaEnum))]
    [loop(enm->op:Operations)]
^
    /// <summary>
    /// Implements the operation: [enm.CSharpName()].[op.Name]
    /// </summary>
    public virtual [op.ReturnType.CSharpFullPublicName()] [enm.CSharpName()]_[op.Name]([GetImplParameters(enm, op)])
    {
        throw new NotImplementedException();
    }
	[end loop]
^
	[end loop]
}
^
end template

template GenerateFactory(MetaModel model)
/// <summary>
/// Factory class for creating instances of model elements.
/// </summary>
public class [model.CSharpFactoryName()] : global::MetaDslx.Core.Immutable.ModelFactory
{
    public [model.CSharpFactoryName()]()
        : base()
    {
		[model.CSharpDescriptorName()].Init();
    }
^
    public [model.CSharpFactoryName()](global::MetaDslx.Core.Immutable.MutableRedModel model)
        : base(model)
    {
		[model.CSharpDescriptorName()].Init();
    }
^
    public [model.CSharpFactoryName()](global::MetaDslx.Core.Immutable.MutableRedModel model, global::MetaDslx.Core.Immutable.MutableRedModelPart part)
        : base(model, part)
    {
		[model.CSharpDescriptorName()].Init();
    }
^
    public override MutableRedSymbol Create(string type)
    {
        switch (type)
        {
			[loop(model->Namespace->Declarations->cls:typeof(MetaClass))]
				[if (!cls.IsAbstract)]
            case "[cls.CSharpName()]": return (MutableRedSymbol)this.[cls.CSharpName()]();
				[end if]
			[end loop]
            default:
                throw new ModelException("Unknown type name: " + type);
        }
    }
	[loop(model->Namespace->Declarations->cls:typeof(MetaClass))]
		[if (!cls.IsAbstract)]
^
    /// <summary>
    /// Creates a new instance of [cls.CSharpName()].
    /// </summary>
    public [cls.CSharpName(ClassKind.Builder)] [cls.CSharpName()]()
	{
		return ([cls.CSharpName(ClassKind.Builder)])this.AddSymbol(new [cls.CSharpName(ClassKind.Id)]());
	}
		[end if]
	[end loop]
}
^
end template

