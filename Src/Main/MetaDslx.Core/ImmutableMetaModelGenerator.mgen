namespace MetaDslx.Core;
generator ImmutableMetaModelGenerator for IEnumerable<ModelObject>;

template Generate()
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using MetaDslx.Core;
using System.Diagnostics;
^
	[loop(Instances->mm:typeof(MetaModel))]
[GenerateMetamodel(mm)]
	[end loop]
end template

template GenerateMetamodel(MetaModel model)
namespace [model.Namespace.CSharpName(ClassKind.Immutable)]
{
    [GenerateMetaModelDescriptor(model)]
	[loop(model->Namespace->Declarations->enm:typeof(MetaEnum))]
    [GenerateEnum(enm)]
	[end loop]
	[loop(model->Namespace->Declarations->cls:typeof(MetaClass))]
    [GenerateImmutableInterface(cls)]
	[end loop]
	[loop(model->Namespace->Declarations->cls:typeof(MetaClass))]
    [GenerateBuilderInterface(cls)]
	[end loop]
	[loop(model->Namespace->Declarations->cls:typeof(MetaClass))]
    [GenerateImmutableInterfaceImpl(model, cls)]
	[end loop]
	[loop(model->Namespace->Declarations->cls:typeof(MetaClass))]
    [GenerateBuilderInterfaceImpl(model, cls)]
	[end loop]
	[GenerateMetaModelInstance(model)]
    [GenerateFactory(model)]
    [GenerateImplementationProvider(model)]
}
end template

template GenerateDocumentation(MetaDocumentedElement elem)
[IList<string> lines = elem.GetDocumentationLines()]
[if (lines.Count > 0)]
/**
 * <summary>
	[loop(line:lines)]
 * [line]
	[end loop]
 * </summary>
 */
[end if]
end template

template GenerateAnnotations(MetaAnnotatedElement elem)
[loop(elem->annot:Annotations)]
["["][annot.Name]["]"]
[end loop]
end template

template GenerateEnum(MetaEnum enm)
[GenerateAnnotations(enm)]
public enum [enm.CSharpName()]
{
    [loop(enm->value:EnumLiterals)]
    [value.Name],
	[end loop]
}
^
end template

function string GetAncestors(MetaClass cls, ClassKind classKind)
	string result = "";
	loop(cls->super:SuperClasses; string delim = " : "; delim = ", ")
		result += delim+super.CSharpFullName(classKind);
	end loop
	if (result == "" && classKind != ClassKind.ChildBuilder) 
		result = " : global::MetaDslx.Core.Immutable.ISymbol";
	end if
	return result;
end function

template GenerateImmutableInterface(MetaClass cls)
internal class [cls.CSharpName(ClassKind.Immutable)]Id : SymbolId
{
    public override Type ImmutableType { get { return typeof([cls.CSharpName(ClassKind.Immutable)]); } }
    public override Type MutableType { get { return typeof([cls.CSharpName(ClassKind.Builder)]); } }
^
    public override IImmutableSymbol CreateImmutable(ImmutableModel model)
    {
        return new [cls.CSharpImplName(ClassKind.Immutable)](this, model);
    }
^
    public override IMutableSymbol CreateMutable(MutableModel model, bool created)
    {
        return new [cls.CSharpImplName(ClassKind.Builder)](this, model, created);
    }
}
^
[GenerateAnnotations(cls)]
public interface [cls.CSharpName(ClassKind.Immutable)][GetAncestors(cls, ClassKind.Immutable)]
{
    [loop(cls->prop:Properties)]
    [GenerateImmutableProperty(prop)]
	[end loop]
^
    [loop(cls->op:Operations)]
    [GenerateOperation(op)]
	[end loop]
}
^
end template

template GenerateBuilderInterface(MetaClass cls)
public interface [cls.CSharpName(ClassKind.Builder)][GetAncestors(cls, ClassKind.Builder)]
{
    [loop(cls->prop:Properties)]
    [GenerateBuilderProperty(prop)]
	[end loop]
}
^
public interface [cls.CSharpName(ClassKind.ChildBuilder)][GetAncestors(cls, ClassKind.ChildBuilder)]
{
    [loop(cls->prop:Properties)]
    [GenerateChildBuilderProperty(prop)]
	[end loop]
}
^
end template

template GenerateImmutableProperty(MetaProperty prop)
[if (prop.Class.GetAllSuperPropertyNames().Contains(prop.Name))]
new \
[end if]
[prop.Type.CSharpFullPublicName(ClassKind.Immutable)] [prop.Name] { get; }
end template

template GenerateImmutableField(MetaClass cls, MetaProperty prop)
["[DebuggerBrowsable(DebuggerBrowsableState.Never)]"]
private [prop.Type.CSharpFullPublicName(ClassKind.Immutable)] [prop.GetFieldName(cls)];
end template

template GenerateBuilderProperty(MetaProperty prop)
[if (prop.Class.GetAllSuperPropertyNames().Contains(prop.Name))]
new \
[end if]
	[if((prop.Kind == MetaPropertyKind.Normal || prop.Kind == MetaPropertyKind.Containment) && !(prop.Type is MetaCollectionType))]
[prop.Type.CSharpFullPublicName(ClassKind.Builder)] [prop.Name] { get; set; }
	[else]
[prop.Type.CSharpFullPublicName(ClassKind.Builder)] [prop.Name] { get; }
	[end if]
[if(!(prop.Type is MetaCollectionType))]
	[if (prop.Class.GetAllSuperPropertyNames().Contains(prop.Name))]
new \
	[end if]
Func<[prop.Type.CSharpFullPublicName(ClassKind.Builder)]> [prop.Name]Lazy { get; set; }
[end if]
[if(prop.Kind == MetaPropertyKind.Containment && (((prop.Type is MetaCollectionType) && (((MetaCollectionType)prop.Type).InnerType is MetaClass)) || (!(prop.Type is MetaCollectionType) && prop.Type is MetaClass)))]
	[if (prop.Class.GetAllSuperPropertyNames().Contains(prop.Name))]
new \
	[end if]
	[if (prop.Type is MetaCollectionType)]
[((MetaCollectionType)prop.Type).InnerType.CSharpFullPublicName(ClassKind.ChildBuilder)] [prop.Name]LazyChild { get; }
	[else]
[prop.Type.CSharpFullPublicName(ClassKind.ChildBuilder)] [prop.Name]LazyChild { get; }
	[end if]
[end if]
end template

template GenerateChildBuilderProperty(MetaProperty prop)
[if(!(prop.Type is MetaCollectionType))]
	[if (prop.Class.GetAllSuperPropertyNames().Contains(prop.Name))]
new \
	[end if]
Func<[prop.Type.CSharpFullPublicName(ClassKind.Builder)]> [prop.Name] { set; }
[end if]
end template

template GenerateBuilderField(MetaClass cls, MetaProperty prop)
private [prop.Type.CSharpFullPublicName(ClassKind.Builder)] [prop.GetFieldName(cls)];
end template

function string GetParameters(MetaFunction op, ClassKind classKind)
	string result = "";
	loop(op->param:Parameters; string delim = ""; delim = ", ")
		result += delim+param.Type.CSharpFullPublicName(classKind)+" "+param.Name;
	end loop
	return result;
end function

function string GetImplParameters(MetaClass cls, MetaOperation op)
	string result = cls.CSharpFullName(ClassKind.Immutable)+" @this";
	string delim = ", ";
	loop(op->param:Parameters)
		result += delim+param.Type.CSharpFullPublicName(ClassKind.Immutable)+" "+param.Name;
	end loop
	return result;
end function

function string GetImplParameters(MetaEnum enm, MetaOperation op)
	string result = enm.CSharpFullName(ClassKind.Immutable)+" @this";
	string delim = ", ";
	loop(op->param:Parameters)
		result += delim+param.Type.CSharpFullPublicName(ClassKind.Immutable)+" "+param.Name;
	end loop
	return result;
end function

function string GetEnumImplParameters(MetaEnum enm, MetaOperation op)
	string result = "this "+enm.CSharpFullName(ClassKind.Immutable)+" @this";
	string delim = ", ";
	loop(op->param:Parameters)
		result += delim+param.Type.CSharpFullPublicName(ClassKind.Immutable)+" "+param.Name;
	end loop
	return result;
end function

function string GetEnumImplCallParameterNames(MetaOperation op)
	string result = "@this";
	string delim = ", ";
	loop(op->param:Parameters)
		result += delim+param.Name;
	end loop
	return result;
end function

function string GetImplCallParameterNames(MetaOperation op)
	string result = "this";
	string delim = ", ";
	loop(op->param:Parameters)
		result += delim+param.Name;
	end loop
	return result;
end function

template GenerateOperation(MetaOperation op)
[op.ReturnType.CSharpFullPublicName(ClassKind.Immutable)] [op.Name]([GetParameters(op, ClassKind.Immutable)]);
end template

template GenerateImmutableInterfaceImpl(MetaModel model, MetaClass cls)
internal class [cls.CSharpImplName(ClassKind.Immutable)] : global::MetaDslx.Core.Immutable.ImmutableSymbolBase, [cls.CSharpFullName(ClassKind.Immutable)]
{
    [loop(cls->prop:GetAllProperties())]
    [GenerateImmutableField(cls, prop)]
	[end loop]
^
    internal [cls.CSharpImplName()](global::MetaDslx.Core.Immutable.SymbolId id, global::MetaDslx.Core.Immutable.ImmutableModel model)
		: base(id, model)
    {
    }
^
    public override object MMetaModel
    {
        get { return null;/*[cls.Model.CSharpFullInstanceName()];*/ }
    }
^
    public override object MMetaClass
    {
        get { return null; /*[cls.CSharpFullInstanceName()];*/ }
    }
^
    [loop(cls->prop:GetAllProperties())]
    [GenerateImmutablePropertyImpl(model, cls, prop)]
	[end loop]
    [loop(cls->op:GetAllOperations())]
    [GenerateOperationImpl(model, op)]
	[end loop]
}
^
end template

template GenerateBuilderInterfaceImpl(MetaModel model, MetaClass cls)
internal class [cls.CSharpImplName(ClassKind.Builder)] : global::MetaDslx.Core.Immutable.MutableSymbolBase, [cls.CSharpFullName(ClassKind.Builder)]
{
    [loop(cls->prop:GetAllProperties() where prop.Type is MetaCollectionType)]
    [GenerateBuilderField(cls, prop)]
	[end loop]
^
    internal [cls.CSharpImplName(ClassKind.Builder)](global::MetaDslx.Core.Immutable.SymbolId id, global::MetaDslx.Core.Immutable.MutableModel model, bool created)
		: base(id, model, created)
    {
		if (!created)
		{
			[loop(cls->prop:GetAllProperties())]
			this.MAttachProperty([prop.CSharpFullDescriptorName(ClassKind.Immutable)]);
			[end loop]
			this.MInit();
		}
    }
^
    protected override void MDoInit()
    {
		[model.Name]ImplementationProvider.Implementation.[cls.CSharpName()](this);
    }
^
    public override object MMetaModel
    {
        get { return null;/*[cls.Model.CSharpFullInstanceName()];*/ }
    }
^
    public override object MMetaClass
    {
        get { return null;/*[cls.CSharpFullInstanceName()];*/ }
    }
^
    [loop(cls->prop:GetAllProperties())]
    [GenerateBuilderPropertyImpl(model, cls, prop)]
	[end loop]
}
^
public class [cls.CSharpImplName(ClassKind.ChildBuilder)] : global::MetaDslx.Core.Immutable.LazyChildBuilderBase, [cls.CSharpFullName(ClassKind.ChildBuilder)]
{
    internal [cls.CSharpImplName(ClassKind.ChildBuilder)](global::MetaDslx.Core.Immutable.MutableSymbolBase parent, global::MetaDslx.Core.Immutable.ModelProperty property)
		: base(parent, property)
    {
    }
^
    [loop(cls->prop:GetAllProperties())]
    [GenerateChildBuilderPropertyImpl(model, cls, prop)]
	[end loop]
}
^
end template

template GeneratePropertyDeclaration(MetaModel model, MetaClass cls, MetaProperty prop)
[if(prop.Class == cls)]
[GenerateAnnotations(prop)]
[if(prop.Kind == MetaPropertyKind.Containment)]
["[ContainmentAttribute]"]
[end if]
[if(prop.Kind != MetaPropertyKind.Normal && prop.Kind != MetaPropertyKind.Containment)]
["[ReadonlyAttribute]"]
[end if]
[loop(p:prop.OppositeProperties)]
["[OppositeAttribute(typeof("][p.Class.CSharpFullDescriptorName()]["), \""][p.Name]["\")]"]
[end if]
[loop(p:prop.SubsettedProperties)]
	[if(cls.GetAllSuperClasses(true).Contains(p.Class))]
["[SubsetsAttribute(typeof("][p.Class.CSharpFullDescriptorName()]["), \""][p.Name]["\")]"]
	[else]
// ERROR: subsetted property '[p.CSharpFullDescriptorName()]' must be a property of an ancestor class
	[end if]
[end if]
[loop(p:prop.RedefinedProperties)]
	[if(cls.GetAllSuperClasses(true).Contains(p.Class))]
["[RedefinesAttribute(typeof("][p.Class.CSharpFullDescriptorName()]["), \""][p.Name]["\")]"]
	[else]
// ERROR: redefined property '[p.CSharpFullDescriptorName()]' must be a property of an ancestor class
	[end if]
[end if]
[if (prop.Type is MetaCollectionType)]
	[MetaCollectionType collType = (MetaCollectionType)prop.Type]
public static readonly global::MetaDslx.Core.Immutable.ModelProperty [prop.Name]Property =
    global::MetaDslx.Core.Immutable.ModelProperty.Register("[prop.Name]", typeof([prop.Class.Model.CSharpDescriptorName()].[prop.Class.CSharpName()]),
        new global::MetaDslx.Core.Immutable.ModelPropertyTypeInfo(typeof([collType.InnerType.CSharpFullPublicName(ClassKind.Immutable)]), typeof([prop.Type.CSharpFullPublicName(ClassKind.Immutable)]), typeof([prop.Class.CSharpFullName(ClassKind.Immutable)])),
        new global::MetaDslx.Core.Immutable.ModelPropertyTypeInfo(typeof([collType.InnerType.CSharpFullPublicName(ClassKind.Builder)]), typeof([prop.Type.CSharpFullPublicName(ClassKind.Builder)]), typeof([prop.Class.CSharpFullName(ClassKind.Builder)])));
[else]
public static readonly global::MetaDslx.Core.Immutable.ModelProperty [prop.Name]Property =
    global::MetaDslx.Core.Immutable.ModelProperty.Register("[prop.Name]", typeof([prop.Class.Model.CSharpDescriptorName()].[prop.Class.CSharpName()]),
        new global::MetaDslx.Core.Immutable.ModelPropertyTypeInfo(typeof([prop.Type.CSharpFullPublicName(ClassKind.Immutable)]), null, typeof([prop.Class.CSharpFullName(ClassKind.Immutable)])),
        new global::MetaDslx.Core.Immutable.ModelPropertyTypeInfo(typeof([prop.Type.CSharpFullPublicName(ClassKind.Builder)]), null, typeof([prop.Class.CSharpFullName(ClassKind.Builder)])));
[end if]
[end if]
^
end template

template GenerateImmutablePropertyImpl(MetaModel model, MetaClass cls, MetaProperty prop)
^
[if (cls.GetAllFinalProperties().Contains(prop))]
public [prop.Type.CSharpFullPublicName(ClassKind.Immutable)] [prop.Name]
[else]
["[DebuggerBrowsable(DebuggerBrowsableState.Never)]"]
[prop.Type.CSharpFullPublicName(ClassKind.Immutable)] [prop.Class.CSharpFullName(ClassKind.Immutable)].[prop.Name]
[end if]
{
    [if(prop.Type is MetaCollectionType)]
    get { return this.GetList<[((MetaCollectionType)prop.Type).InnerType.CSharpFullPublicName(ClassKind.Immutable)]>([prop.CSharpFullDescriptorName(ClassKind.Immutable)], ref [prop.GetFieldName(cls)]); }
	[else if (prop.Type.IsReferenceType())]
    get { return this.GetReference<[prop.Type.CSharpFullPublicName(ClassKind.Immutable)]>([prop.CSharpFullDescriptorName(ClassKind.Immutable)], ref [prop.GetFieldName(cls)]); }
	[else]
    get { return this.GetValue<[prop.Type.CSharpFullPublicName(ClassKind.Immutable)]>([prop.CSharpFullDescriptorName(ClassKind.Immutable)], ref [prop.GetFieldName(cls)]); }
	[end if]
}
end template

template GenerateBuilderPropertyImpl(MetaModel model, MetaClass cls, MetaProperty prop)
^
[if (cls.GetAllFinalProperties().Contains(prop))]
public [prop.Type.CSharpFullPublicName(ClassKind.Builder)] [prop.Name]
[else]
["[DebuggerBrowsable(DebuggerBrowsableState.Never)]"]
[prop.Type.CSharpFullPublicName(ClassKind.Builder)] [prop.Class.CSharpFullName(ClassKind.Builder)].[prop.Name]
[end if]
{
    [if(prop.Type is MetaCollectionType)]
    get { return this.GetList<[((MetaCollectionType)prop.Type).InnerType.CSharpFullPublicName(ClassKind.Builder)]>([prop.CSharpFullDescriptorName(ClassKind.Builder)], ref [prop.GetFieldName(cls)]); }
	[else if (prop.Type.IsReferenceType())]
    get { return this.GetReference<[prop.Type.CSharpFullPublicName(ClassKind.Builder)]>([prop.CSharpFullDescriptorName(ClassKind.Builder)]); }
	[else]
    get { return this.GetValue<[prop.Type.CSharpFullPublicName(ClassKind.Builder)]>([prop.CSharpFullDescriptorName(ClassKind.Builder)]); }
	[end if]
	[if((prop.Kind == MetaPropertyKind.Normal || prop.Kind == MetaPropertyKind.Containment) && !(prop.Type is MetaCollectionType))]
		[if (prop.Type.IsReferenceType())]
    set { this.SetReference<[prop.Type.CSharpFullPublicName(ClassKind.Builder)]>([prop.CSharpFullDescriptorName(ClassKind.Builder)], value); }
		[else]
    set { this.SetValue<[prop.Type.CSharpFullPublicName(ClassKind.Builder)]>([prop.CSharpFullDescriptorName(ClassKind.Builder)], value); }
		[end if]
	[end if]
}
[if(!(prop.Type is MetaCollectionType))]
^
	[if (cls.GetAllFinalProperties().Contains(prop))]
public Func<[prop.Type.CSharpFullPublicName(ClassKind.Builder)]> [prop.Name]Lazy
	[else]
["[DebuggerBrowsable(DebuggerBrowsableState.Never)]"]
Func<[prop.Type.CSharpFullPublicName(ClassKind.Builder)]> [prop.Class.CSharpFullName(ClassKind.Builder)].[prop.Name]Lazy
	[end if]
{
		[if (prop.Type.IsReferenceType())]
    get { return this.GetLazyReference<[prop.Type.CSharpFullPublicName(ClassKind.Builder)]>([prop.CSharpFullDescriptorName(ClassKind.Builder)]); }
    set { this.SetLazyReference([prop.CSharpFullDescriptorName(ClassKind.Builder)], value); }
		[else]
    get { return this.GetLazyValue<[prop.Type.CSharpFullPublicName(ClassKind.Builder)]>([prop.CSharpFullDescriptorName(ClassKind.Builder)]); }
    set { this.SetLazyValue([prop.CSharpFullDescriptorName(ClassKind.Builder)], value); }
		[end if]
}
[end if]
[if(prop.Kind == MetaPropertyKind.Containment && (((prop.Type is MetaCollectionType) && (((MetaCollectionType)prop.Type).InnerType is MetaClass)) || (!(prop.Type is MetaCollectionType) && prop.Type is MetaClass)))]
^
["[DebuggerBrowsable(DebuggerBrowsableState.Never)]"]
	[if (cls.GetAllFinalProperties().Contains(prop))]
		[if (prop.Type is MetaCollectionType)]
public [((MetaCollectionType)prop.Type).InnerType.CSharpFullPublicName(ClassKind.ChildBuilder)] [prop.Name]LazyChild
		[else]
public [prop.Type.CSharpFullPublicName(ClassKind.ChildBuilder)] [prop.Name]LazyChild
		[end if]
	[else]
		[if (prop.Type is MetaCollectionType)]
[((MetaCollectionType)prop.Type).InnerType.CSharpFullPublicName(ClassKind.ChildBuilder)] [prop.Class.CSharpFullName(ClassKind.Builder)].[prop.Name]LazyChild
		[else]
[prop.Type.CSharpFullPublicName(ClassKind.ChildBuilder)] [prop.Class.CSharpFullName(ClassKind.Builder)].[prop.Name]LazyChild
		[end if]
	[end if]
		[if (prop.Type is MetaCollectionType)]
{
    get { return new [((MetaClass)((MetaCollectionType)prop.Type).InnerType).CSharpFullName(ClassKind.ChildBuilder)]Impl(this, [prop.CSharpFullDescriptorName(ClassKind.Builder)]); }
}
		[else]
{
    get { return new [((MetaClass)prop.Type).CSharpFullName(ClassKind.ChildBuilder)]Impl(this, [prop.CSharpFullDescriptorName(ClassKind.Builder)]); }
}
		[end if]
[end if]
end template

template GenerateChildBuilderPropertyImpl(MetaModel model, MetaClass cls, MetaProperty prop)
[if(!(prop.Type is MetaCollectionType))]
^
["[DebuggerBrowsable(DebuggerBrowsableState.Never)]"]
	[if (cls.GetAllFinalProperties().Contains(prop))]
public Func<[prop.Type.CSharpFullPublicName(ClassKind.Builder)]> [prop.Name]
	[else]
Func<[prop.Type.CSharpFullPublicName(ClassKind.Builder)]> [prop.Class.CSharpFullName(ClassKind.ChildBuilder)].[prop.Name]
	[end if]
{
		[if (prop.Type.IsReferenceType())]
    set { this.MParent.MChildAddLazy(this.MProperty, [prop.CSharpFullDescriptorName(ClassKind.Builder)], value); }
		[else]
    set { this.MParent.MChildAddLazy(this.MProperty, [prop.CSharpFullDescriptorName(ClassKind.Builder)], () => value); }
		[end if]
}
[end if]
end template

function string GetReturn(MetaOperation op)
    if (op.ReturnType.CSharpName() == "void") 
		return "";
	else 
		return "return ";
	end if
end function

template GenerateOperationImpl(MetaModel model, MetaOperation op)
^
[op.ReturnType.CSharpFullPublicName(ClassKind.Immutable)] [op.Parent.CSharpFullName(ClassKind.Immutable)].[op.Name]([GetParameters(op, ClassKind.Immutable)])
{
    [GetReturn(op)][model.CSharpFullImplementationName(ClassKind.Immutable)].[op.Parent.CSharpName()]_[op.Name]([GetImplCallParameterNames(op)]);
}
end template

function string GetSuperClasses(MetaClass cls)
	string result = "";
    loop(cls->sup:SuperClasses; string delim = ""; delim = ", ")
		result += delim+sup.CSharpFullName();
	end loop
	return result;
end function

function string GetAllSuperClasses(MetaClass cls)
	string result = "";
    loop(cls->sup:GetAllSuperClasses(false); string delim = ""; delim = ", ")
		result += delim+sup.CSharpFullName();
	end loop
	return result;
end function

template GenerateMetaModelDescriptor(MetaModel model)
public static class [model.CSharpDescriptorName()]
{
	private static global::System.Collections.Generic.List<global::MetaDslx.Core.Immutable.ModelProperty> properties = new global::System.Collections.Generic.List<global::MetaDslx.Core.Immutable.ModelProperty>();
^
    static [model.CSharpDescriptorName()]()
    {
    [loop(model->Namespace->Declarations->cls:typeof(MetaClass)->prop:Properties)]
        properties.Add([cls.CSharpName()].[prop.Name]Property);
    [end loop]
^
        foreach (var property in properties)
        {
            property.Init();
        }
    }
^
    public static void Init()
    {

    }
^
	public const string Uri = "[model.Uri]";
^
    [loop(model->Namespace->Declarations->cls:typeof(MetaClass))]
    [GenerateMetaModelClass(cls)]
    [end loop]
}
^
end template


template GenerateMetaModelClass(MetaClass cls)
^
public static class [cls.CSharpName()]
{
^
[if (cls.CSharpName() == "MetaClass")]
    public static global::MetaDslx.Core.Immutable.MetaClass _MetaClass
[else]
    public static global::MetaDslx.Core.Immutable.MetaClass MetaClass
[end if]
    {
        get { return null;/*[cls.CSharpFullInstanceName()];*/ }
    }
^
    [loop(cls->prop:Properties)]
    [GeneratePropertyDeclaration(cls.Model, cls, prop)]
    [end loop]
}
end template


function MetaSynthetizedPropertyInitializer GetSynthetizedInitializerFor(MetaClass cls, MetaProperty prop)
	MetaSynthetizedPropertyInitializer lastInit = null;
	loop(cls->sup:GetAllSuperClasses(true)->Constructor->Initializers->init:typeof(MetaSynthetizedPropertyInitializer))
		if (init.Property == prop)
			lastInit = init;
		end if
	end loop
	return lastInit;
end function


template GenerateImplementationProvider(MetaModel model)
internal static class [model.Name]ImplementationProvider
{
    // If there is a compile error at this line, create a new class called [model.Name]Implementation
	// which is a subclass of [model.Name]ImplementationBase:
    private static [model.Name]Implementation implementation = new [model.Name]Implementation();
^
    public static [model.Name]Implementation Implementation
    {
        get { return [model.Name]ImplementationProvider.implementation; }
    }
}
	[loop(model->Namespace->Declarations->enm:typeof(MetaEnum))]
^
public static class [enm.Name]Extensions
{
    [loop(enm->op:Operations)]
    public static [op.ReturnType.CSharpFullPublicName(ClassKind.Immutable)] [op.Name]([GetEnumImplParameters(enm, op)])
    {
        [GetReturn(op)][model.Name]ImplementationProvider.Implementation.[op.Parent.CSharpName()]_[op.Name]([GetEnumImplCallParameterNames(op)]);
    }
	[end loop]
}
	[end loop]
^
/// <summary>
/// Base class for implementing the behavior of the model elements.
/// This class has to be be overriden in [model.Name]Implementation to provide custom
/// implementation for the constructors, operations and property values.
/// </summary>
internal abstract class [model.Name]ImplementationBase
{
	[loop(model->Namespace->Declarations->cls:typeof(MetaClass))]
    /// <summary>
	/// Implements the constructor: [cls.CSharpName()]()
    /// </summary>
	[if (hasloop(cls->sup:SuperClasses))]
	/// Direct superclasses: [GetSuperClasses(cls)]
	/// All superclasses: [GetAllSuperClasses(cls)]
	[end if]
	[if (hasloop(cls->prop:Properties where prop.Kind == MetaPropertyKind.Readonly))]
    /// Initializes the following readonly properties:
	/// <ul>
    [loop(cls->prop:Properties where prop.Kind == MetaPropertyKind.Readonly)]
    ///     <li>[prop.Name]</li>
	[end loop]
	/// </ul>
	[end if]
	[if (hasloop(cls->prop:Properties where prop.Kind == MetaPropertyKind.Lazy))]
    /// Initializes the following lazy properties:
	/// <ul>
    [loop(cls->prop:Properties where prop.Kind == MetaPropertyKind.Lazy)]
    ///     <li>[prop.Name]</li>
	[end loop]
	/// </ul>
	[end if]
	[if (hasloop(cls->prop:Properties where prop.Kind == MetaPropertyKind.Derived))]
    /// Initializes the following derived properties:
	/// <ul>
    [loop(cls->prop:Properties where prop.Kind == MetaPropertyKind.Derived)]
    ///     <li>[prop.Name]</li>
	[end loop]
	/// </ul>
	[end if]
    public virtual void [cls.CSharpName()]([cls.CSharpName(ClassKind.Builder)] @this)
    {
		[loop(cls->sup:SuperClasses)]
        this.[sup.CSharpName()](@this);
		[end loop]
		[GenerateInitImplementation(model, cls)]
    }
    [loop(cls->op:Operations)]
^
    /// <summary>
    /// Implements the operation: [cls.CSharpName()].[op.Name]()
    /// </summary>
    public virtual [op.ReturnType.CSharpFullPublicName(ClassKind.Immutable)] [cls.CSharpName()]_[op.Name]([GetImplParameters(cls, op)])
    {
        throw new NotImplementedException();
    }
	[end loop]
^
	[end loop]
	[loop(model->Namespace->Declarations->enm:typeof(MetaEnum))]
    [loop(enm->op:Operations)]
^
    /// <summary>
    /// Implements the operation: [enm.CSharpName()].[op.Name]
    /// </summary>
    public virtual [op.ReturnType.CSharpFullPublicName(ClassKind.Immutable)] [enm.CSharpName()]_[op.Name]([GetImplParameters(enm, op)])
    {
        throw new NotImplementedException();
    }
	[end loop]
^
	[end loop]
^
	[loop(model->Namespace->Declarations->func:typeof(MetaFunction))]
	[GenerateFunction(func, ClassKind.Builder)]
	[end loop]
}
^
end template

template GenerateFactory(MetaModel model)
/// <summary>
/// Factory class for creating instances of model elements.
/// </summary>
public class [model.CSharpFactoryName()] : global::MetaDslx.Core.Immutable.ModelFactory
{
    public [model.CSharpFactoryName()]()
        : base()
    {
		[model.CSharpDescriptorName()].Init();
    }
^
    public [model.CSharpFactoryName()](global::MetaDslx.Core.Immutable.MutableModel model)
        : base(model)
    {
		[model.CSharpDescriptorName()].Init();
    }
^
    public override global::MetaDslx.Core.Immutable.IMutableSymbol Create(string type)
    {
        switch (type)
        {
			[loop(model->Namespace->Declarations->cls:typeof(MetaClass))]
				[if (!cls.IsAbstract)]
            case "[cls.CSharpName()]": return (global::MetaDslx.Core.Immutable.IMutableSymbol)this.[cls.CSharpName()]();
				[end if]
			[end loop]
            default:
                throw new ModelException("Unknown type name: " + type);
        }
    }
	[loop(model->Namespace->Declarations->cls:typeof(MetaClass))]
		[if (!cls.IsAbstract)]
^
    /// <summary>
    /// Creates a new instance of [cls.CSharpName()].
    /// </summary>
    public [cls.CSharpName(ClassKind.Builder)] [cls.CSharpName()](params global::MetaDslx.Core.Immutable.PropertyInit["[]"] propertyInitializers)
	{
		global::MetaDslx.Core.Immutable.MutableSymbolBase symbol = (global::MetaDslx.Core.Immutable.MutableSymbolBase)this.AddSymbol(new [cls.CSharpName(ClassKind.Id)]());
		symbol.MInitProperties(propertyInitializers);
		symbol.MMakeCreated();
		return ([cls.CSharpName(ClassKind.Builder)])symbol;
	}
		[end if]
	[end loop]
}
^
end template

template GenerateFunction(MetaFunction func, ClassKind classKind)
public abstract [func.ReturnType.CSharpFullPublicName(classKind)] [func.Name]([GetParameters(func, classKind)]);
end template

template GenerateInitImplementation(MetaModel model, MetaClass cls)
[loop(cls->prop:Properties)]
	[MetaSynthetizedPropertyInitializer synInit = GetSynthetizedInitializerFor(cls, prop)]
	[if (synInit != null)]
		[if (ModelCompilerContext.Current.TypeProvider.GetTypeOf(synInit.Value) is MetaCollectionType)]
@this.[prop.Name].ClearLazy();
			[if (synInit.Value.Type is MetaCollectionType)]
@this.[prop.Name].LazyAddRange([GenerateExpression(synInit.Value)]);
			[else]
@this.[prop.Name].LazyAdd([GenerateExpression(synInit.Value)]);
			[end if]
		[else]
@this.[prop.Name]Lazy = () => ([prop.Type.CSharpFullName(ClassKind.Builder)])([GenerateExpression(synInit.Value)]);
		[end if]
	[end if]
[end loop]
[loop(cls->Constructor->Initializers->init:typeof(MetaInheritedPropertyInitializer))]
	[if (init.Object != null && init.Property != null)]
		[if (((MetaClass)init.Object.Type).GetAllSuperClasses(true).Contains(init.PropertyContext))]
			[if (init.Value.Type is MetaCollectionType)]
@this.[init.ObjectName]LazyChild.[init.PropertyName] = () => [GenerateExpression(init.Value)]; 
			[else]
@this.[init.ObjectName]LazyChild.[init.PropertyName] = () => [GenerateExpression(init.Value)];
			[end if]
		[else]
((MutableSymbolBase)@this).MChildAddLazy([init.Object.CSharpFullDescriptorName(ClassKind.Builder)], [init.Property.CSharpFullDescriptorName(ClassKind.Builder)], () => [GenerateExpression(init.Value)]);
		[end if]
	[end if]
[end loop]
end template

template GenerateExpression(MetaExpression expr)
[switch (expr)]
[type as MetaBracketExpression:]([GenerateExpression(expr.Expression)])\
[type as MetaThisExpression:]@this\
[type as MetaNullExpression:]null\
[type as MetaTypeAsExpression:][GenerateExpression(expr.Expression)] as [expr.TypeReference.CSharpName(ClassKind.Builder)]\
[type as MetaTypeCastExpression:]([expr.TypeReference.CSharpName(ClassKind.Builder)])[GenerateExpression(expr.Expression)]\
[type as MetaTypeCheckExpression:][GenerateExpression(expr.Expression)] is [expr.TypeReference.CSharpName(ClassKind.Builder)]\
[type as MetaTypeOfExpression:][GenerateTypeOf(expr)]\
[type as MetaConditionalExpression:][GenerateExpression(expr.Condition)] ? [GenerateExpression(expr.Then)] : [GenerateExpression(expr.Else)]\
[type as MetaConstantExpression:][GetCSharpValue(expr.Value)]\
[type as MetaIdentifierExpression:][GenerateIdentifierExpression(expr)]\
[type as MetaMemberAccessExpression:][GenerateExpression(expr.Expression)].[expr.Name]\
[type as MetaFunctionCallExpression:][GenerateFunctionCall(expr)]\
[type as MetaIndexerExpression:][GenerateIndexerCall(expr)]\
[type as MetaOperatorExpression:][GenerateOperator(expr)]\
[type as MetaNewExpression:]new [expr.TypeReference.Model.CSharpFullFactoryName(ClassKind.Immutable)](this.MModelPart).[expr.TypeReference.CSharpName(ClassKind.Immutable)]([GenerateNewPropertyInitializers(expr)])\
[type as MetaNewCollectionExpression:]new List<Func<object>>() { [GenerateNewCollectionValues(expr)] }\
[default:]***unknown expression type***
[end switch]
end template

template GenerateIdentifierExpression(MetaIdentifierExpression expr)
[if (expr.Definition is MetaProperty)]
@this.[expr.Name]\
[else]
[expr.Name]\
[end if]
end template

function bool SameFunction(MetaGlobalFunction mfunc1, MetaGlobalFunction mfunc2)
	return mfunc1.Name == mfunc2.Name && ModelCompilerContext.Current.TypeProvider.Equals((ModelObject)mfunc1.Type, (ModelObject)mfunc2.Type);
end function

template GenerateFunctionCall(MetaFunctionCallExpression call)
[if (call.Definition is MetaGlobalFunction && SameFunction((MetaGlobalFunction)call.Definition, MetaInstance.TypeOf))][GenerateTypeOf(call.Arguments[0])]\
[else]this.[GenerateExpression(call.Expression)]([GenerateCallArguments(call, "")])\
[end if]
end template

template GenerateIndexerCall(MetaIndexerExpression call)
[GenerateExpression(call.Expression)]["["][GenerateCallArguments(call, "")]["]"]\
end template

template GenerateTypeOf(object expr)
[switch(expr)]
[type as MetaPrimitiveType:]
[switch(expr.Name)]
[case "*none*":]global::MetaDslx.Core.Immutable.MetaInstance.None\
[case "*error*":]global::MetaDslx.Core.Immutable.MetaInstance.Error\
[case "*any*":]global::MetaDslx.Core.Immutable.MetaInstance.Any\
[case "object":]global::MetaDslx.Core.Immutable.MetaInstance.Object\
[case "string":]global::MetaDslx.Core.Immutable.MetaInstance.String\
[case "int":]global::MetaDslx.Core.Immutable.MetaInstance.Int\
[case "long":]global::MetaDslx.Core.Immutable.MetaInstance.Long\
[case "float":]global::MetaDslx.Core.Immutable.MetaInstance.Float\
[case "double":]global::MetaDslx.Core.Immutable.MetaInstance.Double\
[case "byte":]global::MetaDslx.Core.Immutable.MetaInstance.Byte\
[case "bool":]global::MetaDslx.Core.Immutable.MetaInstance.Bool\
[case "void":]global::MetaDslx.Core.Immutable.MetaInstance.Void\
[case "ModelObject":]global::MetaDslx.Core.Immutable.MetaInstance.ModelObject\
[case "ModelObjectList":]global::MetaDslx.Core.Immutable.MetaInstance.ModelObjectList\
[end switch]
[type as MetaTypeOfExpression:][GenerateTypeOf(expr.TypeReference)]\
[type as MetaClass:][expr.CSharpFullDescriptorName(ClassKind.Immutable)].MetaClass\
[type as MetaCollectionType:][expr.CSharpFullName(ClassKind.Immutable)]\
[default:]***error***\
[end switch]
end template

template GenerateCallArguments(MetaBoundExpression call, string prefix)
[loop(call->arg:Arguments; string delim = ""; delim = ", ")]
[delim][prefix][GenerateExpression(arg)]\
[end loop]
end template

template GenerateOperator(MetaOperatorExpression expr)
[switch (expr)]
[type as MetaUnaryExpression:]
	[if (expr is MetaPostIncrementAssignExpression || expr is MetaPostDecrementAssignExpression)]
[GenerateExpression(expr.Expression)][GetCSharpOperator(expr)]\
	[else]
[GetCSharpOperator(expr)][GenerateExpression(expr.Expression)]\
	[end if]
[type as MetaBinaryExpression:]
[GenerateExpression(expr.Left)][GetCSharpOperator(expr)][GenerateExpression(expr.Right)]\
[end switch]
end template

template GenerateNewPropertyInitializers(MetaNewExpression expr)
[if (hasloop(expr->pi:PropertyInitializers))]
[loop(expr->pi:PropertyInitializers; string delim = ""; delim = ", ")]
[delim]new PropertyInit([pi.Property.CSharpFullDescriptorName(ClassKind.Immutable)], () => [GenerateExpression(pi.Value)])\
[end loop]
[end if]
end template

template GenerateNewCollectionValues(MetaNewCollectionExpression expr)
[loop(expr->v:Values; string delim = ""; delim = ", \n")]
[delim][GenerateExpression(v)]\
[end loop]
end template

function string GetCSharpValue(object value)
	if (value == null) return "null";
	else if (value is bool && ((bool)value) == true) return "true";
	else if (value is bool && ((bool)value) == false) return "false";
	else if (value is string) return "\""+value.ToString()+"\"";
	else if (value is MetaExpression) return GenerateExpression((MetaExpression)value);
	else return value.ToString();
	end if
end function

function string GetCSharpIdentifier(object value)
	if (value == null) 
		return null;
	end if
	if (value is MetaConstantExpression && ((MetaConstantExpression)value).Value != null)
		return ((MetaConstantExpression)value).Value.ToString();
	else if (value is string) 
		return value.ToString();
	else
		return null;
	end if
end function

function string GetCSharpOperator(MetaOperatorExpression expr)
	switch(expr)
		type as MetaUnaryPlusExpression: return "+";
		type as MetaNegateExpression: return "-";
		type as MetaOnesComplementExpression: return "~";
		type as MetaNotExpression: return "!";
		type as MetaPostIncrementAssignExpression: return "++";
		type as MetaPostDecrementAssignExpression: return "--";
		type as MetaPreIncrementAssignExpression: return "++";
		type as MetaPreDecrementAssignExpression: return "--";
		type as MetaMultiplyExpression: return "*";
		type as MetaDivideExpression: return "/";
		type as MetaModuloExpression: return "%";
		type as MetaAddExpression: return "+";
		type as MetaSubtractExpression: return "-";
		type as MetaLeftShiftExpression: return "<<";
		type as MetaRightShiftExpression: return ">>";
		type as MetaLessThanExpression: return "<";
		type as MetaLessThanOrEqualExpression: return "<=";
		type as MetaGreaterThanExpression: return ">";
		type as MetaGreaterThanOrEqualExpression: return ">=";
		type as MetaEqualExpression: return "==";
		type as MetaNotEqualExpression: return "!=";
		type as MetaAndExpression: return "&";
		type as MetaOrExpression: return "|";
		type as MetaExclusiveOrExpression: return "^";
		type as MetaAndAlsoExpression: return "&&";
		type as MetaOrElseExpression: return "||";
		type as MetaNullCoalescingExpression: return "??";
		type as MetaMultiplyAssignExpression: return "*=";
		type as MetaDivideAssignExpression: return "/=";
		type as MetaModuloAssignExpression: return "%=";
		type as MetaAddAssignExpression: return "+=";
		type as MetaSubtractAssignExpression: return "-=";
		type as MetaLeftShiftAssignExpression: return "<<=";
		type as MetaRightShiftAssignExpression: return ">>=";
		type as MetaAndAssignExpression: return "&=";
		type as MetaExclusiveOrAssignExpression: return "^=";
		type as MetaOrAssignExpression: return "|=";
		default: return "";
	end switch
end function

function string GetTypeName(MetaExpression expr)
	if (expr is MetaTypeOfExpression) return ((MetaTypeOfExpression)expr).TypeReference.CSharpFullName(ClassKind.Immutable);
	else return null;
	end if
end function


template GenerateModelConstant(MetaModel model, MetaConstant mconst)
[GenerateDocumentation(mconst)]
public static readonly [mconst.Type.CSharpFullName(ClassKind.Builder)] [mconst.Name];
end template

template GenerateModelConstantImpl(MetaModel model, MetaConstant mconst, Dictionary<ModelObject, string> mobjToTmp)
[mconst.Name] = [GenerateExpression(mconst.Value)];
end template


template GenerateMetaModelInstance(MetaModel model)
[Dictionary<ModelObject, string> mobjToName = model.GetNamedModelObjects()]
public static class [model.CSharpInstancesName(ClassKind.Immutable)]
{
    private static global::MetaDslx.Core.Immutable.ImmutableModel model;
^
    public static global::MetaDslx.Core.Immutable.ImmutableModel Model
    {
        get { return [model.Name]Instance.model; }
    }
^
    public static readonly global::MetaDslx.Core.Immutable.MetaModel Meta;
^
    [loop(model->Namespace->Declarations->c:typeof(MetaConstant))]
    [GenerateModelConstant(model, c)]
    [end loop]
^
    [loop(mobj:Instances)]
	[GenerateModelObjectInstanceDeclaration(mobj, mobjToName)]
    [end loop]
^
    static [model.CSharpInstancesName()]()
    {
    }
}
end template

template GenerateModelObjectInstanceDeclaration(ModelObject mobj, Dictionary<ModelObject, string> mobjToName)
[if (mobj != null && mobj.MMetaClass != null)]
	[if (mobjToName.ContainsKey(mobj))]
		[string name = mobjToName[mobj]]
		[if (name.StartsWith("__"))]
private static readonly global::MetaDslx.Core.Immutable.[mobj.MMetaClass.CSharpName(ClassKind.Builder)] [name];
		[else]
			[if (mobj is MetaDocumentedElement)]
[GenerateDocumentation(((MetaDocumentedElement)mobj))]
			[end if]
public static readonly global::MetaDslx.Core.Immutable.[mobj.MMetaClass.CSharpName(ClassKind.Builder)] [name];
		[end if]
	[end if]
[end if]
end template
