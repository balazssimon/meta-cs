namespace MetaDslx.Core.Immutable;
generator ImmutableMetaModelGenerator for IEnumerable<ImmutableSymbol>;

template Generate()
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Diagnostics;
^
	[loop(Instances->mm:typeof(MetaModel))]
[GenerateMetamodel(mm)]
	[end loop]
end template

extern function string ToCamelCase(string identifier)
extern function string ToPascalCase(string identifier)
extern function string CSharpName(MetaNamespace mnamespace, NamespaceKind kind = NamespaceKind.Public, bool fullName = false)
extern function string CSharpName(MetaModel mmodel, ModelKind kind = ModelKind.None, bool fullName = false)
extern function string CSharpName(MetaType mtype, MetaModel mmodel, ClassKind kind = ClassKind.None, bool fullName = false)
extern function string CSharpName(MetaProperty mproperty, MetaModel mmodel, PropertyKind kind = PropertyKind.None, bool fullName = false)

template GenerateMetamodel(MetaModel model)
namespace [model.Namespace.CSharpName(NamespaceKind.Public, true)]
{
	[GenerateMetaModelInstance(model)]
^
	[GenerateFactory(model)]
^
	[loop(model->Namespace->Declarations->enm:typeof(MetaEnum))]
^
	[GenerateEnum(model, enm)]
	[end loop]
^
	[GenerateMetaModelDescriptor(model)]
}
^
namespace [model.Namespace.CSharpName(NamespaceKind.Implementation, true)]
{
	[GenerateMetaModelBuilderInstance(model)]
^
	[GenerateImplementationProvider(model)]
}
^
namespace [model.Namespace.CSharpName(NamespaceKind.Internal, true)]
{
	[GenerateImplementationBase(model)]
}
end template

template GenerateMetaModelDescriptor(MetaModel model)
public static class [model.CSharpName(ModelKind.Descriptor)]
{
}
end template

template GenerateMetaModelInstance(MetaModel model)
public class [model.CSharpName(ModelKind.ImmutableInstance)]
{
}
end template

template GenerateMetaModelBuilderInstance(MetaModel model)
public class [model.CSharpName(ModelKind.BuilderInstance)]
{
}
end template

template GenerateFactory(MetaModel model)
public class [model.CSharpName(ModelKind.Factory)]
{
}
end template

template GenerateImplementationProvider(MetaModel model)
public class [model.CSharpName(ModelKind.ImplementationProvider)]
{
}
end template

template GenerateImplementationBase(MetaModel model)
public class [model.CSharpName(ModelKind.ImplementationBase)]
{
}
end template

template GenerateDocumentation(MetaDocumentedElement elem)
[ImmutableModelList<string> lines = elem.GetDocumentationLines()]
[if (lines.Count > 0)]
/**
 * <summary>
	[loop(line:lines)]
 * [line]
	[end loop]
 * </summary>
 */
[end if]
end template

template GenerateEnum(MetaModel mmodel, MetaEnum enm)
[GenerateDocumentation(enm)]
public enum [enm.CSharpName(mmodel)]
{
	[loop(enm->value:EnumLiterals; separator delim = ",")]
	[GenerateDocumentation(value)]
	[value.Name][delim]\
	[end loop]
}
end template
