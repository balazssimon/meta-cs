namespace MetaDslx.Core;
generator ImmutableMetaModelGeneratorOld for IEnumerable<ModelObject>;

template Generate()
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using MetaDslx.Core;
using System.Diagnostics;
^
	[loop(Instances->mm:typeof(MetaModel))]
[GenerateMetamodel(mm)]
	[end loop]
end template

template GenerateMetamodel(MetaModel model)
namespace [model.Namespace.CSharpName(ClassKind.Immutable)]
{
    [GenerateMetaModelDescriptor(model)]
	[loop(model->Namespace->Declarations->enm:typeof(MetaEnum))]
    [GenerateEnum(enm)]
	[end loop]
	[loop(model->Namespace->Declarations->cls:typeof(MetaClass))]
    [GenerateImmutableInterface(cls)]
	[end loop]
	[loop(model->Namespace->Declarations->cls:typeof(MetaClass))]
    [GenerateBuilderInterface(cls)]
	[end loop]
	[loop(model->Namespace->Declarations->cls:typeof(MetaClass))]
    [GenerateImmutableInterfaceImpl(model, cls)]
	[end loop]
	[loop(model->Namespace->Declarations->cls:typeof(MetaClass))]
    [GenerateBuilderInterfaceImpl(model, cls)]
	[end loop]
	[GenerateMetaModelInstance(model)]
    [GenerateFactory(model)]
    [GenerateImplementationProvider(model)]
}
end template

template GenerateDocumentation(MetaDocumentedElement elem)
[IList<string> lines = elem.GetDocumentationLines()]
[if (lines.Count > 0)]
/**
 * <summary>
	[loop(line:lines)]
 * [line]
	[end loop]
 * </summary>
 */
[end if]
end template

template GenerateAnnotations(MetaAnnotatedElement elem)
[loop(elem->annot:Annotations)]
["["][annot.Name]["]"]
[end loop]
end template

template GenerateEnum(MetaEnum enm)
[GenerateAnnotations(enm)]
public enum [enm.CSharpName()]
{
    [loop(enm->value:EnumLiterals)]
    [value.Name],
	[end loop]
}
^
end template

function string GetAncestors(MetaClass cls, ClassKind classKind)
	string result = "";
	loop(cls->super:SuperClasses; separator delim = ", ")
		result += super.CSharpFullName(classKind)+delim;
	end loop
	if (result == "" && classKind == ClassKind.Immutable) 
		result = "global::MetaDslx.Core.Immutable.ImmutableSymbol";
	end if
	if (result == "" && classKind == ClassKind.Builder) 
		result = "global::MetaDslx.Core.Immutable.MutableSymbol";
	end if
	if (result != "") 
		result = " : "+result;
	end if
	return result;
end function

function string GetDescriptorAncestors(MetaClass cls)
	string result = "";
	loop(cls->super:SuperClasses; separator delim = ", ")
		result += "typeof("+super.CSharpFullDescriptorName(ClassKind.Immutable)+")"+delim;
	end loop
	return result;
end function

template GenerateImmutableInterface(MetaClass cls)
internal class [cls.CSharpName(ClassKind.Immutable)]Id : global::MetaDslx.Core.Immutable.SymbolId
{
	public override global::MetaDslx.Core.Immutable.ModelSymbolInfo ModelSymbolInfo { get { return [cls.Model.CSharpDescriptorName()].[cls.CSharpName()].ModelSymbolInfo; } }
    public override global::System.Type ImmutableType { get { return typeof([cls.CSharpName(ClassKind.Immutable)]); } }
    public override global::System.Type MutableType { get { return typeof([cls.CSharpName(ClassKind.Builder)]); } }
^
    public override global::MetaDslx.Core.Immutable.ImmutableSymbolBase CreateImmutable(global::MetaDslx.Core.Immutable.ImmutableModel model)
    {
        return new [cls.CSharpImplName(ClassKind.Immutable)](this, model);
    }
^
    public override global::MetaDslx.Core.Immutable.MutableSymbolBase CreateMutable(global::MetaDslx.Core.Immutable.MutableModel model, bool creating)
    {
        return new [cls.CSharpImplName(ClassKind.Builder)](this, model, creating);
    }
}
^
[GenerateAnnotations(cls)]
public interface [cls.CSharpName(ClassKind.Immutable)][GetAncestors(cls, ClassKind.Immutable)]
{
    [loop(cls->prop:Properties)]
    [GenerateImmutableProperty(prop)]
	[end loop]
^
    [loop(cls->op:Operations)]
    [GenerateOperation(op)]
	[end loop]
^
	new [cls.CSharpName(ClassKind.Builder)] ToMutable();
	new [cls.CSharpName(ClassKind.Builder)] ToMutable(global::MetaDslx.Core.Immutable.MutableModel model);
}
^
end template

template GenerateBuilderInterface(MetaClass cls)
public interface [cls.CSharpName(ClassKind.Builder)][GetAncestors(cls, ClassKind.Builder)]
{
    [loop(cls->prop:Properties)]
    [GenerateBuilderProperty(prop)]
	[end loop]
^
	new [cls.CSharpName(ClassKind.Immutable)] ToImmutable();
	new [cls.CSharpName(ClassKind.Immutable)] ToImmutable(global::MetaDslx.Core.Immutable.ImmutableModel model);
}
^
end template

template GenerateImmutableProperty(MetaProperty prop)
[if (prop.Class.GetAllSuperPropertyNames().Contains(prop.Name))]
new \
[end if]
[prop.Type.CSharpFullPublicName(ClassKind.Immutable)] [prop.Name] { get; }
end template

template GenerateImmutableField(MetaClass cls, MetaProperty prop)
["[DebuggerBrowsable(DebuggerBrowsableState.Never)]"]
private [prop.Type.CSharpFullPublicName(ClassKind.Immutable)] [prop.GetFieldName(cls)];
end template

template GenerateBuilderProperty(MetaProperty prop)
[if (prop.Class.GetAllSuperPropertyNames().Contains(prop.Name))]
new \
[end if]
	[if((prop.Kind == MetaPropertyKind.Normal || prop.Kind == MetaPropertyKind.Containment) && !(prop.Type is MetaCollectionType))]
[prop.Type.CSharpFullPublicName(ClassKind.Builder)] [prop.Name] { get; set; }
	[else]
[prop.Type.CSharpFullPublicName(ClassKind.Builder)] [prop.Name] { get; }
	[end if]
[if(!(prop.Type is MetaCollectionType))]
	[if (prop.Class.GetAllSuperPropertyNames().Contains(prop.Name))]
new \
	[end if]
Func<[prop.Type.CSharpFullPublicName(ClassKind.Builder)]> [prop.Name]Lazy { get; set; }
[end if]
[if(prop.Kind == MetaPropertyKind.Containment && (((prop.Type is MetaCollectionType) && (((MetaCollectionType)prop.Type).InnerType is MetaClass)) || (!(prop.Type is MetaCollectionType) && prop.Type is MetaClass)))]
	[if (prop.Class.GetAllSuperPropertyNames().Contains(prop.Name))]
new \
	[end if]
[end if]
end template

template GenerateBuilderField(MetaClass cls, MetaProperty prop)
private [prop.Type.CSharpFullPublicName(ClassKind.Builder)] [prop.GetFieldName(cls)];
end template

function string GetParameters(MetaFunction op, ClassKind classKind)
	string result = "";
	loop(op->param:Parameters; separator delim = ", ")
		result += param.Type.CSharpFullPublicName(classKind)+" "+param.Name+delim;
	end loop
	return result;
end function

function string GetImplParameters(MetaClass cls, MetaOperation op)
	string result = cls.CSharpFullName(ClassKind.Immutable)+" _this";
	string delim = ", ";
	loop(op->param:Parameters)
		result += delim+param.Type.CSharpFullPublicName(ClassKind.Immutable)+" "+param.Name;
	end loop
	return result;
end function

function string GetImplParameters(MetaEnum enm, MetaOperation op)
	string result = enm.CSharpFullName(ClassKind.Immutable)+" _this";
	string delim = ", ";
	loop(op->param:Parameters)
		result += delim+param.Type.CSharpFullPublicName(ClassKind.Immutable)+" "+param.Name;
	end loop
	return result;
end function

function string GetEnumImplParameters(MetaEnum enm, MetaOperation op)
	string result = "this "+enm.CSharpFullName(ClassKind.Immutable)+" _this";
	string delim = ", ";
	loop(op->param:Parameters)
		result += delim+param.Type.CSharpFullPublicName(ClassKind.Immutable)+" "+param.Name;
	end loop
	return result;
end function

function string GetEnumImplCallParameterNames(MetaOperation op)
	string result = "_this";
	string delim = ", ";
	loop(op->param:Parameters)
		result += delim+param.Name;
	end loop
	return result;
end function

function string GetImplCallParameterNames(MetaOperation op)
	string result = "this";
	string delim = ", ";
	loop(op->param:Parameters)
		result += delim+param.Name;
	end loop
	return result;
end function

template GenerateOperation(MetaOperation op)
[op.ReturnType.CSharpFullPublicName(ClassKind.Immutable)] [op.Name]([GetParameters(op, ClassKind.Immutable)]);
end template

template GenerateImmutableInterfaceImpl(MetaModel model, MetaClass cls)
internal class [cls.CSharpImplName(ClassKind.Immutable)] : global::MetaDslx.Core.Immutable.ImmutableSymbolBase, [cls.CSharpFullName(ClassKind.Immutable)]
{
    [loop(cls->prop:GetAllProperties())]
    [GenerateImmutableField(cls, prop)]
	[end loop]
^
    internal [cls.CSharpImplName()](global::MetaDslx.Core.Immutable.SymbolId id, global::MetaDslx.Core.Immutable.ImmutableModel model)
		: base(id, model)
    {
    }
^
    public override MetaModel MMetaModel
    {
        get { return [cls.Model.CSharpFullInstanceName(ClassKind.Immutable)]; }
    }
^
    public override MetaClass MMetaClass
    {
        get { return [cls.CSharpFullInstanceName(ClassKind.Immutable)]; }
    }
^
    public new [cls.CSharpFullName(ClassKind.Builder)] ToMutable()
	{
		return ([cls.CSharpFullName(ClassKind.Builder)])base.ToMutable();
	}
^
    public new [cls.CSharpFullName(ClassKind.Builder)] ToMutable(global::MetaDslx.Core.Immutable.MutableModel model)
	{
		return ([cls.CSharpFullName(ClassKind.Builder)])base.ToMutable(model);
	}
	[loop(cls->sup:GetAllSuperClasses())]
^
    [sup.CSharpFullName(ClassKind.Builder)] [sup.CSharpFullName(ClassKind.Immutable)].ToMutable()
	{
		return this.ToMutable();
	}
^
    [sup.CSharpFullName(ClassKind.Builder)] [sup.CSharpFullName(ClassKind.Immutable)].ToMutable(global::MetaDslx.Core.Immutable.MutableModel model)
	{
		return this.ToMutable(model);
	}
	[end loop]
    [loop(cls->prop:GetAllProperties())]
^
    [GenerateImmutablePropertyImpl(model, cls, prop)]
	[end loop]
    [loop(cls->op:GetAllOperations())]
^
    [GenerateOperationImpl(model, op)]
	[end loop]
}
^
end template

template GenerateBuilderInterfaceImpl(MetaModel model, MetaClass cls)
internal class [cls.CSharpImplName(ClassKind.Builder)] : global::MetaDslx.Core.Immutable.MutableSymbolBase, [cls.CSharpFullName(ClassKind.Builder)]
{
    [loop(cls->prop:GetAllProperties() where prop.Type is MetaCollectionType)]
    [GenerateBuilderField(cls, prop)]
	[end loop]
^
    internal [cls.CSharpImplName(ClassKind.Builder)](global::MetaDslx.Core.Immutable.SymbolId id, global::MetaDslx.Core.Immutable.MutableModel model, bool creating)
		: base(id, model, creating)
    {
    }
^
    internal protected override void MInit()
    {
		[loop(cls->sup:GetAllSuperClasses(false))]
		[sup.Model.Name]ImplementationProvider.Implementation.[sup.CSharpName()](this);
		[end loop]
		[model.Name]ImplementationProvider.Implementation.[cls.CSharpName()](this);
    }
^
    public override MetaModel MMetaModel
    {
        get { return [cls.Model.CSharpFullInstanceName(ClassKind.Immutable)]; }
    }
^
    public override MetaClass MMetaClass
    {
        get { return [cls.CSharpFullInstanceName(ClassKind.Immutable)]; }
    }
^
    public new [cls.CSharpFullName(ClassKind.Immutable)] ToImmutable()
	{
		return ([cls.CSharpFullName(ClassKind.Immutable)])base.ToImmutable();
	}
^
    public new [cls.CSharpFullName(ClassKind.Immutable)] ToImmutable(global::MetaDslx.Core.Immutable.ImmutableModel model)
	{
		return ([cls.CSharpFullName(ClassKind.Immutable)])base.ToImmutable(model);
	}
	[loop(cls->sup:GetAllSuperClasses())]
^
    [sup.CSharpFullName(ClassKind.Immutable)] [sup.CSharpFullName(ClassKind.Builder)].ToImmutable()
	{
		return this.ToImmutable();
	}
^
    [sup.CSharpFullName(ClassKind.Immutable)] [sup.CSharpFullName(ClassKind.Builder)].ToImmutable(global::MetaDslx.Core.Immutable.ImmutableModel model)
	{
		return this.ToImmutable(model);
	}
	[end loop]
    [loop(cls->prop:GetAllProperties())]
^
    [GenerateBuilderPropertyImpl(model, cls, prop)]
	[end loop]
}
^
end template

template GeneratePropertyDeclaration(MetaModel model, MetaClass cls, MetaProperty prop)
[if(prop.Class == cls)]
[GenerateAnnotations(prop)]
[if(prop.Kind == MetaPropertyKind.Containment)]
["[ContainmentAttribute]"]
[end if]
[if(prop.Kind != MetaPropertyKind.Normal && prop.Kind != MetaPropertyKind.Containment)]
["[ReadonlyAttribute]"]
[end if]
[loop(p:prop.OppositeProperties)]
["[OppositeAttribute(typeof("][p.Class.CSharpFullDescriptorName(ClassKind.Immutable)]["), \""][p.Name]["\")]"]
[end if]
[loop(p:prop.SubsettedProperties)]
	[if(cls.GetAllSuperClasses(true).Contains(p.Class))]
["[SubsetsAttribute(typeof("][p.Class.CSharpFullDescriptorName(ClassKind.Immutable)]["), \""][p.Name]["\")]"]
	[else]
// ERROR: subsetted property '[p.CSharpFullDescriptorName(ClassKind.Immutable)]' must be a property of an ancestor class
	[end if]
[end if]
[loop(p:prop.RedefinedProperties)]
	[if(cls.GetAllSuperClasses(true).Contains(p.Class))]
["[RedefinesAttribute(typeof("][p.Class.CSharpFullDescriptorName(ClassKind.Immutable)]["), \""][p.Name]["\")]"]
	[else]
// ERROR: redefined property '[p.CSharpFullDescriptorName(ClassKind.Immutable)]' must be a property of an ancestor class
	[end if]
[end if]
[if (prop.Type is MetaCollectionType)]
	[MetaCollectionType collType = (MetaCollectionType)prop.Type]
public static readonly global::MetaDslx.Core.Immutable.ModelProperty [prop.Name]Property =
    global::MetaDslx.Core.Immutable.ModelProperty.Register(typeof([prop.Class.Model.CSharpDescriptorName()].[prop.Class.CSharpName()]), "[prop.Name]",
        new global::MetaDslx.Core.Immutable.ModelPropertyTypeInfo(typeof([collType.InnerType.CSharpFullPublicName(ClassKind.Immutable)]), typeof([prop.Type.CSharpFullPublicName(ClassKind.Immutable)])),
        new global::MetaDslx.Core.Immutable.ModelPropertyTypeInfo(typeof([collType.InnerType.CSharpFullPublicName(ClassKind.Builder)]), typeof([prop.Type.CSharpFullPublicName(ClassKind.Builder)])),
		() => [prop.CSharpFullInstanceName(ClassKind.Immutable)]);
[else]
public static readonly global::MetaDslx.Core.Immutable.ModelProperty [prop.Name]Property =
    global::MetaDslx.Core.Immutable.ModelProperty.Register(typeof([prop.Class.Model.CSharpDescriptorName()].[prop.Class.CSharpName()]), "[prop.Name]",
        new global::MetaDslx.Core.Immutable.ModelPropertyTypeInfo(typeof([prop.Type.CSharpFullPublicName(ClassKind.Immutable)]), null),
        new global::MetaDslx.Core.Immutable.ModelPropertyTypeInfo(typeof([prop.Type.CSharpFullPublicName(ClassKind.Builder)]), null),
		() => [prop.CSharpFullInstanceName(ClassKind.Immutable)]);
[end if]
[end if]
^
end template

template GenerateImmutablePropertyImpl(MetaModel model, MetaClass cls, MetaProperty prop)
^
[if (cls.GetAllFinalProperties().Contains(prop))]
public [prop.Type.CSharpFullPublicName(ClassKind.Immutable)] [prop.Name]
[else]
["[DebuggerBrowsable(DebuggerBrowsableState.Never)]"]
[prop.Type.CSharpFullPublicName(ClassKind.Immutable)] [prop.Class.CSharpFullName(ClassKind.Immutable)].[prop.Name]
[end if]
{
    [if(prop.Type is MetaCollectionType)]
    get { return this.GetList<[((MetaCollectionType)prop.Type).InnerType.CSharpFullPublicName(ClassKind.Immutable)]>([prop.CSharpFullDescriptorName(ClassKind.Immutable)], ref [prop.GetFieldName(cls)]); }
	[else if (prop.Type.IsReferenceType())]
    get { return this.GetReference<[prop.Type.CSharpFullPublicName(ClassKind.Immutable)]>([prop.CSharpFullDescriptorName(ClassKind.Immutable)], ref [prop.GetFieldName(cls)]); }
	[else]
    get { return this.GetValue<[prop.Type.CSharpFullPublicName(ClassKind.Immutable)]>([prop.CSharpFullDescriptorName(ClassKind.Immutable)], ref [prop.GetFieldName(cls)]); }
	[end if]
}
end template

template GenerateBuilderPropertyImpl(MetaModel model, MetaClass cls, MetaProperty prop)
^
[if (cls.GetAllFinalProperties().Contains(prop))]
public [prop.Type.CSharpFullPublicName(ClassKind.Builder)] [prop.Name]
[else]
["[DebuggerBrowsable(DebuggerBrowsableState.Never)]"]
[prop.Type.CSharpFullPublicName(ClassKind.Builder)] [prop.Class.CSharpFullName(ClassKind.Builder)].[prop.Name]
[end if]
{
    [if(prop.Type is MetaCollectionType)]
    get { return this.GetList<[((MetaCollectionType)prop.Type).InnerType.CSharpFullPublicName(ClassKind.Builder)]>([prop.CSharpFullDescriptorName(ClassKind.Immutable)], ref [prop.GetFieldName(cls)]); }
	[else if (prop.Type.IsReferenceType())]
    get { return this.GetReference<[prop.Type.CSharpFullPublicName(ClassKind.Builder)]>([prop.CSharpFullDescriptorName(ClassKind.Immutable)]); }
	[else]
    get { return this.GetValue<[prop.Type.CSharpFullPublicName(ClassKind.Builder)]>([prop.CSharpFullDescriptorName(ClassKind.Immutable)]); }
	[end if]
	[if((prop.Kind == MetaPropertyKind.Normal || prop.Kind == MetaPropertyKind.Containment) && !(prop.Type is MetaCollectionType))]
		[if (prop.Type.IsReferenceType())]
    set { this.SetReference<[prop.Type.CSharpFullPublicName(ClassKind.Builder)]>([prop.CSharpFullDescriptorName(ClassKind.Immutable)], value); }
		[else]
    set { this.SetValue<[prop.Type.CSharpFullPublicName(ClassKind.Builder)]>([prop.CSharpFullDescriptorName(ClassKind.Immutable)], value); }
		[end if]
	[end if]
}
[if(!(prop.Type is MetaCollectionType))]
^
	[if (cls.GetAllFinalProperties().Contains(prop))]
public Func<[prop.Type.CSharpFullPublicName(ClassKind.Builder)]> [prop.Name]Lazy
	[else]
["[DebuggerBrowsable(DebuggerBrowsableState.Never)]"]
Func<[prop.Type.CSharpFullPublicName(ClassKind.Builder)]> [prop.Class.CSharpFullName(ClassKind.Builder)].[prop.Name]Lazy
	[end if]
{
		[if (prop.Type.IsReferenceType())]
    get { return this.GetLazyReference<[prop.Type.CSharpFullPublicName(ClassKind.Builder)]>([prop.CSharpFullDescriptorName(ClassKind.Immutable)]); }
    set { this.SetLazyReference([prop.CSharpFullDescriptorName(ClassKind.Immutable)], value); }
		[else]
    get { return this.GetLazyValue<[prop.Type.CSharpFullPublicName(ClassKind.Builder)]>([prop.CSharpFullDescriptorName(ClassKind.Immutable)]); }
    set { this.SetLazyValue([prop.CSharpFullDescriptorName(ClassKind.Immutable)], value); }
		[end if]
}
[end if]
end template

function string GetReturn(MetaOperation op)
    if (op.ReturnType.CSharpName() == "void") 
		return "";
	else 
		return "return ";
	end if
end function

template GenerateOperationImpl(MetaModel model, MetaOperation op)
^
[op.ReturnType.CSharpFullPublicName(ClassKind.Immutable)] [op.Parent.CSharpFullName(ClassKind.Immutable)].[op.Name]([GetParameters(op, ClassKind.Immutable)])
{
    [GetReturn(op)][model.CSharpFullImplementationName(ClassKind.Immutable)].[op.Parent.CSharpName()]_[op.Name]([GetImplCallParameterNames(op)]);
}
end template

function string GetSuperClasses(MetaClass cls)
	string result = "";
    loop(cls->sup:SuperClasses; separator delim = ", ")
		result += sup.CSharpFullName()+delim;
	end loop
	return result;
end function

function string GetAllSuperClasses(MetaClass cls)
	string result = "";
    loop(cls->sup:GetAllSuperClasses(false); separator delim = ", ")
		result += sup.CSharpFullName()+delim;
	end loop
	return result;
end function

template GenerateMetaModelDescriptor(MetaModel model)
public static class [model.CSharpDescriptorName()]
{
    private static global::System.Collections.Generic.List<global::MetaDslx.Core.Immutable.ModelProperty> properties;
^
    static [model.CSharpDescriptorName()]()
    {
        MetaDescriptor.properties = new global::System.Collections.Generic.List<global::MetaDslx.Core.Immutable.ModelProperty>();
		global::System.Collections.Generic.List<global::MetaDslx.Core.Immutable.ModelProperty> properties = new global::System.Collections.Generic.List<global::MetaDslx.Core.Immutable.ModelProperty>();
    [loop(model->Namespace->Declarations->cls:typeof(MetaClass)->prop:Properties)]
        properties.Add([cls.CSharpName()].[prop.Name]Property);
    [end loop]
    }
^
    public static void Initialize()
    {

    }
^
	public const string Uri = "[model.Uri]";
^
    [loop(model->Namespace->Declarations->cls:typeof(MetaClass))]
    [GenerateMetaModelClass(cls)]
    [end loop]
}
^
end template


template GenerateMetaModelClass(MetaClass cls)
^
[if (cls.SuperClasses.Count > 0)]
["[ModelSymbolDecriptor("][GetDescriptorAncestors(cls)][")]"]
[else]
["[ModelSymbolDecriptor]"]
[end if]
public static class [cls.CSharpName()]
{
    static [cls.CSharpName()]()
    {
        [cls.CSharpName()].ModelSymbolInfo = global::MetaDslx.Core.Immutable.ModelSymbolInfo.GetSymbolInfo(typeof([cls.CSharpName()]));
    }
^
    public static global::MetaDslx.Core.Immutable.ModelSymbolInfo ModelSymbolInfo { get; }
^
[if (cls.CSharpName() == "MetaClass")]
    public static global::MetaDslx.Core.Immutable.MetaClass _MetaClass
[else]
    public static global::MetaDslx.Core.Immutable.MetaClass MetaClass
[end if]
    {
        get { return null;/*[cls.CSharpFullInstanceName()];*/ }
    }
^
    [loop(cls->prop:Properties)]
    [GeneratePropertyDeclaration(cls.Model, cls, prop)]
    [end loop]
}
end template

template GenerateImplementationProvider(MetaModel model)
internal static class [model.Name]ImplementationProvider
{
    // If there is a compile error at this line, create a new class called [model.Name]Implementation
	// which is a subclass of [model.Name]ImplementationBase:
    private static [model.Name]Implementation implementation = new [model.Name]Implementation();
^
    public static [model.Name]Implementation Implementation
    {
        get { return [model.Name]ImplementationProvider.implementation; }
    }
}
	[loop(model->Namespace->Declarations->enm:typeof(MetaEnum))]
^
public static class [enm.Name]Extensions
{
    [loop(enm->op:Operations)]
    public static [op.ReturnType.CSharpFullPublicName(ClassKind.Immutable)] [op.Name]([GetEnumImplParameters(enm, op)])
    {
        [GetReturn(op)][model.Name]ImplementationProvider.Implementation.[op.Parent.CSharpName()]_[op.Name]([GetEnumImplCallParameterNames(op)]);
    }
	[end loop]
}
	[end loop]
^
/// <summary>
/// Base class for implementing the behavior of the model elements.
/// This class has to be be overriden in [model.Name]Implementation to provide custom
/// implementation for the constructors, operations and property values.
/// </summary>
internal abstract class [model.Name]ImplementationBase
{
	public virtual void [model.CSharpInstancesName(ClassKind.Builder)]([model.CSharpInstancesName(ClassKind.Builder)] _this)
	{
	}
	[loop(model->Namespace->Declarations->cls:typeof(MetaClass))]
    /// <summary>
	/// Implements the constructor: [cls.CSharpName()]()
    /// </summary>
	[if (hasloop(cls->sup:SuperClasses))]
	/// Direct superclasses: [GetSuperClasses(cls)]
	/// All superclasses: [GetAllSuperClasses(cls)]
	[end if]
	[if (hasloop(cls->prop:Properties where prop.Kind == MetaPropertyKind.Readonly))]
    /// Initializes the following readonly properties:
	/// <ul>
    [loop(cls->prop:Properties where prop.Kind == MetaPropertyKind.Readonly)]
    ///     <li>[prop.Name]</li>
	[end loop]
	/// </ul>
	[end if]
	[if (hasloop(cls->prop:Properties where prop.Kind == MetaPropertyKind.Lazy))]
    /// Initializes the following lazy properties:
	/// <ul>
    [loop(cls->prop:Properties where prop.Kind == MetaPropertyKind.Lazy)]
    ///     <li>[prop.Name]</li>
	[end loop]
	/// </ul>
	[end if]
	[if (hasloop(cls->prop:Properties where prop.Kind == MetaPropertyKind.Derived))]
    /// Initializes the following derived properties:
	/// <ul>
    [loop(cls->prop:Properties where prop.Kind == MetaPropertyKind.Derived)]
    ///     <li>[prop.Name]</li>
	[end loop]
	/// </ul>
	[end if]
    public virtual void [cls.CSharpName()]([cls.CSharpName(ClassKind.Builder)] _this)
    {
    }
    [loop(cls->op:Operations)]
^
    /// <summary>
    /// Implements the operation: [cls.CSharpName()].[op.Name]()
    /// </summary>
    public virtual [op.ReturnType.CSharpFullPublicName(ClassKind.Immutable)] [cls.CSharpName()]_[op.Name]([GetImplParameters(cls, op)])
    {
        throw new NotImplementedException();
    }
	[end loop]
^
	[end loop]
	[loop(model->Namespace->Declarations->enm:typeof(MetaEnum))]
    [loop(enm->op:Operations)]
^
    /// <summary>
    /// Implements the operation: [enm.CSharpName()].[op.Name]
    /// </summary>
    public virtual [op.ReturnType.CSharpFullPublicName(ClassKind.Immutable)] [enm.CSharpName()]_[op.Name]([GetImplParameters(enm, op)])
    {
        throw new NotImplementedException();
    }
	[end loop]
^
	[end loop]
}
^
end template

template GenerateFactory(MetaModel model)
/// <summary>
/// Factory class for creating instances of model elements.
/// </summary>
public class [model.CSharpFactoryName()] : global::MetaDslx.Core.Immutable.ModelFactory
{
    public [model.CSharpFactoryName()](MutableModel model, ModelFactoryFlags flags = ModelFactoryFlags.None)
        : base(model, flags)
    {
		[model.CSharpFullDescriptorName(ClassKind.Immutable)].Initialize();
    }
^
    public override global::MetaDslx.Core.Immutable.MutableSymbolBase Create(string type)
    {
        switch (type)
        {
			[loop(model->Namespace->Declarations->cls:typeof(MetaClass))]
				[if (!cls.IsAbstract)]
            case "[cls.CSharpName()]": return (global::MetaDslx.Core.Immutable.MutableSymbolBase)this.[cls.CSharpName()]();
				[end if]
			[end loop]
            default:
                throw new ModelException("Unknown type name: " + type);
        }
    }
	[loop(model->Namespace->Declarations->cls:typeof(MetaClass))]
		[if (!cls.IsAbstract)]
^
    /// <summary>
    /// Creates a new instance of [cls.CSharpName()].
    /// </summary>
    public [cls.CSharpName(ClassKind.Builder)] [cls.CSharpName()]()
	{
		global::MetaDslx.Core.Immutable.MutableSymbolBase symbol = this.CreateSymbol(new [cls.CSharpName(ClassKind.Id)]());
		return ([cls.CSharpName(ClassKind.Builder)])symbol;
	}
		[end if]
	[end loop]
}
^
end template


template GenerateMetaModelInstance(MetaModel model)
[Dictionary<ModelObject, string> mobjToName = model.GetNamedModelObjects()]
[bool coreModel = model.CSharpFullName(ClassKind.Immutable) == "global::MetaDslx.Core.Immutable.Meta"]
internal class [model.CSharpInstancesName(ClassKind.Builder)]
{
	internal static [model.CSharpInstancesName(ClassKind.Builder)] instance = new [model.CSharpInstancesName(ClassKind.Builder)]();
^
	[if (coreModel)]
	internal readonly global::MetaDslx.Core.Immutable.MetaModelBuilder _MetaModel;
	[else]
	internal readonly global::MetaDslx.Core.Immutable.MetaModelBuilder MetaModel;
	[end if]
	internal readonly global::MetaDslx.Core.Immutable.MutableModel Model;
^
    [loop(model->Namespace->Declarations->c:typeof(MetaConstant))]
    [GenerateModelConstant(model, c)]
    [end loop]
^
    [loop(mobj:Instances)]
	[GenerateModelObjectInstanceDeclaration(mobj, mobjToName)]
    [end loop]
^
    private [model.CSharpInstancesName(ClassKind.Builder)]()
    {
		this.Model = new global::MetaDslx.Core.Immutable.MutableModel();
		[model.CSharpFullFactoryName(ClassKind.Immutable)] factory = new [model.CSharpFullFactoryName(ClassKind.Immutable)](this.Model, global::MetaDslx.Core.Immutable.ModelFactoryFlags.DontMakeSymbolsCreated);
		[model.Name]ImplementationProvider.Implementation.[model.CSharpInstancesName(ClassKind.Builder)](this);
^
		[loop(mobj:Instances)]
		[GenerateModelObjectInstance(coreModel, mobj, mobjToName)]
		[end loop]
^
		[loop(mobj:Instances)]
		[GenerateModelObjectInstanceInitializer(coreModel, mobj, mobjToName)]
		[end loop]
^
		[loop(mobj:Instances)]
		[GenerateModelObjectInstanceFinalizer(mobj, mobjToName)]
		[end loop]
^
        this.Model.EvaluateLazyValues();
    }
}
^
public class [model.CSharpInstancesName(ClassKind.Immutable)]
{
^
	private static bool initialized;
^
	public static bool IsInitialized
	{
		get { return [model.CSharpInstancesName(ClassKind.Immutable)].initialized; }
	}
^
	[if (coreModel)]
	public static readonly global::MetaDslx.Core.Immutable.MetaModel _MetaModel;
	[else]
	public static readonly global::MetaDslx.Core.Immutable.MetaModel MetaModel;
	[end if]
	public static readonly global::MetaDslx.Core.Immutable.ImmutableModel Model;
^
    [loop(model->Namespace->Declarations->c:typeof(MetaConstant))]
    [GenerateImmutableModelConstant(model, c)]
    [end loop]
^
    [loop(mobj:Instances where mobjToName.ContainsKey(mobj) && !mobjToName[mobj].StartsWith("__"))]
	[GenerateImmutableModelObjectInstanceDeclaration(model, mobj, mobjToName)]
    [end loop]
^
	static [model.CSharpInstancesName(ClassKind.Immutable)]()
	{
		[model.CSharpInstancesName(ClassKind.Immutable)].Model = [model.CSharpInstancesName(ClassKind.Builder)].instance.Model.ToImmutable();
		global::MetaDslx.Core.Immutable.ImmutableModel model = [model.CSharpInstancesName(ClassKind.Immutable)].Model;
		[if (coreModel)]
		[model.CSharpInstancesName(ClassKind.Immutable)]._MetaModel = [model.CSharpInstancesName(ClassKind.Builder)].instance._MetaModel.ToImmutable(model);
		[else]
		[model.CSharpInstancesName(ClassKind.Immutable)].MetaModel = [model.CSharpInstancesName(ClassKind.Builder)].instance.MetaModel.ToImmutable(model);
		[end if]
^
		[loop(mobj:Instances where mobjToName.ContainsKey(mobj) && !mobjToName[mobj].StartsWith("__"))]
		[GenerateImmutableModelObjectInstanceDeclarationInitializer(model, mobj, mobjToName)]
		[end loop]
^
		[model.CSharpInstancesName(ClassKind.Immutable)].initialized = true;
	}
}
end template

template GenerateImmutableModelConstant(MetaModel model, MetaConstant mconst)
[GenerateDocumentation(mconst)]
public static readonly [mconst.Type.CSharpFullName(ClassKind.Immutable)] [mconst.Name] = [model.CSharpInstancesName(ClassKind.Builder)].instance.[mconst.Name].ToImmutable();
end template

template GenerateModelConstant(MetaModel model, MetaConstant mconst)
[GenerateDocumentation(mconst)]
internal [mconst.Type.CSharpFullName(ClassKind.Builder)] [mconst.Name] = null;
end template

template GenerateImmutableModelObjectInstanceDeclaration(MetaModel model, ModelObject mobj, Dictionary<ModelObject, string> mobjToName)
[if (mobj != null && mobj.MMetaClass != null)]
	[if (mobjToName.ContainsKey(mobj))]
		[if (!mobjToName[mobj].StartsWith("__"))]
[string name = mobjToName[mobj]]
			[if (mobj is MetaDocumentedElement)]
[GenerateDocumentation(((MetaDocumentedElement)mobj))]
			[end if]
public static readonly global::MetaDslx.Core.Immutable.[mobj.MMetaClass.CSharpName(ClassKind.Immutable)] [name];
		[end if]
	[end if]
[end if]
end template

template GenerateImmutableModelObjectInstanceDeclarationInitializer(MetaModel model, ModelObject mobj, Dictionary<ModelObject, string> mobjToName)
[if (mobj != null && mobj.MMetaClass != null)]
	[if (mobjToName.ContainsKey(mobj))]
		[if (!mobjToName[mobj].StartsWith("__"))]
[string name = mobjToName[mobj]]
[model.CSharpInstancesName(ClassKind.Immutable)].[name] = [model.CSharpInstancesName(ClassKind.Builder)].instance.[name].ToImmutable(model);
		[end if]
	[end if]
[end if]
end template

template GenerateModelObjectInstanceDeclaration(ModelObject mobj, Dictionary<ModelObject, string> mobjToName)
[if (mobj != null && mobj.MMetaClass != null)]
	[if (mobjToName.ContainsKey(mobj))]
		[string name = mobjToName[mobj]]
		[if (name.StartsWith("__"))]
private readonly global::MetaDslx.Core.Immutable.[mobj.MMetaClass.CSharpName(ClassKind.Builder)] [name];
		[else]
internal readonly global::MetaDslx.Core.Immutable.[mobj.MMetaClass.CSharpName(ClassKind.Builder)] [name];
		[end if]
	[end if]
[end if]
end template

template GenerateModelObjectInstance(bool coreModel, ModelObject mobj, Dictionary<ModelObject, string> mobjToName)
[if (mobj != null && mobj.MMetaClass != null)]
	[if (mobjToName.ContainsKey(mobj))]
		[string name = mobjToName[mobj]]
[name] = factory.[mobj.MMetaClass.CSharpName()]();
		[if (mobj is MetaModel)]
			[if (coreModel)]
_MetaModel = [name];
			[else]
MetaModel = [name];
			[end if]
		[end if]
	[end if]
[end if]
end template

template GenerateModelObjectInstanceInitializer(bool coreModel, ModelObject mobj, Dictionary<ModelObject, string> mobjToName)
[if (mobj != null && mobj.MMetaClass != null)]
	[if (mobjToName.ContainsKey(mobj))]
		[loop(mobj->prop:MGetProperties() where !prop.IsReadonly)]
			[if (prop.MetaProperty != null && prop.MetaProperty.Kind != MetaPropertyKind.Derived)]
				[object propValue = mobj.MGet(prop)]
[GenerateModelObjectPropertyValue(coreModel, mobj, prop, propValue, mobjToName)]
			[end if]
		[end loop]
	[end if]
[end if]
end template

template GenerateModelObjectInstanceFinalizer(ModelObject mobj, Dictionary<ModelObject, string> mobjToName)
[if (mobj != null && mobj.MMetaClass != null)]
	[if (mobjToName.ContainsKey(mobj))]
		[string name = mobjToName[mobj]]
((global::MetaDslx.Core.Immutable.MutableSymbolBase)[name]).MMakeCreated();
	[end if]
[end if]
end template

template GenerateModelObjectPropertyValue(bool coreModel, ModelObject mobj, ModelProperty prop, object value, Dictionary<ModelObject, string> mobjToName)
[string name = mobjToName[mobj]]
[ModelObject moValue = value as ModelObject]
[if (value == null)]
	[if (prop.Type != null && prop.Type.IsClass)]
[name].[prop.Name] = null;
	[else]
// [name].[prop.Name] = null;
	[end if]
[else if (value is string)]
[name].[prop.Name] = "[value]";
[else if (value is bool)]
[name].[prop.Name] = [value.ToString().ToLower()];
[else if (value.GetType().IsPrimitive)]
[name].[prop.Name] = [value.ToString()];
[else if (MetaBuiltInTypes.Types.Contains(value))]
	[if (coreModel)]
		[if (mobjToName.ContainsKey(moValue))]
[name].[prop.Name]Lazy = () => [mobjToName[moValue]];
		[else]
[name].[prop.Name]Lazy = () => this.[((MetaPrimitiveType)moValue).Name.ToPascalCase()];
		[end if]
	[else]
[name].[prop.Name] = [GenerateTypeOf(value)];
	[end if]
[else if (value is MetaPrimitiveType)]
	[if (coreModel)]
[name].[prop.Name]Lazy = () => [mobjToName[moValue]];
	[else]
[name].[prop.Name] = [GenerateTypeOf(value)];
	[end if]
[else if (value is Enum)]
[name].[prop.Name] = [GetEnumValueOf(value)];
[else if (moValue != null)]
	[if (mobjToName.ContainsKey(moValue))]
[name].[prop.Name]Lazy = () => [mobjToName[moValue]];
	[else]
// Omitted since not part of the model: [name].[prop.Name] = [moValue]
	[end if]
[else]
	[IEnumerable<object> mc = (value as ModelCollection) as IEnumerable<object>]
	[if (mc != null)]
		[loop(cvalue:mc)]
[GenerateModelObjectPropertyCollectionValue(coreModel, mobj, prop, cvalue, mobjToName)]
		[end loop]
	[else]
// Invalid property value type: [name].[prop.Name] = [value.GetType()]
	[end if]
[end if]
end template

template GenerateModelObjectPropertyCollectionValue(bool coreModel, ModelObject mobj, ModelProperty prop, object value, Dictionary<ModelObject, string> mobjToName)
[string name = mobjToName[mobj]]
[ModelObject moValue = value as ModelObject]
[if (value == null)]
[name].[prop.Name].Add(null);
[else if (value is string)]
[name].[prop.Name].Add("[value]");
[else if (value is bool)]
[name].[prop.Name].Add([value.ToString().ToLower()]);
[else if (value.GetType().IsPrimitive)]
[name].[prop.Name].Add([value.ToString()]);
[else if (MetaBuiltInTypes.Types.Contains(value))]
	[if (coreModel)]
		[if (mobjToName.ContainsKey(moValue))]
[name].[prop.Name].AddLazy(() => [mobjToName[moValue]]);
		[else]
[name].[prop.Name].AddLazy(() => this.[((MetaPrimitiveType)value).Name.ToPascalCase()]);
		[end if]
	[else]
[name].[prop.Name].Add([GenerateTypeOf(value)]);
	[end if]
[else if (value is MetaPrimitiveType)]
	[if (coreModel)]
		[if (mobjToName.ContainsKey(moValue))]
[name].[prop.Name].AddLazy(() => [mobjToName[moValue]]);
		[else]
[name].[prop.Name].AddLazy(() => this.[((MetaPrimitiveType)value).Name.ToPascalCase()]);
		[end if]
	[else]
[name].[prop.Name].Add([GenerateTypeOf(value)]);
	[end if]
[else if (value is Enum)]
[name].[prop.Name].Add([GetEnumValueOf(value)]);
[else if (moValue != null)]
	[if (mobjToName.ContainsKey(moValue))]
[name].[prop.Name].AddLazy(() => [mobjToName[moValue]]);
	[else]
// Omitted since not part of the model: [name].[prop.Name] = [moValue]
	[end if]
[else]
	[IEnumerable<object> mc = (value as ModelCollection) as IEnumerable<object>]
	[if (mc != null)]
		[loop(cvalue:mc)]
[GenerateModelObjectPropertyCollectionValue(coreModel, mobj, prop, cvalue, mobjToName)]
		[end loop]
	[else]
// Invalid property value type: [name].[prop.Name] = [value.GetType()]
	[end if]
[end if]
end template

function string GetEnumValueOf(object enm)
	string result = "global::"+enm.GetType().FullName.Replace("+",".")+"."+enm.ToString();
	if (!result.StartsWith("global::MetaDslx.Core.Immutable.") && result.StartsWith("global::MetaDslx.Core."))
		result = result.Replace("global::MetaDslx.Core.", "global::MetaDslx.Core.Immutable.");
	end if
	return result;
end function

template GenerateTypeOf(object expr)
[switch(expr)]
[type as MetaPrimitiveType:]
[switch(expr.Name)]
[case "*none*":]global::MetaDslx.Core.Immutable.MetaInstance.IsInitialized ? global::MetaDslx.Core.Immutable.MetaInstance.None.ToMutable() : null\
[case "*error*":]global::MetaDslx.Core.Immutable.MetaInstance.IsInitialized ? global::MetaDslx.Core.Immutable.MetaInstance.Error.ToMutable() : null\
[case "*any*":]global::MetaDslx.Core.Immutable.MetaInstance.IsInitialized ? global::MetaDslx.Core.Immutable.MetaInstance.Any.ToMutable() : null\
[case "object":]global::MetaDslx.Core.Immutable.MetaInstance.IsInitialized ? global::MetaDslx.Core.Immutable.MetaInstance.Object.ToMutable() : null\
[case "string":]global::MetaDslx.Core.Immutable.MetaInstance.IsInitialized ? global::MetaDslx.Core.Immutable.MetaInstance.String.ToMutable() : null\
[case "int":]global::MetaDslx.Core.Immutable.MetaInstance.IsInitialized ? global::MetaDslx.Core.Immutable.MetaInstance.Int.ToMutable() : null\
[case "long":]global::MetaDslx.Core.Immutable.MetaInstance.IsInitialized ? global::MetaDslx.Core.Immutable.MetaInstance.Long.ToMutable() : null\
[case "float":]global::MetaDslx.Core.Immutable.MetaInstance.IsInitialized ? global::MetaDslx.Core.Immutable.MetaInstance.Float.ToMutable() : null\
[case "double":]global::MetaDslx.Core.Immutable.MetaInstance.IsInitialized ? global::MetaDslx.Core.Immutable.MetaInstance.Double.ToMutable() : null\
[case "byte":]global::MetaDslx.Core.Immutable.MetaInstance.IsInitialized ? global::MetaDslx.Core.Immutable.MetaInstance.Byte.ToMutable() : null\
[case "bool":]global::MetaDslx.Core.Immutable.MetaInstance.IsInitialized ? global::MetaDslx.Core.Immutable.MetaInstance.Bool.ToMutable() : null\
[case "void":]global::MetaDslx.Core.Immutable.MetaInstance.IsInitialized ? global::MetaDslx.Core.Immutable.MetaInstance.Void.ToMutable() : null\
[case "ModelObject":]global::MetaDslx.Core.Immutable.MetaInstance.IsInitialized ? global::MetaDslx.Core.Immutable.MetaInstance.ModelObject.ToMutable() : null\
[case "ModelObjectList":]global::MetaDslx.Core.Immutable.MetaInstance.IsInitialized ? global::MetaDslx.Core.Immutable.MetaInstance.ModelObjectList.ToMutable() : null\
[case "DefinitionList":]global::MetaDslx.Core.Immutable.MetaInstance.IsInitialized ? global::MetaDslx.Core.Immutable.MetaInstance.DefinitionList.ToMutable() : null\
[end switch]
[type as MetaClass:][expr.CSharpFullDescriptorName(ClassKind.Immutable)].MetaClass\
[type as MetaCollectionType:][expr.CSharpFullName(ClassKind.Immutable)]\
[default:]***error***\
[end switch]
end template
