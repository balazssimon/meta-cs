parser grammar MetaModelParser;

options
{
    tokenVocab = MetaModelLexer; 
	generateCompilerBase=true;
}

@header {
using MetaDslx.Core.Immutable;
}

main: namespaceDeclaration;

$QualifiedName
qualifiedName : identifier (TDot identifier)*;
identifierList : identifier (TComma identifier)*;
qualifiedNameList : qualifiedName (TComma qualifiedName)*;

$Property(Annotations)
$Symbol(MetaAnnotation)
annotation : TOpenBracket $Property(Name) $Value identifier /*annotationParams?*/ TCloseBracket;

/*
annotationParams : TOpenParen annotationParamList? TCloseParen;
annotationParamList : annotationParam (TComma annotationParam)*;

$Property(Properties)
$Symbol(MetaAnnotationProperty)
annotationParam : $Property(Name) $Value identifier;
*/

$NameDef(symbolType=MetaNamespace,nestingProperty=Namespaces,merge=true)
$Trivia(Documentation)
namespaceDeclaration: annotation* KNamespace qualifiedName TOpenBrace metamodelDeclaration declaration* TCloseBrace;

$Property(MetaModel)
$NameDef(MetaModel)
$Trivia(Documentation)
metamodelDeclaration: annotation* KMetamodel identifier (TOpenParen metamodelPropertyList? TCloseParen)? TSemicolon;

metamodelPropertyList : metamodelProperty (TComma metamodelProperty)*;

$Property
metamodelProperty : identifier TAssign $Value stringLiteral;

declaration : enumDeclaration | classDeclaration | associationDeclaration | constDeclaration;

$Property(Declarations) 
$TypeDef(MetaEnum)
$Trivia(Documentation)
enumDeclaration : annotation* KEnum identifier TOpenBrace $Property(EnumLiterals) enumValues (TSemicolon enumMemberDeclaration*)? TCloseBrace;
enumValues : enumValue (TComma enumValue)*;
$NameDef(MetaEnumLiteral)
$Trivia(Documentation)
enumValue : annotation* identifier;
enumMemberDeclaration : $Property(Operations) operationDeclaration;

$Property(Declarations) 
$TypeDef(MetaClass)
$Trivia(Documentation)
classDeclaration : annotation* $Property(name=IsAbstract,value=true) KAbstract? KClass identifier (TColon $Property(SuperClasses) classAncestors)? TOpenBrace classMemberDeclaration* TCloseBrace;
classAncestors : classAncestor (TComma classAncestor)*;
classAncestor : $TypeUse(symbolType=MetaClass,location=ResolutionLocation.Parent) qualifiedName;
classMemberDeclaration 
	: $Property(Properties) fieldDeclaration 
	| $Property(Operations) operationDeclaration
	;

$NameDef(MetaProperty)
$Trivia(Documentation)
fieldDeclaration : annotation* $Property(Kind) fieldModifier? $Property(Type) typeReference identifier (redefinitions | subsettings)? TSemicolon;
fieldModifier 
	: $Value(MetaPropertyKind.Containment) KContainment 
	| $Value(MetaPropertyKind.Readonly) KReadonly 
	| $Value(MetaPropertyKind.Lazy) KLazy 
	| $Value(MetaPropertyKind.Derived) KDerived
	;

redefinitions : KRedefines $Property(RedefinedProperties) nameUseList?;
subsettings : KSubsets $Property(SubsettedProperties) nameUseList?;

nameUseList : $NameUse(MetaProperty) qualifiedName (TComma qualifiedName)*;

$Property(Declarations) 
$NameDef(MetaConstant)
$Trivia(Documentation)
constDeclaration : KConst $Property(Type) typeReference identifier TSemicolon;

$TypeUse
returnType : typeReference | voidType;
$TypeUse
typeOfReference : typeReference;
$TypeUse
typeReference : collectionType | simpleType;
$TypeUse
simpleType : primitiveType | objectType | nullableType | qualifiedName;
$TypeUse(MetaClass)
classType : qualifiedName;

$Name
objectType 
	: KObject 
	| KSymbol
	| KString
	;
$Name
primitiveType 
	: KInt 
	| KLong 
	| KFloat 
	| KDouble 
	| KByte 
	| KBool
	;
$Name
voidType 
	: KVoid
	;

$TypeCtr(MetaNullableType)
nullableType : $Property(InnerType) primitiveType TQuestion;

$TypeCtr(MetaCollectionType)
collectionType : $Property(Kind) collectionKind TLessThan $Property(InnerType) simpleType TGreaterThan;
collectionKind 
	: $Value(MetaCollectionKind.Set) KSet 
	| $Value(MetaCollectionKind.List) KList
	| $Value(MetaCollectionKind.MultiSet) KMultiSet 
	| $Value(MetaCollectionKind.MultiList) KMultiList
	;

$NameDef(MetaOperation)
$Trivia(Documentation)
operationDeclaration : annotation* KStatic? $Property(ReturnType) returnType identifier TOpenParen $Property(Parameters) parameterList? TCloseParen TSemicolon;
parameterList : parameter (TComma parameter)*;

$NameDef(MetaParameter)
$Trivia(Documentation)
parameter : annotation* $Property(Type) typeReference identifier /*(TAssign expression)? { expression.ExpectedType = typeReference; }*/;


associationDeclaration : annotation* KAssociation $NameUse(MetaProperty) source=qualifiedName KWith $NameUse(MetaProperty) target=qualifiedName TSemicolon 
	-> { source.OppositeProperties = target; }
	;


// Additional rules for lexer:

// Identifiers
$Name
$Identifier
identifier : IdentifierNormal | IdentifierVerbatim;
//identifier : IdentifierGeneral | IdentifierVerbatim;

// Literals
literal 
    : $Value nullLiteral
	| $Value booleanLiteral
	| $Value integerLiteral
	| $Value decimalLiteral
	| $Value scientificLiteral
    | $Value stringLiteral
	;

// Null literal
nullLiteral : KNull;

// Boolean literals
booleanLiteral : KTrue | KFalse;

// Number literals
integerLiteral : IntegerLiteral;
decimalLiteral : DecimalLiteral;
scientificLiteral : ScientificLiteral;

// String literals
stringLiteral : RegularStringLiteral;

