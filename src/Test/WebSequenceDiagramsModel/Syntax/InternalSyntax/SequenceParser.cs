//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.6.6
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Users\Balazs\source\repos\meta-cs\src\Test\WebSequenceDiagramsModel\Syntax\InternalSyntax\SequenceParser.g4 by ANTLR 4.6.6

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace WebSequenceDiagramsModel.Syntax.InternalSyntax {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.6.6")]
[System.CLSCompliant(false)]
public partial class SequenceParser : Parser {
	public const int
		KTitle=1, KNote=2, KDestroy=3, KAlt=4, KElse=5, KEnd=6, KOpt=7, KLoop=8, 
		KRef=9, LSingleLineComment=10, LCommentStart=11, TCreate=12, TSync=13, 
		TAsync=14, TReturn=15, LUtf8Bom=16, LWhiteSpace=17, LCrLf=18, LLineEnd=19, 
		LIdentifier=20, KEndNote=21, KEndRef=22, TColon=23, TMinus=24, ArrowEndR=25;
	public const int
		RULE_main = 0, RULE_interaction = 1, RULE_line = 2, RULE_declaration = 3, 
		RULE_title = 4, RULE_arrow = 5, RULE_destroy = 6, RULE_alt = 7, RULE_altFragment = 8, 
		RULE_elseFragment = 9, RULE_loop = 10, RULE_loopFragment = 11, RULE_opt = 12, 
		RULE_optFragment = 13, RULE_ref = 14, RULE_simpleRefFragment = 15, RULE_messageRefFragment = 16, 
		RULE_refInput = 17, RULE_refOutput = 18, RULE_fragmentBody = 19, RULE_end = 20, 
		RULE_note = 21, RULE_singleLineNote = 22, RULE_multiLineNote = 23, RULE_simpleBody = 24, 
		RULE_simpleLine = 25, RULE_arrowType = 26, RULE_lifeLineName = 27, RULE_name = 28, 
		RULE_identifier = 29, RULE_text = 30, RULE_identifierPart = 31;
	public static readonly string[] ruleNames = {
		"main", "interaction", "line", "declaration", "title", "arrow", "destroy", 
		"alt", "altFragment", "elseFragment", "loop", "loopFragment", "opt", "optFragment", 
		"ref", "simpleRefFragment", "messageRefFragment", "refInput", "refOutput", 
		"fragmentBody", "end", "note", "singleLineNote", "multiLineNote", "simpleBody", 
		"simpleLine", "arrowType", "lifeLineName", "name", "identifier", "text", 
		"identifierPart"
	};

	private static readonly string[] _LiteralNames = {
		null, "'title'", "'note'", "'destroy'", "'alt'", "'else'", "'end'", "'opt'", 
		"'loop'", "'ref'", null, null, null, "'->'", "'->>'", null, null, null, 
		null, null, null, "'end note'", "'end ref'", "':'", null, "'r'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "KTitle", "KNote", "KDestroy", "KAlt", "KElse", "KEnd", "KOpt", 
		"KLoop", "KRef", "LSingleLineComment", "LCommentStart", "TCreate", "TSync", 
		"TAsync", "TReturn", "LUtf8Bom", "LWhiteSpace", "LCrLf", "LLineEnd", "LIdentifier", 
		"KEndNote", "KEndRef", "TColon", "TMinus", "ArrowEndR"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[System.Obsolete("Use Vocabulary instead.")]
	public static readonly string[] tokenNames = GenerateTokenNames(DefaultVocabulary, _SymbolicNames.Length);

	private static string[] GenerateTokenNames(IVocabulary vocabulary, int length) {
		string[] tokenNames = new string[length];
		for (int i = 0; i < tokenNames.Length; i++) {
			tokenNames[i] = vocabulary.GetLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = vocabulary.GetSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}

		return tokenNames;
	}

	[System.Obsolete("Use IRecognizer.Vocabulary instead.")]
	public override string[] TokenNames
	{
		get
		{
			return tokenNames;
		}
	}

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "SequenceParser.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public SequenceParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class MainContext : ParserRuleContext {
		public InteractionContext interaction() {
			return GetRuleContext<InteractionContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(SequenceParser.Eof, 0); }
		public MainContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_main; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMain(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MainContext main() {
		MainContext _localctx = new MainContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_main);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 64; interaction();
			State = 65; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InteractionContext : ParserRuleContext {
		public LineContext[] line() {
			return GetRuleContexts<LineContext>();
		}
		public LineContext line(int i) {
			return GetRuleContext<LineContext>(i);
		}
		public InteractionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_interaction; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInteraction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InteractionContext interaction() {
		InteractionContext _localctx = new InteractionContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_interaction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 70;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KTitle) | (1L << KNote) | (1L << KDestroy) | (1L << KAlt) | (1L << KOpt) | (1L << KLoop) | (1L << KRef) | (1L << LCrLf) | (1L << LIdentifier))) != 0)) {
				{
				{
				State = 67; line();
				}
				}
				State = 72;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LineContext : ParserRuleContext {
		public LineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_line; } }
	 
		public LineContext() { }
		public virtual void CopyFrom(LineContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class TitleLineContext : LineContext {
		public TitleContext title() {
			return GetRuleContext<TitleContext>(0);
		}
		public ITerminalNode LCrLf() { return GetToken(SequenceParser.LCrLf, 0); }
		public TitleLineContext(LineContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTitleLine(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DeclarationLineContext : LineContext {
		public ITerminalNode LCrLf() { return GetToken(SequenceParser.LCrLf, 0); }
		public DeclarationContext declaration() {
			return GetRuleContext<DeclarationContext>(0);
		}
		public DeclarationLineContext(LineContext context) { CopyFrom(context); }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclarationLine(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LineContext line() {
		LineContext _localctx = new LineContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_line);
		int _la;
		try {
			State = 80;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case KTitle:
				_localctx = new TitleLineContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 73; title();
				State = 74; Match(LCrLf);
				}
				break;
			case KNote:
			case KDestroy:
			case KAlt:
			case KOpt:
			case KLoop:
			case KRef:
			case LCrLf:
			case LIdentifier:
				_localctx = new DeclarationLineContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 77;
				_errHandler.Sync(this);
				_la = _input.La(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KNote) | (1L << KDestroy) | (1L << KAlt) | (1L << KOpt) | (1L << KLoop) | (1L << KRef) | (1L << LIdentifier))) != 0)) {
					{
					State = 76; declaration();
					}
				}

				State = 79; Match(LCrLf);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationContext : ParserRuleContext {
		public DestroyContext destroy() {
			return GetRuleContext<DestroyContext>(0);
		}
		public ArrowContext arrow() {
			return GetRuleContext<ArrowContext>(0);
		}
		public AltContext alt() {
			return GetRuleContext<AltContext>(0);
		}
		public OptContext opt() {
			return GetRuleContext<OptContext>(0);
		}
		public LoopContext loop() {
			return GetRuleContext<LoopContext>(0);
		}
		public RefContext @ref() {
			return GetRuleContext<RefContext>(0);
		}
		public NoteContext note() {
			return GetRuleContext<NoteContext>(0);
		}
		public DeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declaration; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationContext declaration() {
		DeclarationContext _localctx = new DeclarationContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_declaration);
		try {
			State = 89;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,3,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 82; destroy();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 83; arrow();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 84; alt();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 85; opt();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 86; loop();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 87; @ref();
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 88; note();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TitleContext : ParserRuleContext {
		public ITerminalNode KTitle() { return GetToken(SequenceParser.KTitle, 0); }
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public TitleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_title; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTitle(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TitleContext title() {
		TitleContext _localctx = new TitleContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_title);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 91; Match(KTitle);
			State = 93;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 92; name();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArrowContext : ParserRuleContext {
		public LifeLineNameContext source;
		public ArrowTypeContext type;
		public LifeLineNameContext target;
		public ITerminalNode TColon() { return GetToken(SequenceParser.TColon, 0); }
		public LifeLineNameContext[] lifeLineName() {
			return GetRuleContexts<LifeLineNameContext>();
		}
		public LifeLineNameContext lifeLineName(int i) {
			return GetRuleContext<LifeLineNameContext>(i);
		}
		public ArrowTypeContext arrowType() {
			return GetRuleContext<ArrowTypeContext>(0);
		}
		public TextContext text() {
			return GetRuleContext<TextContext>(0);
		}
		public ArrowContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arrow; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArrow(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArrowContext arrow() {
		ArrowContext _localctx = new ArrowContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_arrow);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 95; _localctx.source = lifeLineName();
			State = 96; _localctx.type = arrowType();
			State = 97; _localctx.target = lifeLineName();
			State = 98; Match(TColon);
			State = 100;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 99; text();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DestroyContext : ParserRuleContext {
		public ITerminalNode KDestroy() { return GetToken(SequenceParser.KDestroy, 0); }
		public LifeLineNameContext lifeLineName() {
			return GetRuleContext<LifeLineNameContext>(0);
		}
		public DestroyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_destroy; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDestroy(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DestroyContext destroy() {
		DestroyContext _localctx = new DestroyContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_destroy);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 102; Match(KDestroy);
			State = 104;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 103; lifeLineName();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AltContext : ParserRuleContext {
		public AltFragmentContext altFragment() {
			return GetRuleContext<AltFragmentContext>(0);
		}
		public EndContext end() {
			return GetRuleContext<EndContext>(0);
		}
		public ElseFragmentContext[] elseFragment() {
			return GetRuleContexts<ElseFragmentContext>();
		}
		public ElseFragmentContext elseFragment(int i) {
			return GetRuleContext<ElseFragmentContext>(i);
		}
		public AltContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alt; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AltContext alt() {
		AltContext _localctx = new AltContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_alt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 106; altFragment();
			State = 110;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==KElse) {
				{
				{
				State = 107; elseFragment();
				}
				}
				State = 112;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 113; end();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AltFragmentContext : ParserRuleContext {
		public TextContext condition;
		public ITerminalNode KAlt() { return GetToken(SequenceParser.KAlt, 0); }
		public ITerminalNode LCrLf() { return GetToken(SequenceParser.LCrLf, 0); }
		public FragmentBodyContext fragmentBody() {
			return GetRuleContext<FragmentBodyContext>(0);
		}
		public TextContext text() {
			return GetRuleContext<TextContext>(0);
		}
		public AltFragmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_altFragment; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAltFragment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AltFragmentContext altFragment() {
		AltFragmentContext _localctx = new AltFragmentContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_altFragment);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 115; Match(KAlt);
			State = 117;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 116; _localctx.condition = text();
				}
			}

			State = 119; Match(LCrLf);
			State = 120; fragmentBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseFragmentContext : ParserRuleContext {
		public TextContext condition;
		public ITerminalNode KElse() { return GetToken(SequenceParser.KElse, 0); }
		public ITerminalNode LCrLf() { return GetToken(SequenceParser.LCrLf, 0); }
		public FragmentBodyContext fragmentBody() {
			return GetRuleContext<FragmentBodyContext>(0);
		}
		public TextContext text() {
			return GetRuleContext<TextContext>(0);
		}
		public ElseFragmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elseFragment; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElseFragment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseFragmentContext elseFragment() {
		ElseFragmentContext _localctx = new ElseFragmentContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_elseFragment);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 122; Match(KElse);
			State = 124;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 123; _localctx.condition = text();
				}
			}

			State = 126; Match(LCrLf);
			State = 127; fragmentBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoopContext : ParserRuleContext {
		public LoopFragmentContext loopFragment() {
			return GetRuleContext<LoopFragmentContext>(0);
		}
		public EndContext end() {
			return GetRuleContext<EndContext>(0);
		}
		public LoopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loop; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLoop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LoopContext loop() {
		LoopContext _localctx = new LoopContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_loop);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 129; loopFragment();
			State = 130; end();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoopFragmentContext : ParserRuleContext {
		public TextContext condition;
		public ITerminalNode KLoop() { return GetToken(SequenceParser.KLoop, 0); }
		public ITerminalNode LCrLf() { return GetToken(SequenceParser.LCrLf, 0); }
		public FragmentBodyContext fragmentBody() {
			return GetRuleContext<FragmentBodyContext>(0);
		}
		public TextContext text() {
			return GetRuleContext<TextContext>(0);
		}
		public LoopFragmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loopFragment; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLoopFragment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LoopFragmentContext loopFragment() {
		LoopFragmentContext _localctx = new LoopFragmentContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_loopFragment);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 132; Match(KLoop);
			State = 134;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 133; _localctx.condition = text();
				}
			}

			State = 136; Match(LCrLf);
			State = 137; fragmentBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OptContext : ParserRuleContext {
		public OptFragmentContext optFragment() {
			return GetRuleContext<OptFragmentContext>(0);
		}
		public EndContext end() {
			return GetRuleContext<EndContext>(0);
		}
		public OptContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_opt; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OptContext opt() {
		OptContext _localctx = new OptContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_opt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 139; optFragment();
			State = 140; end();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OptFragmentContext : ParserRuleContext {
		public TextContext condition;
		public ITerminalNode KOpt() { return GetToken(SequenceParser.KOpt, 0); }
		public ITerminalNode LCrLf() { return GetToken(SequenceParser.LCrLf, 0); }
		public FragmentBodyContext fragmentBody() {
			return GetRuleContext<FragmentBodyContext>(0);
		}
		public TextContext text() {
			return GetRuleContext<TextContext>(0);
		}
		public OptFragmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_optFragment; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOptFragment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OptFragmentContext optFragment() {
		OptFragmentContext _localctx = new OptFragmentContext(_ctx, State);
		EnterRule(_localctx, 26, RULE_optFragment);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 142; Match(KOpt);
			State = 144;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 143; _localctx.condition = text();
				}
			}

			State = 146; Match(LCrLf);
			State = 147; fragmentBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RefContext : ParserRuleContext {
		public SimpleRefFragmentContext simpleRefFragment() {
			return GetRuleContext<SimpleRefFragmentContext>(0);
		}
		public MessageRefFragmentContext messageRefFragment() {
			return GetRuleContext<MessageRefFragmentContext>(0);
		}
		public RefContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ref; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRef(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RefContext @ref() {
		RefContext _localctx = new RefContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_ref);
		try {
			State = 151;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case KRef:
				EnterOuterAlt(_localctx, 1);
				{
				State = 149; simpleRefFragment();
				}
				break;
			case LIdentifier:
				EnterOuterAlt(_localctx, 2);
				{
				State = 150; messageRefFragment();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleRefFragmentContext : ParserRuleContext {
		public TextContext over;
		public TextContext refText;
		public ITerminalNode KRef() { return GetToken(SequenceParser.KRef, 0); }
		public ITerminalNode LCrLf() { return GetToken(SequenceParser.LCrLf, 0); }
		public SimpleBodyContext simpleBody() {
			return GetRuleContext<SimpleBodyContext>(0);
		}
		public ITerminalNode KEndRef() { return GetToken(SequenceParser.KEndRef, 0); }
		public ITerminalNode TColon() { return GetToken(SequenceParser.TColon, 0); }
		public TextContext[] text() {
			return GetRuleContexts<TextContext>();
		}
		public TextContext text(int i) {
			return GetRuleContext<TextContext>(i);
		}
		public SimpleRefFragmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleRefFragment; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleRefFragment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SimpleRefFragmentContext simpleRefFragment() {
		SimpleRefFragmentContext _localctx = new SimpleRefFragmentContext(_ctx, State);
		EnterRule(_localctx, 30, RULE_simpleRefFragment);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 153; Match(KRef);
			State = 157;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,13,_ctx) ) {
			case 1:
				{
				State = 154; _localctx.over = text();
				State = 155; Match(TColon);
				}
				break;
			}
			State = 160;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 159; _localctx.refText = text();
				}
			}

			State = 162; Match(LCrLf);
			State = 163; simpleBody();
			State = 164; Match(KEndRef);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MessageRefFragmentContext : ParserRuleContext {
		public RefInputContext refInput() {
			return GetRuleContext<RefInputContext>(0);
		}
		public SimpleBodyContext simpleBody() {
			return GetRuleContext<SimpleBodyContext>(0);
		}
		public RefOutputContext refOutput() {
			return GetRuleContext<RefOutputContext>(0);
		}
		public MessageRefFragmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_messageRefFragment; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMessageRefFragment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MessageRefFragmentContext messageRefFragment() {
		MessageRefFragmentContext _localctx = new MessageRefFragmentContext(_ctx, State);
		EnterRule(_localctx, 32, RULE_messageRefFragment);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 166; refInput();
			State = 167; simpleBody();
			State = 168; refOutput();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RefInputContext : ParserRuleContext {
		public LifeLineNameContext source;
		public ArrowTypeContext sourceType;
		public TextContext over;
		public TextContext message;
		public ITerminalNode KRef() { return GetToken(SequenceParser.KRef, 0); }
		public ITerminalNode LCrLf() { return GetToken(SequenceParser.LCrLf, 0); }
		public LifeLineNameContext lifeLineName() {
			return GetRuleContext<LifeLineNameContext>(0);
		}
		public ArrowTypeContext arrowType() {
			return GetRuleContext<ArrowTypeContext>(0);
		}
		public ITerminalNode TColon() { return GetToken(SequenceParser.TColon, 0); }
		public TextContext[] text() {
			return GetRuleContexts<TextContext>();
		}
		public TextContext text(int i) {
			return GetRuleContext<TextContext>(i);
		}
		public RefInputContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_refInput; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRefInput(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RefInputContext refInput() {
		RefInputContext _localctx = new RefInputContext(_ctx, State);
		EnterRule(_localctx, 34, RULE_refInput);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 170; _localctx.source = lifeLineName();
			State = 171; _localctx.sourceType = arrowType();
			State = 172; Match(KRef);
			State = 176;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,15,_ctx) ) {
			case 1:
				{
				State = 173; _localctx.over = text();
				State = 174; Match(TColon);
				}
				break;
			}
			State = 179;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 178; _localctx.message = text();
				}
			}

			State = 181; Match(LCrLf);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RefOutputContext : ParserRuleContext {
		public TextContext ignored;
		public ArrowTypeContext targetType;
		public LifeLineNameContext target;
		public TextContext message;
		public ITerminalNode KEndRef() { return GetToken(SequenceParser.KEndRef, 0); }
		public ITerminalNode TColon() { return GetToken(SequenceParser.TColon, 0); }
		public ArrowTypeContext arrowType() {
			return GetRuleContext<ArrowTypeContext>(0);
		}
		public LifeLineNameContext lifeLineName() {
			return GetRuleContext<LifeLineNameContext>(0);
		}
		public TextContext[] text() {
			return GetRuleContexts<TextContext>();
		}
		public TextContext text(int i) {
			return GetRuleContext<TextContext>(i);
		}
		public RefOutputContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_refOutput; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRefOutput(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RefOutputContext refOutput() {
		RefOutputContext _localctx = new RefOutputContext(_ctx, State);
		EnterRule(_localctx, 36, RULE_refOutput);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 183; Match(KEndRef);
			State = 185;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 184; _localctx.ignored = text();
				}
			}

			State = 187; _localctx.targetType = arrowType();
			State = 188; _localctx.target = lifeLineName();
			State = 189; Match(TColon);
			State = 191;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 190; _localctx.message = text();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FragmentBodyContext : ParserRuleContext {
		public LineContext[] line() {
			return GetRuleContexts<LineContext>();
		}
		public LineContext line(int i) {
			return GetRuleContext<LineContext>(i);
		}
		public FragmentBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fragmentBody; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFragmentBody(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FragmentBodyContext fragmentBody() {
		FragmentBodyContext _localctx = new FragmentBodyContext(_ctx, State);
		EnterRule(_localctx, 38, RULE_fragmentBody);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 196;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KTitle) | (1L << KNote) | (1L << KDestroy) | (1L << KAlt) | (1L << KOpt) | (1L << KLoop) | (1L << KRef) | (1L << LCrLf) | (1L << LIdentifier))) != 0)) {
				{
				{
				State = 193; line();
				}
				}
				State = 198;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EndContext : ParserRuleContext {
		public ITerminalNode KEnd() { return GetToken(SequenceParser.KEnd, 0); }
		public TextContext text() {
			return GetRuleContext<TextContext>(0);
		}
		public EndContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_end; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEnd(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EndContext end() {
		EndContext _localctx = new EndContext(_ctx, State);
		EnterRule(_localctx, 40, RULE_end);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 199; Match(KEnd);
			State = 201;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 200; text();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NoteContext : ParserRuleContext {
		public SingleLineNoteContext singleLineNote() {
			return GetRuleContext<SingleLineNoteContext>(0);
		}
		public MultiLineNoteContext multiLineNote() {
			return GetRuleContext<MultiLineNoteContext>(0);
		}
		public NoteContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_note; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNote(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NoteContext note() {
		NoteContext _localctx = new NoteContext(_ctx, State);
		EnterRule(_localctx, 42, RULE_note);
		try {
			State = 205;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,21,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 203; singleLineNote();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 204; multiLineNote();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SingleLineNoteContext : ParserRuleContext {
		public TextContext position;
		public TextContext noteText;
		public ITerminalNode KNote() { return GetToken(SequenceParser.KNote, 0); }
		public ITerminalNode TColon() { return GetToken(SequenceParser.TColon, 0); }
		public TextContext[] text() {
			return GetRuleContexts<TextContext>();
		}
		public TextContext text(int i) {
			return GetRuleContext<TextContext>(i);
		}
		public SingleLineNoteContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_singleLineNote; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSingleLineNote(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SingleLineNoteContext singleLineNote() {
		SingleLineNoteContext _localctx = new SingleLineNoteContext(_ctx, State);
		EnterRule(_localctx, 44, RULE_singleLineNote);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 207; Match(KNote);
			State = 208; _localctx.position = text();
			State = 209; Match(TColon);
			State = 210; _localctx.noteText = text();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultiLineNoteContext : ParserRuleContext {
		public ITerminalNode KNote() { return GetToken(SequenceParser.KNote, 0); }
		public SimpleBodyContext simpleBody() {
			return GetRuleContext<SimpleBodyContext>(0);
		}
		public ITerminalNode KEndNote() { return GetToken(SequenceParser.KEndNote, 0); }
		public MultiLineNoteContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiLineNote; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiLineNote(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MultiLineNoteContext multiLineNote() {
		MultiLineNoteContext _localctx = new MultiLineNoteContext(_ctx, State);
		EnterRule(_localctx, 46, RULE_multiLineNote);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 212; Match(KNote);
			State = 213; simpleBody();
			State = 214; Match(KEndNote);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleBodyContext : ParserRuleContext {
		public SimpleLineContext[] simpleLine() {
			return GetRuleContexts<SimpleLineContext>();
		}
		public SimpleLineContext simpleLine(int i) {
			return GetRuleContext<SimpleLineContext>(i);
		}
		public SimpleBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleBody; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleBody(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SimpleBodyContext simpleBody() {
		SimpleBodyContext _localctx = new SimpleBodyContext(_ctx, State);
		EnterRule(_localctx, 48, RULE_simpleBody);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 219;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==LIdentifier) {
				{
				{
				State = 216; simpleLine();
				}
				}
				State = 221;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleLineContext : ParserRuleContext {
		public TextContext text() {
			return GetRuleContext<TextContext>(0);
		}
		public ITerminalNode LCrLf() { return GetToken(SequenceParser.LCrLf, 0); }
		public SimpleLineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleLine; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleLine(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SimpleLineContext simpleLine() {
		SimpleLineContext _localctx = new SimpleLineContext(_ctx, State);
		EnterRule(_localctx, 50, RULE_simpleLine);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 222; text();
			State = 223; Match(LCrLf);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArrowTypeContext : ParserRuleContext {
		public ITerminalNode TSync() { return GetToken(SequenceParser.TSync, 0); }
		public ITerminalNode TAsync() { return GetToken(SequenceParser.TAsync, 0); }
		public ITerminalNode TReturn() { return GetToken(SequenceParser.TReturn, 0); }
		public ITerminalNode TCreate() { return GetToken(SequenceParser.TCreate, 0); }
		public ArrowTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arrowType; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArrowType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArrowTypeContext arrowType() {
		ArrowTypeContext _localctx = new ArrowTypeContext(_ctx, State);
		EnterRule(_localctx, 52, RULE_arrowType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 225;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << TCreate) | (1L << TSync) | (1L << TAsync) | (1L << TReturn))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LifeLineNameContext : ParserRuleContext {
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public LifeLineNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lifeLineName; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLifeLineName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LifeLineNameContext lifeLineName() {
		LifeLineNameContext _localctx = new LifeLineNameContext(_ctx, State);
		EnterRule(_localctx, 54, RULE_lifeLineName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 227; name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public NameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_name; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NameContext name() {
		NameContext _localctx = new NameContext(_ctx, State);
		EnterRule(_localctx, 56, RULE_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 229; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierContext : ParserRuleContext {
		public TextContext text() {
			return GetRuleContext<TextContext>(0);
		}
		public IdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifier; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierContext identifier() {
		IdentifierContext _localctx = new IdentifierContext(_ctx, State);
		EnterRule(_localctx, 58, RULE_identifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 231; text();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TextContext : ParserRuleContext {
		public IdentifierPartContext[] identifierPart() {
			return GetRuleContexts<IdentifierPartContext>();
		}
		public IdentifierPartContext identifierPart(int i) {
			return GetRuleContext<IdentifierPartContext>(i);
		}
		public TextContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_text; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitText(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TextContext text() {
		TextContext _localctx = new TextContext(_ctx, State);
		EnterRule(_localctx, 60, RULE_text);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 234;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 233; identifierPart();
				}
				}
				State = 236;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==LIdentifier );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierPartContext : ParserRuleContext {
		public ITerminalNode LIdentifier() { return GetToken(SequenceParser.LIdentifier, 0); }
		public IdentifierPartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierPart; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifierPart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierPartContext identifierPart() {
		IdentifierPartContext _localctx = new IdentifierPartContext(_ctx, State);
		EnterRule(_localctx, 62, RULE_identifierPart);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 238; Match(LIdentifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3\x1B\xF3\x4\x2\t"+
		"\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t"+
		"\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10"+
		"\t\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15"+
		"\x4\x16\t\x16\x4\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x4\x1B"+
		"\t\x1B\x4\x1C\t\x1C\x4\x1D\t\x1D\x4\x1E\t\x1E\x4\x1F\t\x1F\x4 \t \x4!"+
		"\t!\x3\x2\x3\x2\x3\x2\x3\x3\a\x3G\n\x3\f\x3\xE\x3J\v\x3\x3\x4\x3\x4\x3"+
		"\x4\x3\x4\x5\x4P\n\x4\x3\x4\x5\x4S\n\x4\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5"+
		"\x3\x5\x3\x5\x5\x5\\\n\x5\x3\x6\x3\x6\x5\x6`\n\x6\x3\a\x3\a\x3\a\x3\a"+
		"\x3\a\x5\ag\n\a\x3\b\x3\b\x5\bk\n\b\x3\t\x3\t\a\to\n\t\f\t\xE\tr\v\t\x3"+
		"\t\x3\t\x3\n\x3\n\x5\nx\n\n\x3\n\x3\n\x3\n\x3\v\x3\v\x5\v\x7F\n\v\x3\v"+
		"\x3\v\x3\v\x3\f\x3\f\x3\f\x3\r\x3\r\x5\r\x89\n\r\x3\r\x3\r\x3\r\x3\xE"+
		"\x3\xE\x3\xE\x3\xF\x3\xF\x5\xF\x93\n\xF\x3\xF\x3\xF\x3\xF\x3\x10\x3\x10"+
		"\x5\x10\x9A\n\x10\x3\x11\x3\x11\x3\x11\x3\x11\x5\x11\xA0\n\x11\x3\x11"+
		"\x5\x11\xA3\n\x11\x3\x11\x3\x11\x3\x11\x3\x11\x3\x12\x3\x12\x3\x12\x3"+
		"\x12\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x3\x13\x5\x13\xB3\n\x13\x3\x13"+
		"\x5\x13\xB6\n\x13\x3\x13\x3\x13\x3\x14\x3\x14\x5\x14\xBC\n\x14\x3\x14"+
		"\x3\x14\x3\x14\x3\x14\x5\x14\xC2\n\x14\x3\x15\a\x15\xC5\n\x15\f\x15\xE"+
		"\x15\xC8\v\x15\x3\x16\x3\x16\x5\x16\xCC\n\x16\x3\x17\x3\x17\x5\x17\xD0"+
		"\n\x17\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x19\x3\x19\x3\x19\x3\x19"+
		"\x3\x1A\a\x1A\xDC\n\x1A\f\x1A\xE\x1A\xDF\v\x1A\x3\x1B\x3\x1B\x3\x1B\x3"+
		"\x1C\x3\x1C\x3\x1D\x3\x1D\x3\x1E\x3\x1E\x3\x1F\x3\x1F\x3 \x6 \xED\n \r"+
		" \xE \xEE\x3!\x3!\x3!\x2\x2\x2\"\x2\x2\x4\x2\x6\x2\b\x2\n\x2\f\x2\xE\x2"+
		"\x10\x2\x12\x2\x14\x2\x16\x2\x18\x2\x1A\x2\x1C\x2\x1E\x2 \x2\"\x2$\x2"+
		"&\x2(\x2*\x2,\x2.\x2\x30\x2\x32\x2\x34\x2\x36\x2\x38\x2:\x2<\x2>\x2@\x2"+
		"\x2\x3\x3\x2\xE\x11\xEF\x2\x42\x3\x2\x2\x2\x4H\x3\x2\x2\x2\x6R\x3\x2\x2"+
		"\x2\b[\x3\x2\x2\x2\n]\x3\x2\x2\x2\f\x61\x3\x2\x2\x2\xEh\x3\x2\x2\x2\x10"+
		"l\x3\x2\x2\x2\x12u\x3\x2\x2\x2\x14|\x3\x2\x2\x2\x16\x83\x3\x2\x2\x2\x18"+
		"\x86\x3\x2\x2\x2\x1A\x8D\x3\x2\x2\x2\x1C\x90\x3\x2\x2\x2\x1E\x99\x3\x2"+
		"\x2\x2 \x9B\x3\x2\x2\x2\"\xA8\x3\x2\x2\x2$\xAC\x3\x2\x2\x2&\xB9\x3\x2"+
		"\x2\x2(\xC6\x3\x2\x2\x2*\xC9\x3\x2\x2\x2,\xCF\x3\x2\x2\x2.\xD1\x3\x2\x2"+
		"\x2\x30\xD6\x3\x2\x2\x2\x32\xDD\x3\x2\x2\x2\x34\xE0\x3\x2\x2\x2\x36\xE3"+
		"\x3\x2\x2\x2\x38\xE5\x3\x2\x2\x2:\xE7\x3\x2\x2\x2<\xE9\x3\x2\x2\x2>\xEC"+
		"\x3\x2\x2\x2@\xF0\x3\x2\x2\x2\x42\x43\x5\x4\x3\x2\x43\x44\a\x2\x2\x3\x44"+
		"\x3\x3\x2\x2\x2\x45G\x5\x6\x4\x2\x46\x45\x3\x2\x2\x2GJ\x3\x2\x2\x2H\x46"+
		"\x3\x2\x2\x2HI\x3\x2\x2\x2I\x5\x3\x2\x2\x2JH\x3\x2\x2\x2KL\x5\n\x6\x2"+
		"LM\a\x14\x2\x2MS\x3\x2\x2\x2NP\x5\b\x5\x2ON\x3\x2\x2\x2OP\x3\x2\x2\x2"+
		"PQ\x3\x2\x2\x2QS\a\x14\x2\x2RK\x3\x2\x2\x2RO\x3\x2\x2\x2S\a\x3\x2\x2\x2"+
		"T\\\x5\xE\b\x2U\\\x5\f\a\x2V\\\x5\x10\t\x2W\\\x5\x1A\xE\x2X\\\x5\x16\f"+
		"\x2Y\\\x5\x1E\x10\x2Z\\\x5,\x17\x2[T\x3\x2\x2\x2[U\x3\x2\x2\x2[V\x3\x2"+
		"\x2\x2[W\x3\x2\x2\x2[X\x3\x2\x2\x2[Y\x3\x2\x2\x2[Z\x3\x2\x2\x2\\\t\x3"+
		"\x2\x2\x2]_\a\x3\x2\x2^`\x5:\x1E\x2_^\x3\x2\x2\x2_`\x3\x2\x2\x2`\v\x3"+
		"\x2\x2\x2\x61\x62\x5\x38\x1D\x2\x62\x63\x5\x36\x1C\x2\x63\x64\x5\x38\x1D"+
		"\x2\x64\x66\a\x19\x2\x2\x65g\x5> \x2\x66\x65\x3\x2\x2\x2\x66g\x3\x2\x2"+
		"\x2g\r\x3\x2\x2\x2hj\a\x5\x2\x2ik\x5\x38\x1D\x2ji\x3\x2\x2\x2jk\x3\x2"+
		"\x2\x2k\xF\x3\x2\x2\x2lp\x5\x12\n\x2mo\x5\x14\v\x2nm\x3\x2\x2\x2or\x3"+
		"\x2\x2\x2pn\x3\x2\x2\x2pq\x3\x2\x2\x2qs\x3\x2\x2\x2rp\x3\x2\x2\x2st\x5"+
		"*\x16\x2t\x11\x3\x2\x2\x2uw\a\x6\x2\x2vx\x5> \x2wv\x3\x2\x2\x2wx\x3\x2"+
		"\x2\x2xy\x3\x2\x2\x2yz\a\x14\x2\x2z{\x5(\x15\x2{\x13\x3\x2\x2\x2|~\a\a"+
		"\x2\x2}\x7F\x5> \x2~}\x3\x2\x2\x2~\x7F\x3\x2\x2\x2\x7F\x80\x3\x2\x2\x2"+
		"\x80\x81\a\x14\x2\x2\x81\x82\x5(\x15\x2\x82\x15\x3\x2\x2\x2\x83\x84\x5"+
		"\x18\r\x2\x84\x85\x5*\x16\x2\x85\x17\x3\x2\x2\x2\x86\x88\a\n\x2\x2\x87"+
		"\x89\x5> \x2\x88\x87\x3\x2\x2\x2\x88\x89\x3\x2\x2\x2\x89\x8A\x3\x2\x2"+
		"\x2\x8A\x8B\a\x14\x2\x2\x8B\x8C\x5(\x15\x2\x8C\x19\x3\x2\x2\x2\x8D\x8E"+
		"\x5\x1C\xF\x2\x8E\x8F\x5*\x16\x2\x8F\x1B\x3\x2\x2\x2\x90\x92\a\t\x2\x2"+
		"\x91\x93\x5> \x2\x92\x91\x3\x2\x2\x2\x92\x93\x3\x2\x2\x2\x93\x94\x3\x2"+
		"\x2\x2\x94\x95\a\x14\x2\x2\x95\x96\x5(\x15\x2\x96\x1D\x3\x2\x2\x2\x97"+
		"\x9A\x5 \x11\x2\x98\x9A\x5\"\x12\x2\x99\x97\x3\x2\x2\x2\x99\x98\x3\x2"+
		"\x2\x2\x9A\x1F\x3\x2\x2\x2\x9B\x9F\a\v\x2\x2\x9C\x9D\x5> \x2\x9D\x9E\a"+
		"\x19\x2\x2\x9E\xA0\x3\x2\x2\x2\x9F\x9C\x3\x2\x2\x2\x9F\xA0\x3\x2\x2\x2"+
		"\xA0\xA2\x3\x2\x2\x2\xA1\xA3\x5> \x2\xA2\xA1\x3\x2\x2\x2\xA2\xA3\x3\x2"+
		"\x2\x2\xA3\xA4\x3\x2\x2\x2\xA4\xA5\a\x14\x2\x2\xA5\xA6\x5\x32\x1A\x2\xA6"+
		"\xA7\a\x18\x2\x2\xA7!\x3\x2\x2\x2\xA8\xA9\x5$\x13\x2\xA9\xAA\x5\x32\x1A"+
		"\x2\xAA\xAB\x5&\x14\x2\xAB#\x3\x2\x2\x2\xAC\xAD\x5\x38\x1D\x2\xAD\xAE"+
		"\x5\x36\x1C\x2\xAE\xB2\a\v\x2\x2\xAF\xB0\x5> \x2\xB0\xB1\a\x19\x2\x2\xB1"+
		"\xB3\x3\x2\x2\x2\xB2\xAF\x3\x2\x2\x2\xB2\xB3\x3\x2\x2\x2\xB3\xB5\x3\x2"+
		"\x2\x2\xB4\xB6\x5> \x2\xB5\xB4\x3\x2\x2\x2\xB5\xB6\x3\x2\x2\x2\xB6\xB7"+
		"\x3\x2\x2\x2\xB7\xB8\a\x14\x2\x2\xB8%\x3\x2\x2\x2\xB9\xBB\a\x18\x2\x2"+
		"\xBA\xBC\x5> \x2\xBB\xBA\x3\x2\x2\x2\xBB\xBC\x3\x2\x2\x2\xBC\xBD\x3\x2"+
		"\x2\x2\xBD\xBE\x5\x36\x1C\x2\xBE\xBF\x5\x38\x1D\x2\xBF\xC1\a\x19\x2\x2"+
		"\xC0\xC2\x5> \x2\xC1\xC0\x3\x2\x2\x2\xC1\xC2\x3\x2\x2\x2\xC2\'\x3\x2\x2"+
		"\x2\xC3\xC5\x5\x6\x4\x2\xC4\xC3\x3\x2\x2\x2\xC5\xC8\x3\x2\x2\x2\xC6\xC4"+
		"\x3\x2\x2\x2\xC6\xC7\x3\x2\x2\x2\xC7)\x3\x2\x2\x2\xC8\xC6\x3\x2\x2\x2"+
		"\xC9\xCB\a\b\x2\x2\xCA\xCC\x5> \x2\xCB\xCA\x3\x2\x2\x2\xCB\xCC\x3\x2\x2"+
		"\x2\xCC+\x3\x2\x2\x2\xCD\xD0\x5.\x18\x2\xCE\xD0\x5\x30\x19\x2\xCF\xCD"+
		"\x3\x2\x2\x2\xCF\xCE\x3\x2\x2\x2\xD0-\x3\x2\x2\x2\xD1\xD2\a\x4\x2\x2\xD2"+
		"\xD3\x5> \x2\xD3\xD4\a\x19\x2\x2\xD4\xD5\x5> \x2\xD5/\x3\x2\x2\x2\xD6"+
		"\xD7\a\x4\x2\x2\xD7\xD8\x5\x32\x1A\x2\xD8\xD9\a\x17\x2\x2\xD9\x31\x3\x2"+
		"\x2\x2\xDA\xDC\x5\x34\x1B\x2\xDB\xDA\x3\x2\x2\x2\xDC\xDF\x3\x2\x2\x2\xDD"+
		"\xDB\x3\x2\x2\x2\xDD\xDE\x3\x2\x2\x2\xDE\x33\x3\x2\x2\x2\xDF\xDD\x3\x2"+
		"\x2\x2\xE0\xE1\x5> \x2\xE1\xE2\a\x14\x2\x2\xE2\x35\x3\x2\x2\x2\xE3\xE4"+
		"\t\x2\x2\x2\xE4\x37\x3\x2\x2\x2\xE5\xE6\x5:\x1E\x2\xE6\x39\x3\x2\x2\x2"+
		"\xE7\xE8\x5<\x1F\x2\xE8;\x3\x2\x2\x2\xE9\xEA\x5> \x2\xEA=\x3\x2\x2\x2"+
		"\xEB\xED\x5@!\x2\xEC\xEB\x3\x2\x2\x2\xED\xEE\x3\x2\x2\x2\xEE\xEC\x3\x2"+
		"\x2\x2\xEE\xEF\x3\x2\x2\x2\xEF?\x3\x2\x2\x2\xF0\xF1\a\x16\x2\x2\xF1\x41"+
		"\x3\x2\x2\x2\x1AHOR[_\x66jpw~\x88\x92\x99\x9F\xA2\xB2\xB5\xBB\xC1\xC6"+
		"\xCB\xCF\xDD\xEE";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace WebSequenceDiagramsModel.Syntax.InternalSyntax
