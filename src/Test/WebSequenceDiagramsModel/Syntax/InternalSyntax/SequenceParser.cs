//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.6.6
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Users\Balazs\source\repos\meta-cs\src\Test\WebSequenceDiagramsModel\Syntax\InternalSyntax\SequenceParser.g4 by ANTLR 4.6.6

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace WebSequenceDiagramsModel.Syntax.InternalSyntax {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.6.6")]
[System.CLSCompliant(false)]
public partial class SequenceParser : Parser {
	public const int
		KTitle=1, KNote=2, KDestroy=3, KAlt=4, KElse=5, KEnd=6, KOpt=7, KLoop=8, 
		KRef=9, LSingleLineComment=10, LCommentStart=11, TCreate=12, TSync=13, 
		TAsync=14, TReturn=15, LUtf8Bom=16, LWhiteSpace=17, LCrLf=18, LLineEnd=19, 
		LIdentifier=20, NoteWhiteSpace=21, NoteLinesWhiteSpace=22, KEndNote=23, 
		RefWhiteSpace=24, RefLinesWhiteSpace=25, KEndRef=26, RefEndWhiteSpace=27, 
		LineEndWhiteSpace=28, ArrowEndWhiteSpace=29, TColon=30, TMinus=31, ArrowEndR=32;
	public const int
		RULE_main = 0, RULE_interaction = 1, RULE_line = 2, RULE_declaration = 3, 
		RULE_title = 4, RULE_arrow = 5, RULE_destroy = 6, RULE_alt = 7, RULE_altFragment = 8, 
		RULE_elseFragment = 9, RULE_loop = 10, RULE_loopFragment = 11, RULE_opt = 12, 
		RULE_optFragment = 13, RULE_ref = 14, RULE_simpleRefFragment = 15, RULE_messageRefFragment = 16, 
		RULE_refInput = 17, RULE_refOutput = 18, RULE_fragmentBody = 19, RULE_end = 20, 
		RULE_note = 21, RULE_singleLineNote = 22, RULE_multiLineNote = 23, RULE_simpleBody = 24, 
		RULE_simpleLine = 25, RULE_arrowType = 26, RULE_lifeLineName = 27, RULE_name = 28, 
		RULE_identifier = 29, RULE_text = 30, RULE_identifierPart = 31;
	public static readonly string[] ruleNames = {
		"main", "interaction", "line", "declaration", "title", "arrow", "destroy", 
		"alt", "altFragment", "elseFragment", "loop", "loopFragment", "opt", "optFragment", 
		"ref", "simpleRefFragment", "messageRefFragment", "refInput", "refOutput", 
		"fragmentBody", "end", "note", "singleLineNote", "multiLineNote", "simpleBody", 
		"simpleLine", "arrowType", "lifeLineName", "name", "identifier", "text", 
		"identifierPart"
	};

	private static readonly string[] _LiteralNames = {
		null, "'title'", "'note'", "'destroy'", "'alt'", "'else'", "'end'", "'opt'", 
		"'loop'", "'ref'", null, null, null, "'->'", "'->>'", null, null, null, 
		null, null, null, null, null, "'end note'", null, null, "'end ref'", null, 
		null, null, "':'", null, "'r'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "KTitle", "KNote", "KDestroy", "KAlt", "KElse", "KEnd", "KOpt", 
		"KLoop", "KRef", "LSingleLineComment", "LCommentStart", "TCreate", "TSync", 
		"TAsync", "TReturn", "LUtf8Bom", "LWhiteSpace", "LCrLf", "LLineEnd", "LIdentifier", 
		"NoteWhiteSpace", "NoteLinesWhiteSpace", "KEndNote", "RefWhiteSpace", 
		"RefLinesWhiteSpace", "KEndRef", "RefEndWhiteSpace", "LineEndWhiteSpace", 
		"ArrowEndWhiteSpace", "TColon", "TMinus", "ArrowEndR"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[System.Obsolete("Use Vocabulary instead.")]
	public static readonly string[] tokenNames = GenerateTokenNames(DefaultVocabulary, _SymbolicNames.Length);

	private static string[] GenerateTokenNames(IVocabulary vocabulary, int length) {
		string[] tokenNames = new string[length];
		for (int i = 0; i < tokenNames.Length; i++) {
			tokenNames[i] = vocabulary.GetLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = vocabulary.GetSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}

		return tokenNames;
	}

	[System.Obsolete("Use IRecognizer.Vocabulary instead.")]
	public override string[] TokenNames
	{
		get
		{
			return tokenNames;
		}
	}

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "SequenceParser.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public SequenceParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class MainContext : ParserRuleContext {
		public InteractionContext interaction() {
			return GetRuleContext<InteractionContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(SequenceParser.Eof, 0); }
		public MainContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_main; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterMain(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitMain(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMain(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MainContext main() {
		MainContext _localctx = new MainContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_main);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 64; interaction();
			State = 65; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InteractionContext : ParserRuleContext {
		public LineContext[] line() {
			return GetRuleContexts<LineContext>();
		}
		public LineContext line(int i) {
			return GetRuleContext<LineContext>(i);
		}
		public InteractionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_interaction; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterInteraction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitInteraction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInteraction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InteractionContext interaction() {
		InteractionContext _localctx = new InteractionContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_interaction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 70;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KTitle) | (1L << KNote) | (1L << KDestroy) | (1L << KAlt) | (1L << KOpt) | (1L << KLoop) | (1L << KRef) | (1L << LCrLf) | (1L << LIdentifier))) != 0)) {
				{
				{
				State = 67; line();
				}
				}
				State = 72;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LineContext : ParserRuleContext {
		public ITerminalNode LCrLf() { return GetToken(SequenceParser.LCrLf, 0); }
		public DeclarationContext declaration() {
			return GetRuleContext<DeclarationContext>(0);
		}
		public LineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_line; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterLine(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitLine(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLine(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LineContext line() {
		LineContext _localctx = new LineContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_line);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 74;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KTitle) | (1L << KNote) | (1L << KDestroy) | (1L << KAlt) | (1L << KOpt) | (1L << KLoop) | (1L << KRef) | (1L << LIdentifier))) != 0)) {
				{
				State = 73; declaration();
				}
			}

			State = 76; Match(LCrLf);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationContext : ParserRuleContext {
		public TitleContext title() {
			return GetRuleContext<TitleContext>(0);
		}
		public DestroyContext destroy() {
			return GetRuleContext<DestroyContext>(0);
		}
		public ArrowContext arrow() {
			return GetRuleContext<ArrowContext>(0);
		}
		public AltContext alt() {
			return GetRuleContext<AltContext>(0);
		}
		public OptContext opt() {
			return GetRuleContext<OptContext>(0);
		}
		public LoopContext loop() {
			return GetRuleContext<LoopContext>(0);
		}
		public RefContext @ref() {
			return GetRuleContext<RefContext>(0);
		}
		public NoteContext note() {
			return GetRuleContext<NoteContext>(0);
		}
		public DeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitDeclaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationContext declaration() {
		DeclarationContext _localctx = new DeclarationContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_declaration);
		try {
			State = 86;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,2,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 78; title();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 79; destroy();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 80; arrow();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 81; alt();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 82; opt();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 83; loop();
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 84; @ref();
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 85; note();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TitleContext : ParserRuleContext {
		public ITerminalNode KTitle() { return GetToken(SequenceParser.KTitle, 0); }
		public TextContext text() {
			return GetRuleContext<TextContext>(0);
		}
		public TitleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_title; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterTitle(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitTitle(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTitle(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TitleContext title() {
		TitleContext _localctx = new TitleContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_title);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 88; Match(KTitle);
			State = 90;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 89; text();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArrowContext : ParserRuleContext {
		public LifeLineNameContext source;
		public ArrowTypeContext type;
		public LifeLineNameContext target;
		public ITerminalNode TColon() { return GetToken(SequenceParser.TColon, 0); }
		public LifeLineNameContext[] lifeLineName() {
			return GetRuleContexts<LifeLineNameContext>();
		}
		public LifeLineNameContext lifeLineName(int i) {
			return GetRuleContext<LifeLineNameContext>(i);
		}
		public ArrowTypeContext arrowType() {
			return GetRuleContext<ArrowTypeContext>(0);
		}
		public TextContext text() {
			return GetRuleContext<TextContext>(0);
		}
		public ArrowContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arrow; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterArrow(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitArrow(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArrow(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArrowContext arrow() {
		ArrowContext _localctx = new ArrowContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_arrow);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 92; _localctx.source = lifeLineName();
			State = 93; _localctx.type = arrowType();
			State = 94; _localctx.target = lifeLineName();
			State = 95; Match(TColon);
			State = 97;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 96; text();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DestroyContext : ParserRuleContext {
		public ITerminalNode KDestroy() { return GetToken(SequenceParser.KDestroy, 0); }
		public LifeLineNameContext lifeLineName() {
			return GetRuleContext<LifeLineNameContext>(0);
		}
		public DestroyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_destroy; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterDestroy(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitDestroy(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDestroy(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DestroyContext destroy() {
		DestroyContext _localctx = new DestroyContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_destroy);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 99; Match(KDestroy);
			State = 101;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 100; lifeLineName();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AltContext : ParserRuleContext {
		public AltFragmentContext altFragment() {
			return GetRuleContext<AltFragmentContext>(0);
		}
		public EndContext end() {
			return GetRuleContext<EndContext>(0);
		}
		public ElseFragmentContext[] elseFragment() {
			return GetRuleContexts<ElseFragmentContext>();
		}
		public ElseFragmentContext elseFragment(int i) {
			return GetRuleContext<ElseFragmentContext>(i);
		}
		public AltContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alt; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterAlt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitAlt(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AltContext alt() {
		AltContext _localctx = new AltContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_alt);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 103; altFragment();
			State = 107;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==KElse) {
				{
				{
				State = 104; elseFragment();
				}
				}
				State = 109;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 110; end();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AltFragmentContext : ParserRuleContext {
		public TextContext condition;
		public ITerminalNode KAlt() { return GetToken(SequenceParser.KAlt, 0); }
		public ITerminalNode LCrLf() { return GetToken(SequenceParser.LCrLf, 0); }
		public FragmentBodyContext fragmentBody() {
			return GetRuleContext<FragmentBodyContext>(0);
		}
		public TextContext text() {
			return GetRuleContext<TextContext>(0);
		}
		public AltFragmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_altFragment; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterAltFragment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitAltFragment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAltFragment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AltFragmentContext altFragment() {
		AltFragmentContext _localctx = new AltFragmentContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_altFragment);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 112; Match(KAlt);
			State = 114;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 113; _localctx.condition = text();
				}
			}

			State = 116; Match(LCrLf);
			State = 117; fragmentBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseFragmentContext : ParserRuleContext {
		public TextContext condition;
		public ITerminalNode KElse() { return GetToken(SequenceParser.KElse, 0); }
		public ITerminalNode LCrLf() { return GetToken(SequenceParser.LCrLf, 0); }
		public FragmentBodyContext fragmentBody() {
			return GetRuleContext<FragmentBodyContext>(0);
		}
		public TextContext text() {
			return GetRuleContext<TextContext>(0);
		}
		public ElseFragmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elseFragment; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterElseFragment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitElseFragment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElseFragment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseFragmentContext elseFragment() {
		ElseFragmentContext _localctx = new ElseFragmentContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_elseFragment);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 119; Match(KElse);
			State = 121;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 120; _localctx.condition = text();
				}
			}

			State = 123; Match(LCrLf);
			State = 124; fragmentBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoopContext : ParserRuleContext {
		public LoopFragmentContext loopFragment() {
			return GetRuleContext<LoopFragmentContext>(0);
		}
		public EndContext end() {
			return GetRuleContext<EndContext>(0);
		}
		public LoopContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loop; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterLoop(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitLoop(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLoop(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LoopContext loop() {
		LoopContext _localctx = new LoopContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_loop);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 126; loopFragment();
			State = 127; end();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoopFragmentContext : ParserRuleContext {
		public TextContext condition;
		public ITerminalNode KLoop() { return GetToken(SequenceParser.KLoop, 0); }
		public ITerminalNode LCrLf() { return GetToken(SequenceParser.LCrLf, 0); }
		public FragmentBodyContext fragmentBody() {
			return GetRuleContext<FragmentBodyContext>(0);
		}
		public TextContext text() {
			return GetRuleContext<TextContext>(0);
		}
		public LoopFragmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loopFragment; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterLoopFragment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitLoopFragment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLoopFragment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LoopFragmentContext loopFragment() {
		LoopFragmentContext _localctx = new LoopFragmentContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_loopFragment);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 129; Match(KLoop);
			State = 131;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 130; _localctx.condition = text();
				}
			}

			State = 133; Match(LCrLf);
			State = 134; fragmentBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OptContext : ParserRuleContext {
		public OptFragmentContext optFragment() {
			return GetRuleContext<OptFragmentContext>(0);
		}
		public EndContext end() {
			return GetRuleContext<EndContext>(0);
		}
		public OptContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_opt; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterOpt(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitOpt(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpt(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OptContext opt() {
		OptContext _localctx = new OptContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_opt);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 136; optFragment();
			State = 137; end();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OptFragmentContext : ParserRuleContext {
		public TextContext condition;
		public ITerminalNode KOpt() { return GetToken(SequenceParser.KOpt, 0); }
		public ITerminalNode LCrLf() { return GetToken(SequenceParser.LCrLf, 0); }
		public FragmentBodyContext fragmentBody() {
			return GetRuleContext<FragmentBodyContext>(0);
		}
		public TextContext text() {
			return GetRuleContext<TextContext>(0);
		}
		public OptFragmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_optFragment; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterOptFragment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitOptFragment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOptFragment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OptFragmentContext optFragment() {
		OptFragmentContext _localctx = new OptFragmentContext(_ctx, State);
		EnterRule(_localctx, 26, RULE_optFragment);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 139; Match(KOpt);
			State = 141;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 140; _localctx.condition = text();
				}
			}

			State = 143; Match(LCrLf);
			State = 144; fragmentBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RefContext : ParserRuleContext {
		public SimpleRefFragmentContext simpleRefFragment() {
			return GetRuleContext<SimpleRefFragmentContext>(0);
		}
		public MessageRefFragmentContext messageRefFragment() {
			return GetRuleContext<MessageRefFragmentContext>(0);
		}
		public RefContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ref; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterRef(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitRef(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRef(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RefContext @ref() {
		RefContext _localctx = new RefContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_ref);
		try {
			State = 148;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case KRef:
				EnterOuterAlt(_localctx, 1);
				{
				State = 146; simpleRefFragment();
				}
				break;
			case LIdentifier:
				EnterOuterAlt(_localctx, 2);
				{
				State = 147; messageRefFragment();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleRefFragmentContext : ParserRuleContext {
		public TextContext over;
		public TextContext refText;
		public ITerminalNode KRef() { return GetToken(SequenceParser.KRef, 0); }
		public ITerminalNode LCrLf() { return GetToken(SequenceParser.LCrLf, 0); }
		public SimpleBodyContext simpleBody() {
			return GetRuleContext<SimpleBodyContext>(0);
		}
		public ITerminalNode KEndRef() { return GetToken(SequenceParser.KEndRef, 0); }
		public ITerminalNode TColon() { return GetToken(SequenceParser.TColon, 0); }
		public TextContext[] text() {
			return GetRuleContexts<TextContext>();
		}
		public TextContext text(int i) {
			return GetRuleContext<TextContext>(i);
		}
		public SimpleRefFragmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleRefFragment; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterSimpleRefFragment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitSimpleRefFragment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleRefFragment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SimpleRefFragmentContext simpleRefFragment() {
		SimpleRefFragmentContext _localctx = new SimpleRefFragmentContext(_ctx, State);
		EnterRule(_localctx, 30, RULE_simpleRefFragment);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 150; Match(KRef);
			State = 154;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,12,_ctx) ) {
			case 1:
				{
				State = 151; _localctx.over = text();
				State = 152; Match(TColon);
				}
				break;
			}
			State = 157;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 156; _localctx.refText = text();
				}
			}

			State = 159; Match(LCrLf);
			State = 160; simpleBody();
			State = 161; Match(KEndRef);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MessageRefFragmentContext : ParserRuleContext {
		public RefInputContext refInput() {
			return GetRuleContext<RefInputContext>(0);
		}
		public SimpleBodyContext simpleBody() {
			return GetRuleContext<SimpleBodyContext>(0);
		}
		public RefOutputContext refOutput() {
			return GetRuleContext<RefOutputContext>(0);
		}
		public MessageRefFragmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_messageRefFragment; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterMessageRefFragment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitMessageRefFragment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMessageRefFragment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MessageRefFragmentContext messageRefFragment() {
		MessageRefFragmentContext _localctx = new MessageRefFragmentContext(_ctx, State);
		EnterRule(_localctx, 32, RULE_messageRefFragment);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 163; refInput();
			State = 164; simpleBody();
			State = 165; refOutput();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RefInputContext : ParserRuleContext {
		public LifeLineNameContext source;
		public ArrowTypeContext sourceType;
		public TextContext over;
		public TextContext message;
		public ITerminalNode KRef() { return GetToken(SequenceParser.KRef, 0); }
		public ITerminalNode LCrLf() { return GetToken(SequenceParser.LCrLf, 0); }
		public LifeLineNameContext lifeLineName() {
			return GetRuleContext<LifeLineNameContext>(0);
		}
		public ArrowTypeContext arrowType() {
			return GetRuleContext<ArrowTypeContext>(0);
		}
		public ITerminalNode TColon() { return GetToken(SequenceParser.TColon, 0); }
		public TextContext[] text() {
			return GetRuleContexts<TextContext>();
		}
		public TextContext text(int i) {
			return GetRuleContext<TextContext>(i);
		}
		public RefInputContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_refInput; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterRefInput(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitRefInput(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRefInput(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RefInputContext refInput() {
		RefInputContext _localctx = new RefInputContext(_ctx, State);
		EnterRule(_localctx, 34, RULE_refInput);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 167; _localctx.source = lifeLineName();
			State = 168; _localctx.sourceType = arrowType();
			State = 169; Match(KRef);
			State = 173;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,14,_ctx) ) {
			case 1:
				{
				State = 170; _localctx.over = text();
				State = 171; Match(TColon);
				}
				break;
			}
			State = 176;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 175; _localctx.message = text();
				}
			}

			State = 178; Match(LCrLf);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RefOutputContext : ParserRuleContext {
		public TextContext ignored;
		public ArrowTypeContext targetType;
		public LifeLineNameContext target;
		public TextContext message;
		public ITerminalNode KEndRef() { return GetToken(SequenceParser.KEndRef, 0); }
		public ITerminalNode TColon() { return GetToken(SequenceParser.TColon, 0); }
		public ArrowTypeContext arrowType() {
			return GetRuleContext<ArrowTypeContext>(0);
		}
		public LifeLineNameContext lifeLineName() {
			return GetRuleContext<LifeLineNameContext>(0);
		}
		public TextContext[] text() {
			return GetRuleContexts<TextContext>();
		}
		public TextContext text(int i) {
			return GetRuleContext<TextContext>(i);
		}
		public RefOutputContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_refOutput; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterRefOutput(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitRefOutput(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRefOutput(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RefOutputContext refOutput() {
		RefOutputContext _localctx = new RefOutputContext(_ctx, State);
		EnterRule(_localctx, 36, RULE_refOutput);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 180; Match(KEndRef);
			State = 182;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 181; _localctx.ignored = text();
				}
			}

			State = 184; _localctx.targetType = arrowType();
			State = 185; _localctx.target = lifeLineName();
			State = 186; Match(TColon);
			State = 188;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 187; _localctx.message = text();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FragmentBodyContext : ParserRuleContext {
		public LineContext[] line() {
			return GetRuleContexts<LineContext>();
		}
		public LineContext line(int i) {
			return GetRuleContext<LineContext>(i);
		}
		public FragmentBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fragmentBody; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterFragmentBody(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitFragmentBody(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFragmentBody(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FragmentBodyContext fragmentBody() {
		FragmentBodyContext _localctx = new FragmentBodyContext(_ctx, State);
		EnterRule(_localctx, 38, RULE_fragmentBody);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 193;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KTitle) | (1L << KNote) | (1L << KDestroy) | (1L << KAlt) | (1L << KOpt) | (1L << KLoop) | (1L << KRef) | (1L << LCrLf) | (1L << LIdentifier))) != 0)) {
				{
				{
				State = 190; line();
				}
				}
				State = 195;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EndContext : ParserRuleContext {
		public ITerminalNode KEnd() { return GetToken(SequenceParser.KEnd, 0); }
		public TextContext text() {
			return GetRuleContext<TextContext>(0);
		}
		public EndContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_end; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterEnd(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitEnd(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEnd(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EndContext end() {
		EndContext _localctx = new EndContext(_ctx, State);
		EnterRule(_localctx, 40, RULE_end);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 196; Match(KEnd);
			State = 198;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 197; text();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NoteContext : ParserRuleContext {
		public SingleLineNoteContext singleLineNote() {
			return GetRuleContext<SingleLineNoteContext>(0);
		}
		public MultiLineNoteContext multiLineNote() {
			return GetRuleContext<MultiLineNoteContext>(0);
		}
		public NoteContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_note; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterNote(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitNote(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNote(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NoteContext note() {
		NoteContext _localctx = new NoteContext(_ctx, State);
		EnterRule(_localctx, 42, RULE_note);
		try {
			State = 202;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,20,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 200; singleLineNote();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 201; multiLineNote();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SingleLineNoteContext : ParserRuleContext {
		public TextContext position;
		public TextContext noteText;
		public ITerminalNode KNote() { return GetToken(SequenceParser.KNote, 0); }
		public ITerminalNode TColon() { return GetToken(SequenceParser.TColon, 0); }
		public TextContext[] text() {
			return GetRuleContexts<TextContext>();
		}
		public TextContext text(int i) {
			return GetRuleContext<TextContext>(i);
		}
		public SingleLineNoteContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_singleLineNote; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterSingleLineNote(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitSingleLineNote(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSingleLineNote(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SingleLineNoteContext singleLineNote() {
		SingleLineNoteContext _localctx = new SingleLineNoteContext(_ctx, State);
		EnterRule(_localctx, 44, RULE_singleLineNote);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 204; Match(KNote);
			State = 205; _localctx.position = text();
			State = 206; Match(TColon);
			State = 207; _localctx.noteText = text();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultiLineNoteContext : ParserRuleContext {
		public ITerminalNode KNote() { return GetToken(SequenceParser.KNote, 0); }
		public SimpleBodyContext simpleBody() {
			return GetRuleContext<SimpleBodyContext>(0);
		}
		public ITerminalNode KEndNote() { return GetToken(SequenceParser.KEndNote, 0); }
		public MultiLineNoteContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiLineNote; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterMultiLineNote(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitMultiLineNote(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiLineNote(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MultiLineNoteContext multiLineNote() {
		MultiLineNoteContext _localctx = new MultiLineNoteContext(_ctx, State);
		EnterRule(_localctx, 46, RULE_multiLineNote);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 209; Match(KNote);
			State = 210; simpleBody();
			State = 211; Match(KEndNote);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleBodyContext : ParserRuleContext {
		public SimpleLineContext[] simpleLine() {
			return GetRuleContexts<SimpleLineContext>();
		}
		public SimpleLineContext simpleLine(int i) {
			return GetRuleContext<SimpleLineContext>(i);
		}
		public SimpleBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleBody; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterSimpleBody(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitSimpleBody(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleBody(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SimpleBodyContext simpleBody() {
		SimpleBodyContext _localctx = new SimpleBodyContext(_ctx, State);
		EnterRule(_localctx, 48, RULE_simpleBody);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 216;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==LIdentifier) {
				{
				{
				State = 213; simpleLine();
				}
				}
				State = 218;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SimpleLineContext : ParserRuleContext {
		public TextContext text() {
			return GetRuleContext<TextContext>(0);
		}
		public ITerminalNode LCrLf() { return GetToken(SequenceParser.LCrLf, 0); }
		public SimpleLineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simpleLine; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterSimpleLine(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitSimpleLine(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleLine(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SimpleLineContext simpleLine() {
		SimpleLineContext _localctx = new SimpleLineContext(_ctx, State);
		EnterRule(_localctx, 50, RULE_simpleLine);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 219; text();
			State = 220; Match(LCrLf);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArrowTypeContext : ParserRuleContext {
		public ITerminalNode TSync() { return GetToken(SequenceParser.TSync, 0); }
		public ITerminalNode TAsync() { return GetToken(SequenceParser.TAsync, 0); }
		public ITerminalNode TReturn() { return GetToken(SequenceParser.TReturn, 0); }
		public ITerminalNode TCreate() { return GetToken(SequenceParser.TCreate, 0); }
		public ArrowTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arrowType; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterArrowType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitArrowType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArrowType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArrowTypeContext arrowType() {
		ArrowTypeContext _localctx = new ArrowTypeContext(_ctx, State);
		EnterRule(_localctx, 52, RULE_arrowType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 222;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << TCreate) | (1L << TSync) | (1L << TAsync) | (1L << TReturn))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LifeLineNameContext : ParserRuleContext {
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public LifeLineNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lifeLineName; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterLifeLineName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitLifeLineName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLifeLineName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LifeLineNameContext lifeLineName() {
		LifeLineNameContext _localctx = new LifeLineNameContext(_ctx, State);
		EnterRule(_localctx, 54, RULE_lifeLineName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 224; name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public NameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NameContext name() {
		NameContext _localctx = new NameContext(_ctx, State);
		EnterRule(_localctx, 56, RULE_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 226; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierContext : ParserRuleContext {
		public TextContext text() {
			return GetRuleContext<TextContext>(0);
		}
		public IdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierContext identifier() {
		IdentifierContext _localctx = new IdentifierContext(_ctx, State);
		EnterRule(_localctx, 58, RULE_identifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 228; text();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TextContext : ParserRuleContext {
		public IdentifierPartContext[] identifierPart() {
			return GetRuleContexts<IdentifierPartContext>();
		}
		public IdentifierPartContext identifierPart(int i) {
			return GetRuleContext<IdentifierPartContext>(i);
		}
		public TextContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_text; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterText(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitText(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitText(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TextContext text() {
		TextContext _localctx = new TextContext(_ctx, State);
		EnterRule(_localctx, 60, RULE_text);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 231;
			_errHandler.Sync(this);
			_la = _input.La(1);
			do {
				{
				{
				State = 230; identifierPart();
				}
				}
				State = 233;
				_errHandler.Sync(this);
				_la = _input.La(1);
			} while ( _la==LIdentifier );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierPartContext : ParserRuleContext {
		public ITerminalNode LIdentifier() { return GetToken(SequenceParser.LIdentifier, 0); }
		public IdentifierPartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierPart; } }
		public override void EnterRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.EnterIdentifierPart(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			ISequenceParserListener typedListener = listener as ISequenceParserListener;
			if (typedListener != null) typedListener.ExitIdentifierPart(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ISequenceParserVisitor<TResult> typedVisitor = visitor as ISequenceParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifierPart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierPartContext identifierPart() {
		IdentifierPartContext _localctx = new IdentifierPartContext(_ctx, State);
		EnterRule(_localctx, 62, RULE_identifierPart);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 235; Match(LIdentifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3\"\xF0\x4\x2\t\x2"+
		"\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t\t"+
		"\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10\t"+
		"\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15"+
		"\x4\x16\t\x16\x4\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x4\x1B"+
		"\t\x1B\x4\x1C\t\x1C\x4\x1D\t\x1D\x4\x1E\t\x1E\x4\x1F\t\x1F\x4 \t \x4!"+
		"\t!\x3\x2\x3\x2\x3\x2\x3\x3\a\x3G\n\x3\f\x3\xE\x3J\v\x3\x3\x4\x5\x4M\n"+
		"\x4\x3\x4\x3\x4\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x5\x5"+
		"Y\n\x5\x3\x6\x3\x6\x5\x6]\n\x6\x3\a\x3\a\x3\a\x3\a\x3\a\x5\a\x64\n\a\x3"+
		"\b\x3\b\x5\bh\n\b\x3\t\x3\t\a\tl\n\t\f\t\xE\to\v\t\x3\t\x3\t\x3\n\x3\n"+
		"\x5\nu\n\n\x3\n\x3\n\x3\n\x3\v\x3\v\x5\v|\n\v\x3\v\x3\v\x3\v\x3\f\x3\f"+
		"\x3\f\x3\r\x3\r\x5\r\x86\n\r\x3\r\x3\r\x3\r\x3\xE\x3\xE\x3\xE\x3\xF\x3"+
		"\xF\x5\xF\x90\n\xF\x3\xF\x3\xF\x3\xF\x3\x10\x3\x10\x5\x10\x97\n\x10\x3"+
		"\x11\x3\x11\x3\x11\x3\x11\x5\x11\x9D\n\x11\x3\x11\x5\x11\xA0\n\x11\x3"+
		"\x11\x3\x11\x3\x11\x3\x11\x3\x12\x3\x12\x3\x12\x3\x12\x3\x13\x3\x13\x3"+
		"\x13\x3\x13\x3\x13\x3\x13\x5\x13\xB0\n\x13\x3\x13\x5\x13\xB3\n\x13\x3"+
		"\x13\x3\x13\x3\x14\x3\x14\x5\x14\xB9\n\x14\x3\x14\x3\x14\x3\x14\x3\x14"+
		"\x5\x14\xBF\n\x14\x3\x15\a\x15\xC2\n\x15\f\x15\xE\x15\xC5\v\x15\x3\x16"+
		"\x3\x16\x5\x16\xC9\n\x16\x3\x17\x3\x17\x5\x17\xCD\n\x17\x3\x18\x3\x18"+
		"\x3\x18\x3\x18\x3\x18\x3\x19\x3\x19\x3\x19\x3\x19\x3\x1A\a\x1A\xD9\n\x1A"+
		"\f\x1A\xE\x1A\xDC\v\x1A\x3\x1B\x3\x1B\x3\x1B\x3\x1C\x3\x1C\x3\x1D\x3\x1D"+
		"\x3\x1E\x3\x1E\x3\x1F\x3\x1F\x3 \x6 \xEA\n \r \xE \xEB\x3!\x3!\x3!\x2"+
		"\x2\x2\"\x2\x2\x4\x2\x6\x2\b\x2\n\x2\f\x2\xE\x2\x10\x2\x12\x2\x14\x2\x16"+
		"\x2\x18\x2\x1A\x2\x1C\x2\x1E\x2 \x2\"\x2$\x2&\x2(\x2*\x2,\x2.\x2\x30\x2"+
		"\x32\x2\x34\x2\x36\x2\x38\x2:\x2<\x2>\x2@\x2\x2\x3\x3\x2\xE\x11\xEC\x2"+
		"\x42\x3\x2\x2\x2\x4H\x3\x2\x2\x2\x6L\x3\x2\x2\x2\bX\x3\x2\x2\x2\nZ\x3"+
		"\x2\x2\x2\f^\x3\x2\x2\x2\xE\x65\x3\x2\x2\x2\x10i\x3\x2\x2\x2\x12r\x3\x2"+
		"\x2\x2\x14y\x3\x2\x2\x2\x16\x80\x3\x2\x2\x2\x18\x83\x3\x2\x2\x2\x1A\x8A"+
		"\x3\x2\x2\x2\x1C\x8D\x3\x2\x2\x2\x1E\x96\x3\x2\x2\x2 \x98\x3\x2\x2\x2"+
		"\"\xA5\x3\x2\x2\x2$\xA9\x3\x2\x2\x2&\xB6\x3\x2\x2\x2(\xC3\x3\x2\x2\x2"+
		"*\xC6\x3\x2\x2\x2,\xCC\x3\x2\x2\x2.\xCE\x3\x2\x2\x2\x30\xD3\x3\x2\x2\x2"+
		"\x32\xDA\x3\x2\x2\x2\x34\xDD\x3\x2\x2\x2\x36\xE0\x3\x2\x2\x2\x38\xE2\x3"+
		"\x2\x2\x2:\xE4\x3\x2\x2\x2<\xE6\x3\x2\x2\x2>\xE9\x3\x2\x2\x2@\xED\x3\x2"+
		"\x2\x2\x42\x43\x5\x4\x3\x2\x43\x44\a\x2\x2\x3\x44\x3\x3\x2\x2\x2\x45G"+
		"\x5\x6\x4\x2\x46\x45\x3\x2\x2\x2GJ\x3\x2\x2\x2H\x46\x3\x2\x2\x2HI\x3\x2"+
		"\x2\x2I\x5\x3\x2\x2\x2JH\x3\x2\x2\x2KM\x5\b\x5\x2LK\x3\x2\x2\x2LM\x3\x2"+
		"\x2\x2MN\x3\x2\x2\x2NO\a\x14\x2\x2O\a\x3\x2\x2\x2PY\x5\n\x6\x2QY\x5\xE"+
		"\b\x2RY\x5\f\a\x2SY\x5\x10\t\x2TY\x5\x1A\xE\x2UY\x5\x16\f\x2VY\x5\x1E"+
		"\x10\x2WY\x5,\x17\x2XP\x3\x2\x2\x2XQ\x3\x2\x2\x2XR\x3\x2\x2\x2XS\x3\x2"+
		"\x2\x2XT\x3\x2\x2\x2XU\x3\x2\x2\x2XV\x3\x2\x2\x2XW\x3\x2\x2\x2Y\t\x3\x2"+
		"\x2\x2Z\\\a\x3\x2\x2[]\x5> \x2\\[\x3\x2\x2\x2\\]\x3\x2\x2\x2]\v\x3\x2"+
		"\x2\x2^_\x5\x38\x1D\x2_`\x5\x36\x1C\x2`\x61\x5\x38\x1D\x2\x61\x63\a \x2"+
		"\x2\x62\x64\x5> \x2\x63\x62\x3\x2\x2\x2\x63\x64\x3\x2\x2\x2\x64\r\x3\x2"+
		"\x2\x2\x65g\a\x5\x2\x2\x66h\x5\x38\x1D\x2g\x66\x3\x2\x2\x2gh\x3\x2\x2"+
		"\x2h\xF\x3\x2\x2\x2im\x5\x12\n\x2jl\x5\x14\v\x2kj\x3\x2\x2\x2lo\x3\x2"+
		"\x2\x2mk\x3\x2\x2\x2mn\x3\x2\x2\x2np\x3\x2\x2\x2om\x3\x2\x2\x2pq\x5*\x16"+
		"\x2q\x11\x3\x2\x2\x2rt\a\x6\x2\x2su\x5> \x2ts\x3\x2\x2\x2tu\x3\x2\x2\x2"+
		"uv\x3\x2\x2\x2vw\a\x14\x2\x2wx\x5(\x15\x2x\x13\x3\x2\x2\x2y{\a\a\x2\x2"+
		"z|\x5> \x2{z\x3\x2\x2\x2{|\x3\x2\x2\x2|}\x3\x2\x2\x2}~\a\x14\x2\x2~\x7F"+
		"\x5(\x15\x2\x7F\x15\x3\x2\x2\x2\x80\x81\x5\x18\r\x2\x81\x82\x5*\x16\x2"+
		"\x82\x17\x3\x2\x2\x2\x83\x85\a\n\x2\x2\x84\x86\x5> \x2\x85\x84\x3\x2\x2"+
		"\x2\x85\x86\x3\x2\x2\x2\x86\x87\x3\x2\x2\x2\x87\x88\a\x14\x2\x2\x88\x89"+
		"\x5(\x15\x2\x89\x19\x3\x2\x2\x2\x8A\x8B\x5\x1C\xF\x2\x8B\x8C\x5*\x16\x2"+
		"\x8C\x1B\x3\x2\x2\x2\x8D\x8F\a\t\x2\x2\x8E\x90\x5> \x2\x8F\x8E\x3\x2\x2"+
		"\x2\x8F\x90\x3\x2\x2\x2\x90\x91\x3\x2\x2\x2\x91\x92\a\x14\x2\x2\x92\x93"+
		"\x5(\x15\x2\x93\x1D\x3\x2\x2\x2\x94\x97\x5 \x11\x2\x95\x97\x5\"\x12\x2"+
		"\x96\x94\x3\x2\x2\x2\x96\x95\x3\x2\x2\x2\x97\x1F\x3\x2\x2\x2\x98\x9C\a"+
		"\v\x2\x2\x99\x9A\x5> \x2\x9A\x9B\a \x2\x2\x9B\x9D\x3\x2\x2\x2\x9C\x99"+
		"\x3\x2\x2\x2\x9C\x9D\x3\x2\x2\x2\x9D\x9F\x3\x2\x2\x2\x9E\xA0\x5> \x2\x9F"+
		"\x9E\x3\x2\x2\x2\x9F\xA0\x3\x2\x2\x2\xA0\xA1\x3\x2\x2\x2\xA1\xA2\a\x14"+
		"\x2\x2\xA2\xA3\x5\x32\x1A\x2\xA3\xA4\a\x1C\x2\x2\xA4!\x3\x2\x2\x2\xA5"+
		"\xA6\x5$\x13\x2\xA6\xA7\x5\x32\x1A\x2\xA7\xA8\x5&\x14\x2\xA8#\x3\x2\x2"+
		"\x2\xA9\xAA\x5\x38\x1D\x2\xAA\xAB\x5\x36\x1C\x2\xAB\xAF\a\v\x2\x2\xAC"+
		"\xAD\x5> \x2\xAD\xAE\a \x2\x2\xAE\xB0\x3\x2\x2\x2\xAF\xAC\x3\x2\x2\x2"+
		"\xAF\xB0\x3\x2\x2\x2\xB0\xB2\x3\x2\x2\x2\xB1\xB3\x5> \x2\xB2\xB1\x3\x2"+
		"\x2\x2\xB2\xB3\x3\x2\x2\x2\xB3\xB4\x3\x2\x2\x2\xB4\xB5\a\x14\x2\x2\xB5"+
		"%\x3\x2\x2\x2\xB6\xB8\a\x1C\x2\x2\xB7\xB9\x5> \x2\xB8\xB7\x3\x2\x2\x2"+
		"\xB8\xB9\x3\x2\x2\x2\xB9\xBA\x3\x2\x2\x2\xBA\xBB\x5\x36\x1C\x2\xBB\xBC"+
		"\x5\x38\x1D\x2\xBC\xBE\a \x2\x2\xBD\xBF\x5> \x2\xBE\xBD\x3\x2\x2\x2\xBE"+
		"\xBF\x3\x2\x2\x2\xBF\'\x3\x2\x2\x2\xC0\xC2\x5\x6\x4\x2\xC1\xC0\x3\x2\x2"+
		"\x2\xC2\xC5\x3\x2\x2\x2\xC3\xC1\x3\x2\x2\x2\xC3\xC4\x3\x2\x2\x2\xC4)\x3"+
		"\x2\x2\x2\xC5\xC3\x3\x2\x2\x2\xC6\xC8\a\b\x2\x2\xC7\xC9\x5> \x2\xC8\xC7"+
		"\x3\x2\x2\x2\xC8\xC9\x3\x2\x2\x2\xC9+\x3\x2\x2\x2\xCA\xCD\x5.\x18\x2\xCB"+
		"\xCD\x5\x30\x19\x2\xCC\xCA\x3\x2\x2\x2\xCC\xCB\x3\x2\x2\x2\xCD-\x3\x2"+
		"\x2\x2\xCE\xCF\a\x4\x2\x2\xCF\xD0\x5> \x2\xD0\xD1\a \x2\x2\xD1\xD2\x5"+
		"> \x2\xD2/\x3\x2\x2\x2\xD3\xD4\a\x4\x2\x2\xD4\xD5\x5\x32\x1A\x2\xD5\xD6"+
		"\a\x19\x2\x2\xD6\x31\x3\x2\x2\x2\xD7\xD9\x5\x34\x1B\x2\xD8\xD7\x3\x2\x2"+
		"\x2\xD9\xDC\x3\x2\x2\x2\xDA\xD8\x3\x2\x2\x2\xDA\xDB\x3\x2\x2\x2\xDB\x33"+
		"\x3\x2\x2\x2\xDC\xDA\x3\x2\x2\x2\xDD\xDE\x5> \x2\xDE\xDF\a\x14\x2\x2\xDF"+
		"\x35\x3\x2\x2\x2\xE0\xE1\t\x2\x2\x2\xE1\x37\x3\x2\x2\x2\xE2\xE3\x5:\x1E"+
		"\x2\xE3\x39\x3\x2\x2\x2\xE4\xE5\x5<\x1F\x2\xE5;\x3\x2\x2\x2\xE6\xE7\x5"+
		"> \x2\xE7=\x3\x2\x2\x2\xE8\xEA\x5@!\x2\xE9\xE8\x3\x2\x2\x2\xEA\xEB\x3"+
		"\x2\x2\x2\xEB\xE9\x3\x2\x2\x2\xEB\xEC\x3\x2\x2\x2\xEC?\x3\x2\x2\x2\xED"+
		"\xEE\a\x16\x2\x2\xEE\x41\x3\x2\x2\x2\x19HLX\\\x63gmt{\x85\x8F\x96\x9C"+
		"\x9F\xAF\xB2\xB8\xBE\xC3\xC8\xCC\xDA\xEB";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace WebSequenceDiagramsModel.Syntax.InternalSyntax
