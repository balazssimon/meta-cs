//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.6.6
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Users\Balazs\source\repos\meta-cs\src\Test\MetaDslx.CodeAnalysis.Languages.Test\Languages\PilV2\Syntax\InternalSyntax\PilParser.g4 by ANTLR 4.6.6

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace PilV2.Syntax.InternalSyntax {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.6.6")]
[System.CLSCompliant(false)]
public partial class PilParser : global::MetaDslx.Languages.Antlr4Roslyn.Syntax.InternalSyntax.IncrementalParser {
    private PilSyntaxParser SyntaxParser => (PilSyntaxParser)this.IncrementalAntlr4Parser;
	public const int
		KTypeDef=1, KEnum=2, KFunction=3, KEndFunction=4, KResult=5, KFork=6, 
		KEndFork=7, KCase=8, KElse=9, KIf=10, KEndIf=11, KQuery=12, KEndQuery=13, 
		KPulse=14, KStatic=15, KObject=16, KEndObject=17, KTrigger=18, KInput=19, 
		KOnAccepted=20, KOnRefused=21, KOnCancel=22, KAssert=23, KRequest=24, 
		KAccept=25, KRefuse=26, KCancel=27, KVar=28, KParam=29, KUndo=30, KTrue=31, 
		KFalse=32, KInt=33, KBool=34, KString=35, KObjectType=36, KIn=37, KNull=38, 
		TSemicolon=39, TColon=40, TDot=41, TComma=42, TAssign=43, TOpenParen=44, 
		TCloseParen=45, TOpenBracket=46, TCloseBracket=47, TOpenBrace=48, TCloseBrace=49, 
		TLessThan=50, TGreaterThan=51, TQuestion=52, TQuestionQuestion=53, TAmpersand=54, 
		THat=55, TBar=56, TAndAlso=57, TOrElse=58, TPlusPlus=59, TMinusMinus=60, 
		TPlus=61, TMinus=62, TTilde=63, TExclamation=64, TSlash=65, TAsterisk=66, 
		TPercent=67, TLessThanOrEqual=68, TGreaterThanOrEqual=69, TEqual=70, TNotEqual=71, 
		TAsteriskAssign=72, TSlashAssign=73, TPercentAssign=74, TPlusAssign=75, 
		TMinusAssign=76, TLeftShiftAssign=77, TRightShiftAssign=78, TAmpersandAssign=79, 
		THatAssign=80, TBarAssign=81, LIdentifier=82, LInteger=83, LDecimal=84, 
		LScientific=85, LString=86, LUtf8Bom=87, LWhiteSpace=88, LCrLf=89, LLineEnd=90, 
		LSingleLineComment=91, LMultiLineComment=92;
	public const int
		RULE_main = 0, RULE_declaration = 1, RULE_typeDefDeclaration = 2, RULE_externalParameterDeclaration = 3, 
		RULE_enumDeclaration = 4, RULE_enumLiterals = 5, RULE_enumLiteral = 6, 
		RULE_objectDeclaration = 7, RULE_objectHeader = 8, RULE_ports = 9, RULE_port = 10, 
		RULE_objectExternalParameters = 11, RULE_objectFields = 12, RULE_objectFunctions = 13, 
		RULE_functionDeclaration = 14, RULE_functionHeader = 15, RULE_functionParams = 16, 
		RULE_param = 17, RULE_queryDeclaration = 18, RULE_queryHeader = 19, RULE_queryRequestParams = 20, 
		RULE_queryAcceptParams = 21, RULE_queryRefuseParams = 22, RULE_queryCancelParams = 23, 
		RULE_queryExternalParameters = 24, RULE_queryField = 25, RULE_queryFunction = 26, 
		RULE_queryObject = 27, RULE_queryObjectField = 28, RULE_queryObjectFunction = 29, 
		RULE_queryObjectEvent = 30, RULE_input = 31, RULE_inputPortList = 32, 
		RULE_inputPort = 33, RULE_trigger = 34, RULE_triggerVarList = 35, RULE_triggerVar = 36, 
		RULE_statements = 37, RULE_statement = 38, RULE_forkStatement = 39, RULE_caseBranch = 40, 
		RULE_elseBranch = 41, RULE_ifStatement = 42, RULE_ifBranch = 43, RULE_elseIfBranch = 44, 
		RULE_requestStatement = 45, RULE_callRequest = 46, RULE_requestArguments = 47, 
		RULE_responseStatement = 48, RULE_cancelStatement = 49, RULE_assertion = 50, 
		RULE_responseStatementKind = 51, RULE_cancelStatementKind = 52, RULE_forkRequestStatement = 53, 
		RULE_forkRequestVariable = 54, RULE_forkRequestIdentifier = 55, RULE_acceptBranch = 56, 
		RULE_refuseBranch = 57, RULE_cancelBranch = 58, RULE_variableDeclarationStatement = 59, 
		RULE_variableDeclaration = 60, RULE_assignmentStatement = 61, RULE_leftSide = 62, 
		RULE_expressionList = 63, RULE_expression = 64, RULE_arithmeticExpression = 65, 
		RULE_opMulDiv = 66, RULE_opAddSub = 67, RULE_arithmeticExpressionTerminator = 68, 
		RULE_opMinus = 69, RULE_conditionalExpression = 70, RULE_andAlsoOp = 71, 
		RULE_orElseOp = 72, RULE_opExcl = 73, RULE_conditionalExpressionTerminator = 74, 
		RULE_comparisonExpression = 75, RULE_comparisonOperator = 76, RULE_elementOfExpression = 77, 
		RULE_elementOfValueList = 78, RULE_elementOfValue = 79, RULE_terminalExpression = 80, 
		RULE_functionCallExpression = 81, RULE_variableReference = 82, RULE_variableReferenceIdentifier = 83, 
		RULE_comment = 84, RULE_literal = 85, RULE_typeReference = 86, RULE_builtInType = 87, 
		RULE_qualifierList = 88, RULE_qualifier = 89, RULE_name = 90, RULE_identifierList = 91, 
		RULE_identifier = 92, RULE_resultIdentifier = 93;
	public static readonly string[] ruleNames = {
		"main", "declaration", "typeDefDeclaration", "externalParameterDeclaration", 
		"enumDeclaration", "enumLiterals", "enumLiteral", "objectDeclaration", 
		"objectHeader", "ports", "port", "objectExternalParameters", "objectFields", 
		"objectFunctions", "functionDeclaration", "functionHeader", "functionParams", 
		"param", "queryDeclaration", "queryHeader", "queryRequestParams", "queryAcceptParams", 
		"queryRefuseParams", "queryCancelParams", "queryExternalParameters", "queryField", 
		"queryFunction", "queryObject", "queryObjectField", "queryObjectFunction", 
		"queryObjectEvent", "input", "inputPortList", "inputPort", "trigger", 
		"triggerVarList", "triggerVar", "statements", "statement", "forkStatement", 
		"caseBranch", "elseBranch", "ifStatement", "ifBranch", "elseIfBranch", 
		"requestStatement", "callRequest", "requestArguments", "responseStatement", 
		"cancelStatement", "assertion", "responseStatementKind", "cancelStatementKind", 
		"forkRequestStatement", "forkRequestVariable", "forkRequestIdentifier", 
		"acceptBranch", "refuseBranch", "cancelBranch", "variableDeclarationStatement", 
		"variableDeclaration", "assignmentStatement", "leftSide", "expressionList", 
		"expression", "arithmeticExpression", "opMulDiv", "opAddSub", "arithmeticExpressionTerminator", 
		"opMinus", "conditionalExpression", "andAlsoOp", "orElseOp", "opExcl", 
		"conditionalExpressionTerminator", "comparisonExpression", "comparisonOperator", 
		"elementOfExpression", "elementOfValueList", "elementOfValue", "terminalExpression", 
		"functionCallExpression", "variableReference", "variableReferenceIdentifier", 
		"comment", "literal", "typeReference", "builtInType", "qualifierList", 
		"qualifier", "name", "identifierList", "identifier", "resultIdentifier"
	};

	private static readonly string[] _LiteralNames = {
		null, "'TYPE'", "'ENUM'", "'FUNCTION'", "'EFUNCTION'", "'RESULT'", "'FORK'", 
		"'EFORK'", "'CASE'", "'ELSE'", "'IF'", "'EIF'", "'QUERY'", "'EQUERY'", 
		"'PULSE'", "'STATIC'", "'OBJECT'", "'EOBJECT'", "'TRIGGER'", "'INPUT'", 
		"'ON_ACCEPTED'", "'ON_REFUSED'", "'ON_CANCELLED'", "'ASSERT'", "'REQ'", 
		"'ACCEPT'", "'REFUSE'", "'CANCEL'", "'VAR'", "'PARAM'", "'UNDO'", "'TRUE'", 
		"'FALSE'", "'int'", "'bool'", "'string'", "'object'", "'in'", "'NULL'", 
		"';'", "':'", "'.'", "','", "':='", "'('", "')'", "'['", "']'", "'{'", 
		"'}'", "'<'", "'>'", "'?'", "'??'", "'&'", "'^'", "'|'", "'&&'", "'||'", 
		"'++'", "'--'", "'+'", "'-'", "'~'", "'!'", "'/'", "'*'", "'%'", "'<='", 
		"'>='", "'='", "'!='", "'*='", "'/='", "'%='", "'+='", "'-='", "'<<='", 
		"'>>='", "'&='", "'^='", "'|='"
	};
	private static readonly string[] _SymbolicNames = {
		null, "KTypeDef", "KEnum", "KFunction", "KEndFunction", "KResult", "KFork", 
		"KEndFork", "KCase", "KElse", "KIf", "KEndIf", "KQuery", "KEndQuery", 
		"KPulse", "KStatic", "KObject", "KEndObject", "KTrigger", "KInput", "KOnAccepted", 
		"KOnRefused", "KOnCancel", "KAssert", "KRequest", "KAccept", "KRefuse", 
		"KCancel", "KVar", "KParam", "KUndo", "KTrue", "KFalse", "KInt", "KBool", 
		"KString", "KObjectType", "KIn", "KNull", "TSemicolon", "TColon", "TDot", 
		"TComma", "TAssign", "TOpenParen", "TCloseParen", "TOpenBracket", "TCloseBracket", 
		"TOpenBrace", "TCloseBrace", "TLessThan", "TGreaterThan", "TQuestion", 
		"TQuestionQuestion", "TAmpersand", "THat", "TBar", "TAndAlso", "TOrElse", 
		"TPlusPlus", "TMinusMinus", "TPlus", "TMinus", "TTilde", "TExclamation", 
		"TSlash", "TAsterisk", "TPercent", "TLessThanOrEqual", "TGreaterThanOrEqual", 
		"TEqual", "TNotEqual", "TAsteriskAssign", "TSlashAssign", "TPercentAssign", 
		"TPlusAssign", "TMinusAssign", "TLeftShiftAssign", "TRightShiftAssign", 
		"TAmpersandAssign", "THatAssign", "TBarAssign", "LIdentifier", "LInteger", 
		"LDecimal", "LScientific", "LString", "LUtf8Bom", "LWhiteSpace", "LCrLf", 
		"LLineEnd", "LSingleLineComment", "LMultiLineComment"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[System.Obsolete("Use Vocabulary instead.")]
	public static readonly string[] tokenNames = GenerateTokenNames(DefaultVocabulary, _SymbolicNames.Length);

	private static string[] GenerateTokenNames(IVocabulary vocabulary, int length) {
		string[] tokenNames = new string[length];
		for (int i = 0; i < tokenNames.Length; i++) {
			tokenNames[i] = vocabulary.GetLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = vocabulary.GetSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}

		return tokenNames;
	}

	[System.Obsolete("Use IRecognizer.Vocabulary instead.")]
	public override string[] TokenNames
	{
		get
		{
			return tokenNames;
		}
	}

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "PilParser.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public PilParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class MainContext : ParserRuleContext {
		public ITerminalNode Eof() { return GetToken(PilParser.Eof, 0); }
		public DeclarationContext[] declaration() {
			return GetRuleContexts<DeclarationContext>();
		}
		public DeclarationContext declaration(int i) {
			return GetRuleContext<DeclarationContext>(i);
		}
		public MainContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_main; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterMain(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitMain(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMain(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MainContext main() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseMain() : _DoParseMain();
	}

	internal MainContext _DoParseMain() {
		MainContext _localctx = new MainContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_main);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 191;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KTypeDef) | (1L << KEnum) | (1L << KFunction) | (1L << KQuery) | (1L << KObject) | (1L << KParam))) != 0)) {
				{
				{
				State = 188; declaration();
				}
				}
				State = 193;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 194; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationContext : ParserRuleContext {
		public TypeDefDeclarationContext typeDefDeclaration() {
			return GetRuleContext<TypeDefDeclarationContext>(0);
		}
		public ExternalParameterDeclarationContext externalParameterDeclaration() {
			return GetRuleContext<ExternalParameterDeclarationContext>(0);
		}
		public EnumDeclarationContext enumDeclaration() {
			return GetRuleContext<EnumDeclarationContext>(0);
		}
		public ObjectDeclarationContext objectDeclaration() {
			return GetRuleContext<ObjectDeclarationContext>(0);
		}
		public FunctionDeclarationContext functionDeclaration() {
			return GetRuleContext<FunctionDeclarationContext>(0);
		}
		public QueryDeclarationContext queryDeclaration() {
			return GetRuleContext<QueryDeclarationContext>(0);
		}
		public DeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitDeclaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationContext declaration() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseDeclaration() : _DoParseDeclaration();
	}

	internal DeclarationContext _DoParseDeclaration() {
		DeclarationContext _localctx = new DeclarationContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_declaration);
		try {
			State = 202;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case KTypeDef:
				EnterOuterAlt(_localctx, 1);
				{
				State = 196; typeDefDeclaration();
				}
				break;
			case KParam:
				EnterOuterAlt(_localctx, 2);
				{
				State = 197; externalParameterDeclaration();
				}
				break;
			case KEnum:
				EnterOuterAlt(_localctx, 3);
				{
				State = 198; enumDeclaration();
				}
				break;
			case KObject:
				EnterOuterAlt(_localctx, 4);
				{
				State = 199; objectDeclaration();
				}
				break;
			case KFunction:
				EnterOuterAlt(_localctx, 5);
				{
				State = 200; functionDeclaration();
				}
				break;
			case KQuery:
				EnterOuterAlt(_localctx, 6);
				{
				State = 201; queryDeclaration();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeDefDeclarationContext : ParserRuleContext {
		public ITerminalNode KTypeDef() { return GetToken(PilParser.KTypeDef, 0); }
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public ITerminalNode TColon() { return GetToken(PilParser.TColon, 0); }
		public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		public ITerminalNode TSemicolon() { return GetToken(PilParser.TSemicolon, 0); }
		public TypeDefDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeDefDeclaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterTypeDefDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitTypeDefDeclaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeDefDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeDefDeclarationContext typeDefDeclaration() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseTypeDefDeclaration() : _DoParseTypeDefDeclaration();
	}

	internal TypeDefDeclarationContext _DoParseTypeDefDeclaration() {
		TypeDefDeclarationContext _localctx = new TypeDefDeclarationContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_typeDefDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 204; Match(KTypeDef);
			State = 205; name();
			State = 206; Match(TColon);
			State = 207; typeReference();
			State = 208; Match(TSemicolon);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExternalParameterDeclarationContext : ParserRuleContext {
		public ITerminalNode KParam() { return GetToken(PilParser.KParam, 0); }
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public ITerminalNode TColon() { return GetToken(PilParser.TColon, 0); }
		public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		public ITerminalNode TSemicolon() { return GetToken(PilParser.TSemicolon, 0); }
		public ITerminalNode TAssign() { return GetToken(PilParser.TAssign, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ExternalParameterDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_externalParameterDeclaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterExternalParameterDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitExternalParameterDeclaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExternalParameterDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExternalParameterDeclarationContext externalParameterDeclaration() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseExternalParameterDeclaration() : _DoParseExternalParameterDeclaration();
	}

	internal ExternalParameterDeclarationContext _DoParseExternalParameterDeclaration() {
		ExternalParameterDeclarationContext _localctx = new ExternalParameterDeclarationContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_externalParameterDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 210; Match(KParam);
			State = 211; name();
			State = 212; Match(TColon);
			State = 213; typeReference();
			State = 216;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==TAssign) {
				{
				State = 214; Match(TAssign);
				State = 215; expression();
				}
			}

			State = 218; Match(TSemicolon);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnumDeclarationContext : ParserRuleContext {
		public ITerminalNode KEnum() { return GetToken(PilParser.KEnum, 0); }
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public ITerminalNode TOpenBracket() { return GetToken(PilParser.TOpenBracket, 0); }
		public EnumLiteralsContext enumLiterals() {
			return GetRuleContext<EnumLiteralsContext>(0);
		}
		public ITerminalNode TCloseBracket() { return GetToken(PilParser.TCloseBracket, 0); }
		public ITerminalNode TSemicolon() { return GetToken(PilParser.TSemicolon, 0); }
		public EnumDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enumDeclaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterEnumDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitEnumDeclaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEnumDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EnumDeclarationContext enumDeclaration() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseEnumDeclaration() : _DoParseEnumDeclaration();
	}

	internal EnumDeclarationContext _DoParseEnumDeclaration() {
		EnumDeclarationContext _localctx = new EnumDeclarationContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_enumDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 220; Match(KEnum);
			State = 221; name();
			State = 222; Match(TOpenBracket);
			State = 223; enumLiterals();
			State = 224; Match(TCloseBracket);
			State = 225; Match(TSemicolon);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnumLiteralsContext : ParserRuleContext {
		public EnumLiteralContext[] enumLiteral() {
			return GetRuleContexts<EnumLiteralContext>();
		}
		public EnumLiteralContext enumLiteral(int i) {
			return GetRuleContext<EnumLiteralContext>(i);
		}
		public ITerminalNode[] TComma() { return GetTokens(PilParser.TComma); }
		public ITerminalNode TComma(int i) {
			return GetToken(PilParser.TComma, i);
		}
		public EnumLiteralsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enumLiterals; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterEnumLiterals(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitEnumLiterals(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEnumLiterals(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EnumLiteralsContext enumLiterals() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseEnumLiterals() : _DoParseEnumLiterals();
	}

	internal EnumLiteralsContext _DoParseEnumLiterals() {
		EnumLiteralsContext _localctx = new EnumLiteralsContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_enumLiterals);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 227; enumLiteral();
			State = 232;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==TComma) {
				{
				{
				State = 228; Match(TComma);
				State = 229; enumLiteral();
				}
				}
				State = 234;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnumLiteralContext : ParserRuleContext {
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public EnumLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enumLiteral; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterEnumLiteral(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitEnumLiteral(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEnumLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EnumLiteralContext enumLiteral() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseEnumLiteral() : _DoParseEnumLiteral();
	}

	internal EnumLiteralContext _DoParseEnumLiteral() {
		EnumLiteralContext _localctx = new EnumLiteralContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_enumLiteral);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 235; name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectDeclarationContext : ParserRuleContext {
		public ITerminalNode KObject() { return GetToken(PilParser.KObject, 0); }
		public ObjectHeaderContext objectHeader() {
			return GetRuleContext<ObjectHeaderContext>(0);
		}
		public ITerminalNode TSemicolon() { return GetToken(PilParser.TSemicolon, 0); }
		public ObjectExternalParametersContext objectExternalParameters() {
			return GetRuleContext<ObjectExternalParametersContext>(0);
		}
		public ObjectFieldsContext objectFields() {
			return GetRuleContext<ObjectFieldsContext>(0);
		}
		public ObjectFunctionsContext objectFunctions() {
			return GetRuleContext<ObjectFunctionsContext>(0);
		}
		public ITerminalNode KEndObject() { return GetToken(PilParser.KEndObject, 0); }
		public ObjectDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectDeclaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterObjectDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitObjectDeclaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObjectDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ObjectDeclarationContext objectDeclaration() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseObjectDeclaration() : _DoParseObjectDeclaration();
	}

	internal ObjectDeclarationContext _DoParseObjectDeclaration() {
		ObjectDeclarationContext _localctx = new ObjectDeclarationContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_objectDeclaration);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 237; Match(KObject);
			State = 238; objectHeader();
			State = 239; Match(TSemicolon);
			State = 240; objectExternalParameters();
			State = 241; objectFields();
			State = 242; objectFunctions();
			State = 243; Match(KEndObject);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectHeaderContext : ParserRuleContext {
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public ITerminalNode TOpenParen() { return GetToken(PilParser.TOpenParen, 0); }
		public ITerminalNode TCloseParen() { return GetToken(PilParser.TCloseParen, 0); }
		public PortsContext ports() {
			return GetRuleContext<PortsContext>(0);
		}
		public ObjectHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectHeader; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterObjectHeader(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitObjectHeader(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObjectHeader(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ObjectHeaderContext objectHeader() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseObjectHeader() : _DoParseObjectHeader();
	}

	internal ObjectHeaderContext _DoParseObjectHeader() {
		ObjectHeaderContext _localctx = new ObjectHeaderContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_objectHeader);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 245; name();
			State = 246; Match(TOpenParen);
			State = 248;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 247; ports();
				}
			}

			State = 250; Match(TCloseParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PortsContext : ParserRuleContext {
		public PortContext[] port() {
			return GetRuleContexts<PortContext>();
		}
		public PortContext port(int i) {
			return GetRuleContext<PortContext>(i);
		}
		public ITerminalNode[] TComma() { return GetTokens(PilParser.TComma); }
		public ITerminalNode TComma(int i) {
			return GetToken(PilParser.TComma, i);
		}
		public PortsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ports; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterPorts(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitPorts(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPorts(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PortsContext ports() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParsePorts() : _DoParsePorts();
	}

	internal PortsContext _DoParsePorts() {
		PortsContext _localctx = new PortsContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_ports);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 252; port();
			State = 257;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==TComma) {
				{
				{
				State = 253; Match(TComma);
				State = 254; port();
				}
				}
				State = 259;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PortContext : ParserRuleContext {
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public PortContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_port; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterPort(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitPort(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPort(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PortContext port() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParsePort() : _DoParsePort();
	}

	internal PortContext _DoParsePort() {
		PortContext _localctx = new PortContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_port);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 260; name();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectExternalParametersContext : ParserRuleContext {
		public ExternalParameterDeclarationContext[] externalParameterDeclaration() {
			return GetRuleContexts<ExternalParameterDeclarationContext>();
		}
		public ExternalParameterDeclarationContext externalParameterDeclaration(int i) {
			return GetRuleContext<ExternalParameterDeclarationContext>(i);
		}
		public ObjectExternalParametersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectExternalParameters; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterObjectExternalParameters(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitObjectExternalParameters(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObjectExternalParameters(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ObjectExternalParametersContext objectExternalParameters() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseObjectExternalParameters() : _DoParseObjectExternalParameters();
	}

	internal ObjectExternalParametersContext _DoParseObjectExternalParameters() {
		ObjectExternalParametersContext _localctx = new ObjectExternalParametersContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_objectExternalParameters);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 265;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==KParam) {
				{
				{
				State = 262; externalParameterDeclaration();
				}
				}
				State = 267;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectFieldsContext : ParserRuleContext {
		public VariableDeclarationContext[] variableDeclaration() {
			return GetRuleContexts<VariableDeclarationContext>();
		}
		public VariableDeclarationContext variableDeclaration(int i) {
			return GetRuleContext<VariableDeclarationContext>(i);
		}
		public ObjectFieldsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectFields; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterObjectFields(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitObjectFields(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObjectFields(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ObjectFieldsContext objectFields() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseObjectFields() : _DoParseObjectFields();
	}

	internal ObjectFieldsContext _DoParseObjectFields() {
		ObjectFieldsContext _localctx = new ObjectFieldsContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_objectFields);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 271;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==KVar) {
				{
				{
				State = 268; variableDeclaration();
				}
				}
				State = 273;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ObjectFunctionsContext : ParserRuleContext {
		public FunctionDeclarationContext[] functionDeclaration() {
			return GetRuleContexts<FunctionDeclarationContext>();
		}
		public FunctionDeclarationContext functionDeclaration(int i) {
			return GetRuleContext<FunctionDeclarationContext>(i);
		}
		public ObjectFunctionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_objectFunctions; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterObjectFunctions(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitObjectFunctions(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitObjectFunctions(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ObjectFunctionsContext objectFunctions() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseObjectFunctions() : _DoParseObjectFunctions();
	}

	internal ObjectFunctionsContext _DoParseObjectFunctions() {
		ObjectFunctionsContext _localctx = new ObjectFunctionsContext(_ctx, State);
		EnterRule(_localctx, 26, RULE_objectFunctions);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 277;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==KFunction) {
				{
				{
				State = 274; functionDeclaration();
				}
				}
				State = 279;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionDeclarationContext : ParserRuleContext {
		public ITerminalNode KFunction() { return GetToken(PilParser.KFunction, 0); }
		public FunctionHeaderContext functionHeader() {
			return GetRuleContext<FunctionHeaderContext>(0);
		}
		public ITerminalNode TSemicolon() { return GetToken(PilParser.TSemicolon, 0); }
		public ITerminalNode KEndFunction() { return GetToken(PilParser.KEndFunction, 0); }
		public CommentContext comment() {
			return GetRuleContext<CommentContext>(0);
		}
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public FunctionDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionDeclaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterFunctionDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitFunctionDeclaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionDeclarationContext functionDeclaration() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseFunctionDeclaration() : _DoParseFunctionDeclaration();
	}

	internal FunctionDeclarationContext _DoParseFunctionDeclaration() {
		FunctionDeclarationContext _localctx = new FunctionDeclarationContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_functionDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 280; Match(KFunction);
			State = 281; functionHeader();
			State = 283;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LString) {
				{
				State = 282; comment();
				}
			}

			State = 285; Match(TSemicolon);
			State = 287;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,10,_ctx) ) {
			case 1:
				{
				State = 286; statements();
				}
				break;
			}
			State = 289; Match(KEndFunction);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionHeaderContext : ParserRuleContext {
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public ITerminalNode TOpenParen() { return GetToken(PilParser.TOpenParen, 0); }
		public ITerminalNode TCloseParen() { return GetToken(PilParser.TCloseParen, 0); }
		public ITerminalNode TColon() { return GetToken(PilParser.TColon, 0); }
		public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		public FunctionParamsContext functionParams() {
			return GetRuleContext<FunctionParamsContext>(0);
		}
		public FunctionHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionHeader; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterFunctionHeader(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitFunctionHeader(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionHeader(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionHeaderContext functionHeader() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseFunctionHeader() : _DoParseFunctionHeader();
	}

	internal FunctionHeaderContext _DoParseFunctionHeader() {
		FunctionHeaderContext _localctx = new FunctionHeaderContext(_ctx, State);
		EnterRule(_localctx, 30, RULE_functionHeader);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 291; name();
			State = 292; Match(TOpenParen);
			State = 294;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 293; functionParams();
				}
			}

			State = 296; Match(TCloseParen);
			State = 297; Match(TColon);
			State = 298; typeReference();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionParamsContext : ParserRuleContext {
		public ParamContext[] param() {
			return GetRuleContexts<ParamContext>();
		}
		public ParamContext param(int i) {
			return GetRuleContext<ParamContext>(i);
		}
		public ITerminalNode[] TComma() { return GetTokens(PilParser.TComma); }
		public ITerminalNode TComma(int i) {
			return GetToken(PilParser.TComma, i);
		}
		public FunctionParamsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionParams; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterFunctionParams(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitFunctionParams(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionParams(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionParamsContext functionParams() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseFunctionParams() : _DoParseFunctionParams();
	}

	internal FunctionParamsContext _DoParseFunctionParams() {
		FunctionParamsContext _localctx = new FunctionParamsContext(_ctx, State);
		EnterRule(_localctx, 32, RULE_functionParams);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 300; param();
			State = 305;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==TComma) {
				{
				{
				State = 301; Match(TComma);
				State = 302; param();
				}
				}
				State = 307;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParamContext : ParserRuleContext {
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public ITerminalNode TColon() { return GetToken(PilParser.TColon, 0); }
		public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		public ParamContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_param; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterParam(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitParam(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParam(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParamContext param() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseParam() : _DoParseParam();
	}

	internal ParamContext _DoParseParam() {
		ParamContext _localctx = new ParamContext(_ctx, State);
		EnterRule(_localctx, 34, RULE_param);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 308; name();
			State = 309; Match(TColon);
			State = 310; typeReference();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QueryDeclarationContext : ParserRuleContext {
		public IToken startQuerySemicolon;
		public IdentifierContext endName;
		public IToken endQuerySemicolon;
		public ITerminalNode KQuery() { return GetToken(PilParser.KQuery, 0); }
		public QueryHeaderContext queryHeader() {
			return GetRuleContext<QueryHeaderContext>(0);
		}
		public ITerminalNode KEndQuery() { return GetToken(PilParser.KEndQuery, 0); }
		public ITerminalNode[] TSemicolon() { return GetTokens(PilParser.TSemicolon); }
		public ITerminalNode TSemicolon(int i) {
			return GetToken(PilParser.TSemicolon, i);
		}
		public CommentContext comment() {
			return GetRuleContext<CommentContext>(0);
		}
		public QueryExternalParametersContext[] queryExternalParameters() {
			return GetRuleContexts<QueryExternalParametersContext>();
		}
		public QueryExternalParametersContext queryExternalParameters(int i) {
			return GetRuleContext<QueryExternalParametersContext>(i);
		}
		public QueryFieldContext[] queryField() {
			return GetRuleContexts<QueryFieldContext>();
		}
		public QueryFieldContext queryField(int i) {
			return GetRuleContext<QueryFieldContext>(i);
		}
		public FunctionDeclarationContext[] functionDeclaration() {
			return GetRuleContexts<FunctionDeclarationContext>();
		}
		public FunctionDeclarationContext functionDeclaration(int i) {
			return GetRuleContext<FunctionDeclarationContext>(i);
		}
		public QueryObjectContext[] queryObject() {
			return GetRuleContexts<QueryObjectContext>();
		}
		public QueryObjectContext queryObject(int i) {
			return GetRuleContext<QueryObjectContext>(i);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public QueryDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_queryDeclaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterQueryDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitQueryDeclaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQueryDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QueryDeclarationContext queryDeclaration() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseQueryDeclaration() : _DoParseQueryDeclaration();
	}

	internal QueryDeclarationContext _DoParseQueryDeclaration() {
		QueryDeclarationContext _localctx = new QueryDeclarationContext(_ctx, State);
		EnterRule(_localctx, 36, RULE_queryDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 312; Match(KQuery);
			State = 313; queryHeader();
			State = 315;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LString) {
				{
				State = 314; comment();
				}
			}

			State = 317; _localctx.startQuerySemicolon = Match(TSemicolon);
			State = 321;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==KParam) {
				{
				{
				State = 318; queryExternalParameters();
				}
				}
				State = 323;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 327;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==KVar) {
				{
				{
				State = 324; queryField();
				}
				}
				State = 329;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 333;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==KFunction) {
				{
				{
				State = 330; functionDeclaration();
				}
				}
				State = 335;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 339;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==KObject) {
				{
				{
				State = 336; queryObject();
				}
				}
				State = 341;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 342; Match(KEndQuery);
			State = 344;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 343; _localctx.endName = identifier();
				}
			}

			State = 346; _localctx.endQuerySemicolon = Match(TSemicolon);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QueryHeaderContext : ParserRuleContext {
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public ITerminalNode TOpenParen() { return GetToken(PilParser.TOpenParen, 0); }
		public ITerminalNode TCloseParen() { return GetToken(PilParser.TCloseParen, 0); }
		public QueryRequestParamsContext queryRequestParams() {
			return GetRuleContext<QueryRequestParamsContext>(0);
		}
		public QueryHeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_queryHeader; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterQueryHeader(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitQueryHeader(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQueryHeader(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QueryHeaderContext queryHeader() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseQueryHeader() : _DoParseQueryHeader();
	}

	internal QueryHeaderContext _DoParseQueryHeader() {
		QueryHeaderContext _localctx = new QueryHeaderContext(_ctx, State);
		EnterRule(_localctx, 38, RULE_queryHeader);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 348; name();
			State = 349; Match(TOpenParen);
			State = 351;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==KRequest || _la==LIdentifier) {
				{
				State = 350; queryRequestParams();
				}
			}

			State = 353; Match(TCloseParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QueryRequestParamsContext : ParserRuleContext {
		public ParamContext[] param() {
			return GetRuleContexts<ParamContext>();
		}
		public ParamContext param(int i) {
			return GetRuleContext<ParamContext>(i);
		}
		public ITerminalNode KRequest() { return GetToken(PilParser.KRequest, 0); }
		public ITerminalNode[] TComma() { return GetTokens(PilParser.TComma); }
		public ITerminalNode TComma(int i) {
			return GetToken(PilParser.TComma, i);
		}
		public ITerminalNode TSemicolon() { return GetToken(PilParser.TSemicolon, 0); }
		public QueryRequestParamsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_queryRequestParams; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterQueryRequestParams(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitQueryRequestParams(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQueryRequestParams(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QueryRequestParamsContext queryRequestParams() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseQueryRequestParams() : _DoParseQueryRequestParams();
	}

	internal QueryRequestParamsContext _DoParseQueryRequestParams() {
		QueryRequestParamsContext _localctx = new QueryRequestParamsContext(_ctx, State);
		EnterRule(_localctx, 40, RULE_queryRequestParams);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 356;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==KRequest) {
				{
				State = 355; Match(KRequest);
				}
			}

			State = 358; param();
			State = 363;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==TComma) {
				{
				{
				State = 359; Match(TComma);
				State = 360; param();
				}
				}
				State = 365;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 367;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==TSemicolon) {
				{
				State = 366; Match(TSemicolon);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QueryAcceptParamsContext : ParserRuleContext {
		public ITerminalNode KAccept() { return GetToken(PilParser.KAccept, 0); }
		public ParamContext[] param() {
			return GetRuleContexts<ParamContext>();
		}
		public ParamContext param(int i) {
			return GetRuleContext<ParamContext>(i);
		}
		public ITerminalNode[] TComma() { return GetTokens(PilParser.TComma); }
		public ITerminalNode TComma(int i) {
			return GetToken(PilParser.TComma, i);
		}
		public ITerminalNode TSemicolon() { return GetToken(PilParser.TSemicolon, 0); }
		public QueryAcceptParamsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_queryAcceptParams; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterQueryAcceptParams(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitQueryAcceptParams(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQueryAcceptParams(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QueryAcceptParamsContext queryAcceptParams() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseQueryAcceptParams() : _DoParseQueryAcceptParams();
	}

	internal QueryAcceptParamsContext _DoParseQueryAcceptParams() {
		QueryAcceptParamsContext _localctx = new QueryAcceptParamsContext(_ctx, State);
		EnterRule(_localctx, 42, RULE_queryAcceptParams);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 369; Match(KAccept);
			State = 370; param();
			State = 375;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==TComma) {
				{
				{
				State = 371; Match(TComma);
				State = 372; param();
				}
				}
				State = 377;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 379;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==TSemicolon) {
				{
				State = 378; Match(TSemicolon);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QueryRefuseParamsContext : ParserRuleContext {
		public ITerminalNode KRefuse() { return GetToken(PilParser.KRefuse, 0); }
		public ParamContext[] param() {
			return GetRuleContexts<ParamContext>();
		}
		public ParamContext param(int i) {
			return GetRuleContext<ParamContext>(i);
		}
		public ITerminalNode[] TComma() { return GetTokens(PilParser.TComma); }
		public ITerminalNode TComma(int i) {
			return GetToken(PilParser.TComma, i);
		}
		public ITerminalNode TSemicolon() { return GetToken(PilParser.TSemicolon, 0); }
		public QueryRefuseParamsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_queryRefuseParams; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterQueryRefuseParams(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitQueryRefuseParams(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQueryRefuseParams(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QueryRefuseParamsContext queryRefuseParams() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseQueryRefuseParams() : _DoParseQueryRefuseParams();
	}

	internal QueryRefuseParamsContext _DoParseQueryRefuseParams() {
		QueryRefuseParamsContext _localctx = new QueryRefuseParamsContext(_ctx, State);
		EnterRule(_localctx, 44, RULE_queryRefuseParams);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 381; Match(KRefuse);
			State = 382; param();
			State = 387;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==TComma) {
				{
				{
				State = 383; Match(TComma);
				State = 384; param();
				}
				}
				State = 389;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 391;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==TSemicolon) {
				{
				State = 390; Match(TSemicolon);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QueryCancelParamsContext : ParserRuleContext {
		public ITerminalNode KCancel() { return GetToken(PilParser.KCancel, 0); }
		public ParamContext[] param() {
			return GetRuleContexts<ParamContext>();
		}
		public ParamContext param(int i) {
			return GetRuleContext<ParamContext>(i);
		}
		public ITerminalNode[] TComma() { return GetTokens(PilParser.TComma); }
		public ITerminalNode TComma(int i) {
			return GetToken(PilParser.TComma, i);
		}
		public ITerminalNode TSemicolon() { return GetToken(PilParser.TSemicolon, 0); }
		public QueryCancelParamsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_queryCancelParams; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterQueryCancelParams(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitQueryCancelParams(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQueryCancelParams(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QueryCancelParamsContext queryCancelParams() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseQueryCancelParams() : _DoParseQueryCancelParams();
	}

	internal QueryCancelParamsContext _DoParseQueryCancelParams() {
		QueryCancelParamsContext _localctx = new QueryCancelParamsContext(_ctx, State);
		EnterRule(_localctx, 46, RULE_queryCancelParams);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 393; Match(KCancel);
			State = 394; param();
			State = 399;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==TComma) {
				{
				{
				State = 395; Match(TComma);
				State = 396; param();
				}
				}
				State = 401;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 403;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==TSemicolon) {
				{
				State = 402; Match(TSemicolon);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QueryExternalParametersContext : ParserRuleContext {
		public ExternalParameterDeclarationContext externalParameterDeclaration() {
			return GetRuleContext<ExternalParameterDeclarationContext>(0);
		}
		public QueryExternalParametersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_queryExternalParameters; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterQueryExternalParameters(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitQueryExternalParameters(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQueryExternalParameters(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QueryExternalParametersContext queryExternalParameters() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseQueryExternalParameters() : _DoParseQueryExternalParameters();
	}

	internal QueryExternalParametersContext _DoParseQueryExternalParameters() {
		QueryExternalParametersContext _localctx = new QueryExternalParametersContext(_ctx, State);
		EnterRule(_localctx, 48, RULE_queryExternalParameters);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 405; externalParameterDeclaration();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QueryFieldContext : ParserRuleContext {
		public VariableDeclarationContext variableDeclaration() {
			return GetRuleContext<VariableDeclarationContext>(0);
		}
		public QueryFieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_queryField; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterQueryField(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitQueryField(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQueryField(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QueryFieldContext queryField() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseQueryField() : _DoParseQueryField();
	}

	internal QueryFieldContext _DoParseQueryField() {
		QueryFieldContext _localctx = new QueryFieldContext(_ctx, State);
		EnterRule(_localctx, 50, RULE_queryField);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 407; variableDeclaration();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QueryFunctionContext : ParserRuleContext {
		public FunctionDeclarationContext functionDeclaration() {
			return GetRuleContext<FunctionDeclarationContext>(0);
		}
		public QueryFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_queryFunction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterQueryFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitQueryFunction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQueryFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QueryFunctionContext queryFunction() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseQueryFunction() : _DoParseQueryFunction();
	}

	internal QueryFunctionContext _DoParseQueryFunction() {
		QueryFunctionContext _localctx = new QueryFunctionContext(_ctx, State);
		EnterRule(_localctx, 52, RULE_queryFunction);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 409; functionDeclaration();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QueryObjectContext : ParserRuleContext {
		public IToken startObjectSemicolon;
		public IdentifierContext endName;
		public IToken endObjectSemicolon;
		public ITerminalNode KObject() { return GetToken(PilParser.KObject, 0); }
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public ITerminalNode KEndObject() { return GetToken(PilParser.KEndObject, 0); }
		public ITerminalNode[] TSemicolon() { return GetTokens(PilParser.TSemicolon); }
		public ITerminalNode TSemicolon(int i) {
			return GetToken(PilParser.TSemicolon, i);
		}
		public CommentContext comment() {
			return GetRuleContext<CommentContext>(0);
		}
		public QueryObjectFieldContext[] queryObjectField() {
			return GetRuleContexts<QueryObjectFieldContext>();
		}
		public QueryObjectFieldContext queryObjectField(int i) {
			return GetRuleContext<QueryObjectFieldContext>(i);
		}
		public QueryObjectFunctionContext[] queryObjectFunction() {
			return GetRuleContexts<QueryObjectFunctionContext>();
		}
		public QueryObjectFunctionContext queryObjectFunction(int i) {
			return GetRuleContext<QueryObjectFunctionContext>(i);
		}
		public QueryObjectEventContext[] queryObjectEvent() {
			return GetRuleContexts<QueryObjectEventContext>();
		}
		public QueryObjectEventContext queryObjectEvent(int i) {
			return GetRuleContext<QueryObjectEventContext>(i);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public QueryObjectContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_queryObject; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterQueryObject(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitQueryObject(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQueryObject(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QueryObjectContext queryObject() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseQueryObject() : _DoParseQueryObject();
	}

	internal QueryObjectContext _DoParseQueryObject() {
		QueryObjectContext _localctx = new QueryObjectContext(_ctx, State);
		EnterRule(_localctx, 54, RULE_queryObject);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 411; Match(KObject);
			State = 412; name();
			State = 414;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LString) {
				{
				State = 413; comment();
				}
			}

			State = 416; _localctx.startObjectSemicolon = Match(TSemicolon);
			State = 420;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==KVar) {
				{
				{
				State = 417; queryObjectField();
				}
				}
				State = 422;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 426;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==KFunction) {
				{
				{
				State = 423; queryObjectFunction();
				}
				}
				State = 428;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 432;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==KTrigger || _la==KInput) {
				{
				{
				State = 429; queryObjectEvent();
				}
				}
				State = 434;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 435; Match(KEndObject);
			State = 437;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 436; _localctx.endName = identifier();
				}
			}

			State = 439; _localctx.endObjectSemicolon = Match(TSemicolon);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QueryObjectFieldContext : ParserRuleContext {
		public VariableDeclarationContext variableDeclaration() {
			return GetRuleContext<VariableDeclarationContext>(0);
		}
		public QueryObjectFieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_queryObjectField; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterQueryObjectField(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitQueryObjectField(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQueryObjectField(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QueryObjectFieldContext queryObjectField() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseQueryObjectField() : _DoParseQueryObjectField();
	}

	internal QueryObjectFieldContext _DoParseQueryObjectField() {
		QueryObjectFieldContext _localctx = new QueryObjectFieldContext(_ctx, State);
		EnterRule(_localctx, 56, RULE_queryObjectField);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 441; variableDeclaration();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QueryObjectFunctionContext : ParserRuleContext {
		public FunctionDeclarationContext functionDeclaration() {
			return GetRuleContext<FunctionDeclarationContext>(0);
		}
		public QueryObjectFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_queryObjectFunction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterQueryObjectFunction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitQueryObjectFunction(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQueryObjectFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QueryObjectFunctionContext queryObjectFunction() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseQueryObjectFunction() : _DoParseQueryObjectFunction();
	}

	internal QueryObjectFunctionContext _DoParseQueryObjectFunction() {
		QueryObjectFunctionContext _localctx = new QueryObjectFunctionContext(_ctx, State);
		EnterRule(_localctx, 58, RULE_queryObjectFunction);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 443; functionDeclaration();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QueryObjectEventContext : ParserRuleContext {
		public InputContext input() {
			return GetRuleContext<InputContext>(0);
		}
		public TriggerContext trigger() {
			return GetRuleContext<TriggerContext>(0);
		}
		public QueryObjectEventContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_queryObjectEvent; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterQueryObjectEvent(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitQueryObjectEvent(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQueryObjectEvent(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QueryObjectEventContext queryObjectEvent() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseQueryObjectEvent() : _DoParseQueryObjectEvent();
	}

	internal QueryObjectEventContext _DoParseQueryObjectEvent() {
		QueryObjectEventContext _localctx = new QueryObjectEventContext(_ctx, State);
		EnterRule(_localctx, 60, RULE_queryObjectEvent);
		try {
			State = 447;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case KInput:
				EnterOuterAlt(_localctx, 1);
				{
				State = 445; input();
				}
				break;
			case KTrigger:
				EnterOuterAlt(_localctx, 2);
				{
				State = 446; trigger();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InputContext : ParserRuleContext {
		public ITerminalNode KInput() { return GetToken(PilParser.KInput, 0); }
		public InputPortListContext inputPortList() {
			return GetRuleContext<InputPortListContext>(0);
		}
		public ITerminalNode TSemicolon() { return GetToken(PilParser.TSemicolon, 0); }
		public CommentContext comment() {
			return GetRuleContext<CommentContext>(0);
		}
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public InputContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_input; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterInput(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitInput(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInput(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InputContext input() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseInput() : _DoParseInput();
	}

	internal InputContext _DoParseInput() {
		InputContext _localctx = new InputContext(_ctx, State);
		EnterRule(_localctx, 62, RULE_input);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 449; Match(KInput);
			State = 450; inputPortList();
			State = 452;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LString) {
				{
				State = 451; comment();
				}
			}

			State = 454; Match(TSemicolon);
			State = 456;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,36,_ctx) ) {
			case 1:
				{
				State = 455; statements();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InputPortListContext : ParserRuleContext {
		public InputPortContext[] inputPort() {
			return GetRuleContexts<InputPortContext>();
		}
		public InputPortContext inputPort(int i) {
			return GetRuleContext<InputPortContext>(i);
		}
		public ITerminalNode[] TComma() { return GetTokens(PilParser.TComma); }
		public ITerminalNode TComma(int i) {
			return GetToken(PilParser.TComma, i);
		}
		public InputPortListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_inputPortList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterInputPortList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitInputPortList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInputPortList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InputPortListContext inputPortList() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseInputPortList() : _DoParseInputPortList();
	}

	internal InputPortListContext _DoParseInputPortList() {
		InputPortListContext _localctx = new InputPortListContext(_ctx, State);
		EnterRule(_localctx, 64, RULE_inputPortList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 458; inputPort();
			State = 463;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==TComma) {
				{
				{
				State = 459; Match(TComma);
				State = 460; inputPort();
				}
				}
				State = 465;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InputPortContext : ParserRuleContext {
		public IdentifierContext portName;
		public IdentifierContext queryName;
		public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		public ITerminalNode TDot() { return GetToken(PilParser.TDot, 0); }
		public InputPortContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_inputPort; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterInputPort(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitInputPort(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInputPort(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InputPortContext inputPort() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseInputPort() : _DoParseInputPort();
	}

	internal InputPortContext _DoParseInputPort() {
		InputPortContext _localctx = new InputPortContext(_ctx, State);
		EnterRule(_localctx, 66, RULE_inputPort);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 466; _localctx.portName = identifier();
			State = 469;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==TDot) {
				{
				State = 467; Match(TDot);
				State = 468; _localctx.queryName = identifier();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TriggerContext : ParserRuleContext {
		public ITerminalNode KTrigger() { return GetToken(PilParser.KTrigger, 0); }
		public TriggerVarListContext triggerVarList() {
			return GetRuleContext<TriggerVarListContext>(0);
		}
		public ITerminalNode TSemicolon() { return GetToken(PilParser.TSemicolon, 0); }
		public CommentContext comment() {
			return GetRuleContext<CommentContext>(0);
		}
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public TriggerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trigger; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterTrigger(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitTrigger(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTrigger(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TriggerContext trigger() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseTrigger() : _DoParseTrigger();
	}

	internal TriggerContext _DoParseTrigger() {
		TriggerContext _localctx = new TriggerContext(_ctx, State);
		EnterRule(_localctx, 68, RULE_trigger);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 471; Match(KTrigger);
			State = 472; triggerVarList();
			State = 474;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LString) {
				{
				State = 473; comment();
				}
			}

			State = 476; Match(TSemicolon);
			State = 478;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,40,_ctx) ) {
			case 1:
				{
				State = 477; statements();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TriggerVarListContext : ParserRuleContext {
		public TriggerVarContext[] triggerVar() {
			return GetRuleContexts<TriggerVarContext>();
		}
		public TriggerVarContext triggerVar(int i) {
			return GetRuleContext<TriggerVarContext>(i);
		}
		public ITerminalNode[] TComma() { return GetTokens(PilParser.TComma); }
		public ITerminalNode TComma(int i) {
			return GetToken(PilParser.TComma, i);
		}
		public TriggerVarListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_triggerVarList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterTriggerVarList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitTriggerVarList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTriggerVarList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TriggerVarListContext triggerVarList() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseTriggerVarList() : _DoParseTriggerVarList();
	}

	internal TriggerVarListContext _DoParseTriggerVarList() {
		TriggerVarListContext _localctx = new TriggerVarListContext(_ctx, State);
		EnterRule(_localctx, 70, RULE_triggerVarList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 480; triggerVar();
			State = 485;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==TComma) {
				{
				{
				State = 481; Match(TComma);
				State = 482; triggerVar();
				}
				}
				State = 487;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TriggerVarContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public TriggerVarContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_triggerVar; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterTriggerVar(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitTriggerVar(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTriggerVar(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TriggerVarContext triggerVar() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseTriggerVar() : _DoParseTriggerVar();
	}

	internal TriggerVarContext _DoParseTriggerVar() {
		TriggerVarContext _localctx = new TriggerVarContext(_ctx, State);
		EnterRule(_localctx, 72, RULE_triggerVar);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 488; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementsContext : ParserRuleContext {
		public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public StatementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statements; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterStatements(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitStatements(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementsContext statements() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseStatements() : _DoParseStatements();
	}

	internal StatementsContext _DoParseStatements() {
		StatementsContext _localctx = new StatementsContext(_ctx, State);
		EnterRule(_localctx, 74, RULE_statements);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 493;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KResult) | (1L << KFork) | (1L << KIf) | (1L << KRequest) | (1L << KAccept) | (1L << KRefuse) | (1L << KCancel) | (1L << KVar))) != 0) || _la==LIdentifier) {
				{
				{
				State = 490; statement();
				}
				}
				State = 495;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		public VariableDeclarationStatementContext variableDeclarationStatement() {
			return GetRuleContext<VariableDeclarationStatementContext>(0);
		}
		public RequestStatementContext requestStatement() {
			return GetRuleContext<RequestStatementContext>(0);
		}
		public ForkStatementContext forkStatement() {
			return GetRuleContext<ForkStatementContext>(0);
		}
		public ForkRequestStatementContext forkRequestStatement() {
			return GetRuleContext<ForkRequestStatementContext>(0);
		}
		public IfStatementContext ifStatement() {
			return GetRuleContext<IfStatementContext>(0);
		}
		public ResponseStatementContext responseStatement() {
			return GetRuleContext<ResponseStatementContext>(0);
		}
		public CancelStatementContext cancelStatement() {
			return GetRuleContext<CancelStatementContext>(0);
		}
		public AssignmentStatementContext assignmentStatement() {
			return GetRuleContext<AssignmentStatementContext>(0);
		}
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseStatement() : _DoParseStatement();
	}

	internal StatementContext _DoParseStatement() {
		StatementContext _localctx = new StatementContext(_ctx, State);
		EnterRule(_localctx, 76, RULE_statement);
		try {
			State = 504;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,43,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 496; variableDeclarationStatement();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 497; requestStatement();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 498; forkStatement();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 499; forkRequestStatement();
				}
				break;

			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 500; ifStatement();
				}
				break;

			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 501; responseStatement();
				}
				break;

			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 502; cancelStatement();
				}
				break;

			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 503; assignmentStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForkStatementContext : ParserRuleContext {
		public ITerminalNode KFork() { return GetToken(PilParser.KFork, 0); }
		public ITerminalNode KEndFork() { return GetToken(PilParser.KEndFork, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public CaseBranchContext[] caseBranch() {
			return GetRuleContexts<CaseBranchContext>();
		}
		public CaseBranchContext caseBranch(int i) {
			return GetRuleContext<CaseBranchContext>(i);
		}
		public ElseBranchContext elseBranch() {
			return GetRuleContext<ElseBranchContext>(0);
		}
		public ForkStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forkStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterForkStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitForkStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForkStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ForkStatementContext forkStatement() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseForkStatement() : _DoParseForkStatement();
	}

	internal ForkStatementContext _DoParseForkStatement() {
		ForkStatementContext _localctx = new ForkStatementContext(_ctx, State);
		EnterRule(_localctx, 78, RULE_forkStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 506; Match(KFork);
			State = 508;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (((((_la - 31)) & ~0x3f) == 0 && ((1L << (_la - 31)) & ((1L << (KTrue - 31)) | (1L << (KFalse - 31)) | (1L << (KNull - 31)) | (1L << (TOpenParen - 31)) | (1L << (TMinus - 31)) | (1L << (TExclamation - 31)) | (1L << (LIdentifier - 31)) | (1L << (LInteger - 31)))) != 0)) {
				{
				State = 507; expression();
				}
			}

			State = 513;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==KCase) {
				{
				{
				State = 510; caseBranch();
				}
				}
				State = 515;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 517;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==KElse) {
				{
				State = 516; elseBranch();
				}
			}

			State = 519; Match(KEndFork);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CaseBranchContext : ParserRuleContext {
		public ExpressionContext condition;
		public ITerminalNode KCase() { return GetToken(PilParser.KCase, 0); }
		public ITerminalNode TSemicolon() { return GetToken(PilParser.TSemicolon, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public CommentContext comment() {
			return GetRuleContext<CommentContext>(0);
		}
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public CaseBranchContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_caseBranch; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterCaseBranch(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitCaseBranch(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCaseBranch(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CaseBranchContext caseBranch() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseCaseBranch() : _DoParseCaseBranch();
	}

	internal CaseBranchContext _DoParseCaseBranch() {
		CaseBranchContext _localctx = new CaseBranchContext(_ctx, State);
		EnterRule(_localctx, 80, RULE_caseBranch);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 521; Match(KCase);
			State = 522; _localctx.condition = expression();
			State = 524;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LString) {
				{
				State = 523; comment();
				}
			}

			State = 526; Match(TSemicolon);
			State = 528;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,48,_ctx) ) {
			case 1:
				{
				State = 527; statements();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseBranchContext : ParserRuleContext {
		public ITerminalNode KElse() { return GetToken(PilParser.KElse, 0); }
		public CommentContext comment() {
			return GetRuleContext<CommentContext>(0);
		}
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public ElseBranchContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elseBranch; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterElseBranch(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitElseBranch(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElseBranch(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseBranchContext elseBranch() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseElseBranch() : _DoParseElseBranch();
	}

	internal ElseBranchContext _DoParseElseBranch() {
		ElseBranchContext _localctx = new ElseBranchContext(_ctx, State);
		EnterRule(_localctx, 82, RULE_elseBranch);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 530; Match(KElse);
			State = 532;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LString) {
				{
				State = 531; comment();
				}
			}

			State = 535;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,50,_ctx) ) {
			case 1:
				{
				State = 534; statements();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfStatementContext : ParserRuleContext {
		public ITerminalNode KIf() { return GetToken(PilParser.KIf, 0); }
		public IfBranchContext ifBranch() {
			return GetRuleContext<IfBranchContext>(0);
		}
		public ITerminalNode KEndIf() { return GetToken(PilParser.KEndIf, 0); }
		public ElseIfBranchContext[] elseIfBranch() {
			return GetRuleContexts<ElseIfBranchContext>();
		}
		public ElseIfBranchContext elseIfBranch(int i) {
			return GetRuleContext<ElseIfBranchContext>(i);
		}
		public ElseBranchContext[] elseBranch() {
			return GetRuleContexts<ElseBranchContext>();
		}
		public ElseBranchContext elseBranch(int i) {
			return GetRuleContext<ElseBranchContext>(i);
		}
		public IfStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterIfStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitIfStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfStatementContext ifStatement() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseIfStatement() : _DoParseIfStatement();
	}

	internal IfStatementContext _DoParseIfStatement() {
		IfStatementContext _localctx = new IfStatementContext(_ctx, State);
		EnterRule(_localctx, 84, RULE_ifStatement);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 537; Match(KIf);
			State = 538; ifBranch();
			State = 542;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,51,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 539; elseIfBranch();
					}
					} 
				}
				State = 544;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,51,_ctx);
			}
			State = 548;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==KElse) {
				{
				{
				State = 545; elseBranch();
				}
				}
				State = 550;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			State = 551; Match(KEndIf);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IfBranchContext : ParserRuleContext {
		public ConditionalExpressionContext conditionalExpression() {
			return GetRuleContext<ConditionalExpressionContext>(0);
		}
		public ITerminalNode TSemicolon() { return GetToken(PilParser.TSemicolon, 0); }
		public CommentContext comment() {
			return GetRuleContext<CommentContext>(0);
		}
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public IfBranchContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ifBranch; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterIfBranch(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitIfBranch(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIfBranch(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IfBranchContext ifBranch() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseIfBranch() : _DoParseIfBranch();
	}

	internal IfBranchContext _DoParseIfBranch() {
		IfBranchContext _localctx = new IfBranchContext(_ctx, State);
		EnterRule(_localctx, 86, RULE_ifBranch);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 553; conditionalExpression(0);
			State = 555;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LString) {
				{
				State = 554; comment();
				}
			}

			State = 557; Match(TSemicolon);
			State = 559;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,54,_ctx) ) {
			case 1:
				{
				State = 558; statements();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseIfBranchContext : ParserRuleContext {
		public ITerminalNode KElse() { return GetToken(PilParser.KElse, 0); }
		public ITerminalNode KIf() { return GetToken(PilParser.KIf, 0); }
		public IfBranchContext ifBranch() {
			return GetRuleContext<IfBranchContext>(0);
		}
		public ElseIfBranchContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elseIfBranch; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterElseIfBranch(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitElseIfBranch(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElseIfBranch(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseIfBranchContext elseIfBranch() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseElseIfBranch() : _DoParseElseIfBranch();
	}

	internal ElseIfBranchContext _DoParseElseIfBranch() {
		ElseIfBranchContext _localctx = new ElseIfBranchContext(_ctx, State);
		EnterRule(_localctx, 88, RULE_elseIfBranch);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 561; Match(KElse);
			State = 562; Match(KIf);
			State = 563; ifBranch();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RequestStatementContext : ParserRuleContext {
		public CallRequestContext callRequest() {
			return GetRuleContext<CallRequestContext>(0);
		}
		public ITerminalNode TSemicolon() { return GetToken(PilParser.TSemicolon, 0); }
		public LeftSideContext leftSide() {
			return GetRuleContext<LeftSideContext>(0);
		}
		public ITerminalNode TAssign() { return GetToken(PilParser.TAssign, 0); }
		public AssertionContext assertion() {
			return GetRuleContext<AssertionContext>(0);
		}
		public RequestStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_requestStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterRequestStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitRequestStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRequestStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RequestStatementContext requestStatement() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseRequestStatement() : _DoParseRequestStatement();
	}

	internal RequestStatementContext _DoParseRequestStatement() {
		RequestStatementContext _localctx = new RequestStatementContext(_ctx, State);
		EnterRule(_localctx, 90, RULE_requestStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 568;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==KResult || _la==LIdentifier) {
				{
				State = 565; leftSide();
				State = 566; Match(TAssign);
				}
			}

			State = 570; callRequest();
			State = 572;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==TColon) {
				{
				State = 571; assertion();
				}
			}

			State = 574; Match(TSemicolon);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CallRequestContext : ParserRuleContext {
		public IdentifierContext portName;
		public IdentifierContext queryName;
		public ITerminalNode KRequest() { return GetToken(PilParser.KRequest, 0); }
		public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		public ITerminalNode TDot() { return GetToken(PilParser.TDot, 0); }
		public RequestArgumentsContext requestArguments() {
			return GetRuleContext<RequestArgumentsContext>(0);
		}
		public CallRequestContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_callRequest; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterCallRequest(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitCallRequest(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCallRequest(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CallRequestContext callRequest() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseCallRequest() : _DoParseCallRequest();
	}

	internal CallRequestContext _DoParseCallRequest() {
		CallRequestContext _localctx = new CallRequestContext(_ctx, State);
		EnterRule(_localctx, 92, RULE_callRequest);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 576; Match(KRequest);
			State = 577; _localctx.portName = identifier();
			State = 580;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==TDot) {
				{
				State = 578; Match(TDot);
				State = 579; _localctx.queryName = identifier();
				}
			}

			State = 583;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==TOpenParen) {
				{
				State = 582; requestArguments();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RequestArgumentsContext : ParserRuleContext {
		public ITerminalNode TOpenParen() { return GetToken(PilParser.TOpenParen, 0); }
		public ITerminalNode TCloseParen() { return GetToken(PilParser.TCloseParen, 0); }
		public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public RequestArgumentsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_requestArguments; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterRequestArguments(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitRequestArguments(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRequestArguments(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RequestArgumentsContext requestArguments() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseRequestArguments() : _DoParseRequestArguments();
	}

	internal RequestArgumentsContext _DoParseRequestArguments() {
		RequestArgumentsContext _localctx = new RequestArgumentsContext(_ctx, State);
		EnterRule(_localctx, 94, RULE_requestArguments);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 585; Match(TOpenParen);
			State = 587;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (((((_la - 31)) & ~0x3f) == 0 && ((1L << (_la - 31)) & ((1L << (KTrue - 31)) | (1L << (KFalse - 31)) | (1L << (KNull - 31)) | (1L << (TOpenParen - 31)) | (1L << (TMinus - 31)) | (1L << (TExclamation - 31)) | (1L << (LIdentifier - 31)) | (1L << (LInteger - 31)))) != 0)) {
				{
				State = 586; expressionList();
				}
			}

			State = 589; Match(TCloseParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ResponseStatementContext : ParserRuleContext {
		public ResponseStatementKindContext responseStatementKind() {
			return GetRuleContext<ResponseStatementKindContext>(0);
		}
		public ITerminalNode TSemicolon() { return GetToken(PilParser.TSemicolon, 0); }
		public AssertionContext assertion() {
			return GetRuleContext<AssertionContext>(0);
		}
		public ResponseStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_responseStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterResponseStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitResponseStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitResponseStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ResponseStatementContext responseStatement() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseResponseStatement() : _DoParseResponseStatement();
	}

	internal ResponseStatementContext _DoParseResponseStatement() {
		ResponseStatementContext _localctx = new ResponseStatementContext(_ctx, State);
		EnterRule(_localctx, 96, RULE_responseStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 591; responseStatementKind();
			State = 593;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==TColon) {
				{
				State = 592; assertion();
				}
			}

			State = 595; Match(TSemicolon);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CancelStatementContext : ParserRuleContext {
		public IdentifierContext portName;
		public CancelStatementKindContext cancelStatementKind() {
			return GetRuleContext<CancelStatementKindContext>(0);
		}
		public ITerminalNode TSemicolon() { return GetToken(PilParser.TSemicolon, 0); }
		public AssertionContext assertion() {
			return GetRuleContext<AssertionContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public CancelStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cancelStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterCancelStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitCancelStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCancelStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CancelStatementContext cancelStatement() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseCancelStatement() : _DoParseCancelStatement();
	}

	internal CancelStatementContext _DoParseCancelStatement() {
		CancelStatementContext _localctx = new CancelStatementContext(_ctx, State);
		EnterRule(_localctx, 98, RULE_cancelStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 597; cancelStatementKind();
			State = 599;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 598; _localctx.portName = identifier();
				}
			}

			State = 602;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==TColon) {
				{
				State = 601; assertion();
				}
			}

			State = 604; Match(TSemicolon);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssertionContext : ParserRuleContext {
		public ITerminalNode TColon() { return GetToken(PilParser.TColon, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public CommentContext comment() {
			return GetRuleContext<CommentContext>(0);
		}
		public AssertionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assertion; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterAssertion(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitAssertion(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssertion(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssertionContext assertion() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseAssertion() : _DoParseAssertion();
	}

	internal AssertionContext _DoParseAssertion() {
		AssertionContext _localctx = new AssertionContext(_ctx, State);
		EnterRule(_localctx, 100, RULE_assertion);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 606; Match(TColon);
			State = 608;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (((((_la - 31)) & ~0x3f) == 0 && ((1L << (_la - 31)) & ((1L << (KTrue - 31)) | (1L << (KFalse - 31)) | (1L << (KNull - 31)) | (1L << (TOpenParen - 31)) | (1L << (TMinus - 31)) | (1L << (TExclamation - 31)) | (1L << (LIdentifier - 31)) | (1L << (LInteger - 31)))) != 0)) {
				{
				State = 607; expression();
				}
			}

			State = 611;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LString) {
				{
				State = 610; comment();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ResponseStatementKindContext : ParserRuleContext {
		public ITerminalNode KAccept() { return GetToken(PilParser.KAccept, 0); }
		public ITerminalNode KRefuse() { return GetToken(PilParser.KRefuse, 0); }
		public ResponseStatementKindContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_responseStatementKind; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterResponseStatementKind(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitResponseStatementKind(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitResponseStatementKind(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ResponseStatementKindContext responseStatementKind() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseResponseStatementKind() : _DoParseResponseStatementKind();
	}

	internal ResponseStatementKindContext _DoParseResponseStatementKind() {
		ResponseStatementKindContext _localctx = new ResponseStatementKindContext(_ctx, State);
		EnterRule(_localctx, 102, RULE_responseStatementKind);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 613;
			_la = _input.La(1);
			if ( !(_la==KAccept || _la==KRefuse) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CancelStatementKindContext : ParserRuleContext {
		public ITerminalNode KCancel() { return GetToken(PilParser.KCancel, 0); }
		public CancelStatementKindContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cancelStatementKind; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterCancelStatementKind(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitCancelStatementKind(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCancelStatementKind(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CancelStatementKindContext cancelStatementKind() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseCancelStatementKind() : _DoParseCancelStatementKind();
	}

	internal CancelStatementKindContext _DoParseCancelStatementKind() {
		CancelStatementKindContext _localctx = new CancelStatementKindContext(_ctx, State);
		EnterRule(_localctx, 104, RULE_cancelStatementKind);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 615; Match(KCancel);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForkRequestStatementContext : ParserRuleContext {
		public ITerminalNode KFork() { return GetToken(PilParser.KFork, 0); }
		public ForkRequestVariableContext forkRequestVariable() {
			return GetRuleContext<ForkRequestVariableContext>(0);
		}
		public ITerminalNode KEndFork() { return GetToken(PilParser.KEndFork, 0); }
		public AcceptBranchContext acceptBranch() {
			return GetRuleContext<AcceptBranchContext>(0);
		}
		public RefuseBranchContext refuseBranch() {
			return GetRuleContext<RefuseBranchContext>(0);
		}
		public CancelBranchContext cancelBranch() {
			return GetRuleContext<CancelBranchContext>(0);
		}
		public ForkRequestStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forkRequestStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterForkRequestStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitForkRequestStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForkRequestStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ForkRequestStatementContext forkRequestStatement() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseForkRequestStatement() : _DoParseForkRequestStatement();
	}

	internal ForkRequestStatementContext _DoParseForkRequestStatement() {
		ForkRequestStatementContext _localctx = new ForkRequestStatementContext(_ctx, State);
		EnterRule(_localctx, 106, RULE_forkRequestStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 617; Match(KFork);
			State = 618; forkRequestVariable();
			State = 620;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,65,_ctx) ) {
			case 1:
				{
				State = 619; acceptBranch();
				}
				break;
			}
			State = 623;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,66,_ctx) ) {
			case 1:
				{
				State = 622; refuseBranch();
				}
				break;
			}
			State = 626;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==KCase) {
				{
				State = 625; cancelBranch();
				}
			}

			State = 628; Match(KEndFork);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForkRequestVariableContext : ParserRuleContext {
		public ForkRequestIdentifierContext forkRequestIdentifier() {
			return GetRuleContext<ForkRequestIdentifierContext>(0);
		}
		public RequestStatementContext requestStatement() {
			return GetRuleContext<RequestStatementContext>(0);
		}
		public ForkRequestVariableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forkRequestVariable; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterForkRequestVariable(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitForkRequestVariable(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForkRequestVariable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ForkRequestVariableContext forkRequestVariable() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseForkRequestVariable() : _DoParseForkRequestVariable();
	}

	internal ForkRequestVariableContext _DoParseForkRequestVariable() {
		ForkRequestVariableContext _localctx = new ForkRequestVariableContext(_ctx, State);
		EnterRule(_localctx, 108, RULE_forkRequestVariable);
		try {
			State = 632;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,68,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 630; forkRequestIdentifier();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 631; requestStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForkRequestIdentifierContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode TSemicolon() { return GetToken(PilParser.TSemicolon, 0); }
		public ForkRequestIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_forkRequestIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterForkRequestIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitForkRequestIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForkRequestIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ForkRequestIdentifierContext forkRequestIdentifier() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseForkRequestIdentifier() : _DoParseForkRequestIdentifier();
	}

	internal ForkRequestIdentifierContext _DoParseForkRequestIdentifier() {
		ForkRequestIdentifierContext _localctx = new ForkRequestIdentifierContext(_ctx, State);
		EnterRule(_localctx, 110, RULE_forkRequestIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 634; identifier();
			State = 635; Match(TSemicolon);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AcceptBranchContext : ParserRuleContext {
		public ExpressionContext condition;
		public ITerminalNode KCase() { return GetToken(PilParser.KCase, 0); }
		public ITerminalNode KAccept() { return GetToken(PilParser.KAccept, 0); }
		public ITerminalNode TSemicolon() { return GetToken(PilParser.TSemicolon, 0); }
		public CommentContext comment() {
			return GetRuleContext<CommentContext>(0);
		}
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public AcceptBranchContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_acceptBranch; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterAcceptBranch(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitAcceptBranch(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAcceptBranch(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AcceptBranchContext acceptBranch() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseAcceptBranch() : _DoParseAcceptBranch();
	}

	internal AcceptBranchContext _DoParseAcceptBranch() {
		AcceptBranchContext _localctx = new AcceptBranchContext(_ctx, State);
		EnterRule(_localctx, 112, RULE_acceptBranch);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 637; Match(KCase);
			State = 638; Match(KAccept);
			State = 640;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (((((_la - 31)) & ~0x3f) == 0 && ((1L << (_la - 31)) & ((1L << (KTrue - 31)) | (1L << (KFalse - 31)) | (1L << (KNull - 31)) | (1L << (TOpenParen - 31)) | (1L << (TMinus - 31)) | (1L << (TExclamation - 31)) | (1L << (LIdentifier - 31)) | (1L << (LInteger - 31)))) != 0)) {
				{
				State = 639; _localctx.condition = expression();
				}
			}

			State = 643;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LString) {
				{
				State = 642; comment();
				}
			}

			State = 645; Match(TSemicolon);
			State = 647;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,71,_ctx) ) {
			case 1:
				{
				State = 646; statements();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RefuseBranchContext : ParserRuleContext {
		public ExpressionContext condition;
		public ITerminalNode KCase() { return GetToken(PilParser.KCase, 0); }
		public ITerminalNode KRefuse() { return GetToken(PilParser.KRefuse, 0); }
		public ITerminalNode TSemicolon() { return GetToken(PilParser.TSemicolon, 0); }
		public CommentContext comment() {
			return GetRuleContext<CommentContext>(0);
		}
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public RefuseBranchContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_refuseBranch; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterRefuseBranch(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitRefuseBranch(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRefuseBranch(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RefuseBranchContext refuseBranch() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseRefuseBranch() : _DoParseRefuseBranch();
	}

	internal RefuseBranchContext _DoParseRefuseBranch() {
		RefuseBranchContext _localctx = new RefuseBranchContext(_ctx, State);
		EnterRule(_localctx, 114, RULE_refuseBranch);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 649; Match(KCase);
			State = 650; Match(KRefuse);
			State = 652;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (((((_la - 31)) & ~0x3f) == 0 && ((1L << (_la - 31)) & ((1L << (KTrue - 31)) | (1L << (KFalse - 31)) | (1L << (KNull - 31)) | (1L << (TOpenParen - 31)) | (1L << (TMinus - 31)) | (1L << (TExclamation - 31)) | (1L << (LIdentifier - 31)) | (1L << (LInteger - 31)))) != 0)) {
				{
				State = 651; _localctx.condition = expression();
				}
			}

			State = 655;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LString) {
				{
				State = 654; comment();
				}
			}

			State = 657; Match(TSemicolon);
			State = 659;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,74,_ctx) ) {
			case 1:
				{
				State = 658; statements();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CancelBranchContext : ParserRuleContext {
		public ExpressionContext condition;
		public ITerminalNode KCase() { return GetToken(PilParser.KCase, 0); }
		public ITerminalNode KCancel() { return GetToken(PilParser.KCancel, 0); }
		public ITerminalNode TSemicolon() { return GetToken(PilParser.TSemicolon, 0); }
		public CommentContext comment() {
			return GetRuleContext<CommentContext>(0);
		}
		public StatementsContext statements() {
			return GetRuleContext<StatementsContext>(0);
		}
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public CancelBranchContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_cancelBranch; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterCancelBranch(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitCancelBranch(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCancelBranch(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CancelBranchContext cancelBranch() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseCancelBranch() : _DoParseCancelBranch();
	}

	internal CancelBranchContext _DoParseCancelBranch() {
		CancelBranchContext _localctx = new CancelBranchContext(_ctx, State);
		EnterRule(_localctx, 116, RULE_cancelBranch);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 661; Match(KCase);
			State = 662; Match(KCancel);
			State = 664;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (((((_la - 31)) & ~0x3f) == 0 && ((1L << (_la - 31)) & ((1L << (KTrue - 31)) | (1L << (KFalse - 31)) | (1L << (KNull - 31)) | (1L << (TOpenParen - 31)) | (1L << (TMinus - 31)) | (1L << (TExclamation - 31)) | (1L << (LIdentifier - 31)) | (1L << (LInteger - 31)))) != 0)) {
				{
				State = 663; _localctx.condition = expression();
				}
			}

			State = 667;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LString) {
				{
				State = 666; comment();
				}
			}

			State = 669; Match(TSemicolon);
			State = 671;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,77,_ctx) ) {
			case 1:
				{
				State = 670; statements();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariableDeclarationStatementContext : ParserRuleContext {
		public VariableDeclarationContext variableDeclaration() {
			return GetRuleContext<VariableDeclarationContext>(0);
		}
		public VariableDeclarationStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variableDeclarationStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterVariableDeclarationStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitVariableDeclarationStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariableDeclarationStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VariableDeclarationStatementContext variableDeclarationStatement() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseVariableDeclarationStatement() : _DoParseVariableDeclarationStatement();
	}

	internal VariableDeclarationStatementContext _DoParseVariableDeclarationStatement() {
		VariableDeclarationStatementContext _localctx = new VariableDeclarationStatementContext(_ctx, State);
		EnterRule(_localctx, 118, RULE_variableDeclarationStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 673; variableDeclaration();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariableDeclarationContext : ParserRuleContext {
		public ITerminalNode KVar() { return GetToken(PilParser.KVar, 0); }
		public NameContext name() {
			return GetRuleContext<NameContext>(0);
		}
		public ITerminalNode TColon() { return GetToken(PilParser.TColon, 0); }
		public TypeReferenceContext typeReference() {
			return GetRuleContext<TypeReferenceContext>(0);
		}
		public ITerminalNode TSemicolon() { return GetToken(PilParser.TSemicolon, 0); }
		public ITerminalNode TAssign() { return GetToken(PilParser.TAssign, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public VariableDeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variableDeclaration; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterVariableDeclaration(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitVariableDeclaration(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariableDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VariableDeclarationContext variableDeclaration() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseVariableDeclaration() : _DoParseVariableDeclaration();
	}

	internal VariableDeclarationContext _DoParseVariableDeclaration() {
		VariableDeclarationContext _localctx = new VariableDeclarationContext(_ctx, State);
		EnterRule(_localctx, 120, RULE_variableDeclaration);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 675; Match(KVar);
			State = 676; name();
			State = 677; Match(TColon);
			State = 678; typeReference();
			State = 681;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==TAssign) {
				{
				State = 679; Match(TAssign);
				State = 680; expression();
				}
			}

			State = 683; Match(TSemicolon);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AssignmentStatementContext : ParserRuleContext {
		public ExpressionContext value;
		public LeftSideContext leftSide() {
			return GetRuleContext<LeftSideContext>(0);
		}
		public ITerminalNode TAssign() { return GetToken(PilParser.TAssign, 0); }
		public ITerminalNode TSemicolon() { return GetToken(PilParser.TSemicolon, 0); }
		public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public AssignmentStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_assignmentStatement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterAssignmentStatement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitAssignmentStatement(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAssignmentStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AssignmentStatementContext assignmentStatement() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseAssignmentStatement() : _DoParseAssignmentStatement();
	}

	internal AssignmentStatementContext _DoParseAssignmentStatement() {
		AssignmentStatementContext _localctx = new AssignmentStatementContext(_ctx, State);
		EnterRule(_localctx, 122, RULE_assignmentStatement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 685; leftSide();
			State = 686; Match(TAssign);
			State = 687; _localctx.value = expression();
			State = 688; Match(TSemicolon);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LeftSideContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ResultIdentifierContext resultIdentifier() {
			return GetRuleContext<ResultIdentifierContext>(0);
		}
		public LeftSideContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_leftSide; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterLeftSide(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitLeftSide(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLeftSide(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LeftSideContext leftSide() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseLeftSide() : _DoParseLeftSide();
	}

	internal LeftSideContext _DoParseLeftSide() {
		LeftSideContext _localctx = new LeftSideContext(_ctx, State);
		EnterRule(_localctx, 124, RULE_leftSide);
		try {
			State = 692;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case LIdentifier:
				EnterOuterAlt(_localctx, 1);
				{
				State = 690; identifier();
				}
				break;
			case KResult:
				EnterOuterAlt(_localctx, 2);
				{
				State = 691; resultIdentifier();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionListContext : ParserRuleContext {
		public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public ITerminalNode[] TComma() { return GetTokens(PilParser.TComma); }
		public ITerminalNode TComma(int i) {
			return GetToken(PilParser.TComma, i);
		}
		public ExpressionListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expressionList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterExpressionList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitExpressionList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpressionList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionListContext expressionList() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseExpressionList() : _DoParseExpressionList();
	}

	internal ExpressionListContext _DoParseExpressionList() {
		ExpressionListContext _localctx = new ExpressionListContext(_ctx, State);
		EnterRule(_localctx, 126, RULE_expressionList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 694; expression();
			State = 699;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==TComma) {
				{
				{
				State = 695; Match(TComma);
				State = 696; expression();
				}
				}
				State = 701;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		public ArithmeticExpressionContext arithmeticExpression() {
			return GetRuleContext<ArithmeticExpressionContext>(0);
		}
		public ConditionalExpressionContext conditionalExpression() {
			return GetRuleContext<ConditionalExpressionContext>(0);
		}
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseExpression() : _DoParseExpression();
	}

	internal ExpressionContext _DoParseExpression() {
		ExpressionContext _localctx = new ExpressionContext(_ctx, State);
		EnterRule(_localctx, 128, RULE_expression);
		try {
			State = 704;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,81,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 702; arithmeticExpression(0);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 703; conditionalExpression(0);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArithmeticExpressionContext : ParserRuleContext {
		public ArithmeticExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arithmeticExpression; } }
	 
		public ArithmeticExpressionContext() { }
		public virtual void CopyFrom(ArithmeticExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class MulDivExpressionContext : ArithmeticExpressionContext {
		public ArithmeticExpressionContext left;
		public ArithmeticExpressionContext right;
		public OpMulDivContext opMulDiv() {
			return GetRuleContext<OpMulDivContext>(0);
		}
		public ArithmeticExpressionContext[] arithmeticExpression() {
			return GetRuleContexts<ArithmeticExpressionContext>();
		}
		public ArithmeticExpressionContext arithmeticExpression(int i) {
			return GetRuleContext<ArithmeticExpressionContext>(i);
		}
		public MulDivExpressionContext(ArithmeticExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterMulDivExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitMulDivExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMulDivExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PlusMinusExpressionContext : ArithmeticExpressionContext {
		public ArithmeticExpressionContext left;
		public ArithmeticExpressionContext right;
		public OpAddSubContext opAddSub() {
			return GetRuleContext<OpAddSubContext>(0);
		}
		public ArithmeticExpressionContext[] arithmeticExpression() {
			return GetRuleContexts<ArithmeticExpressionContext>();
		}
		public ArithmeticExpressionContext arithmeticExpression(int i) {
			return GetRuleContext<ArithmeticExpressionContext>(i);
		}
		public PlusMinusExpressionContext(ArithmeticExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterPlusMinusExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitPlusMinusExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPlusMinusExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NegateExpressionContext : ArithmeticExpressionContext {
		public OpMinusContext opMinus() {
			return GetRuleContext<OpMinusContext>(0);
		}
		public ArithmeticExpressionTerminatorContext arithmeticExpressionTerminator() {
			return GetRuleContext<ArithmeticExpressionTerminatorContext>(0);
		}
		public NegateExpressionContext(ArithmeticExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterNegateExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitNegateExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNegateExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SimpleArithmeticExpressionContext : ArithmeticExpressionContext {
		public ArithmeticExpressionTerminatorContext arithmeticExpressionTerminator() {
			return GetRuleContext<ArithmeticExpressionTerminatorContext>(0);
		}
		public SimpleArithmeticExpressionContext(ArithmeticExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterSimpleArithmeticExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitSimpleArithmeticExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleArithmeticExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArithmeticExpressionContext arithmeticExpression() {
		return arithmeticExpression(0);
	}

	private ArithmeticExpressionContext arithmeticExpression(int _p) {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseArithmeticExpression(_p) : _DoParseArithmeticExpression(_p);
	}

	internal ArithmeticExpressionContext _DoParseArithmeticExpression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		ArithmeticExpressionContext _localctx = new ArithmeticExpressionContext(_ctx, _parentState);
		ArithmeticExpressionContext _prevctx = _localctx;
		int _startState = 130;
		EnterRecursionRule(_localctx, 130, RULE_arithmeticExpression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 711;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case TMinus:
				{
				_localctx = new NegateExpressionContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;

				State = 707; opMinus();
				State = 708; arithmeticExpressionTerminator();
				}
				break;
			case KTrue:
			case KFalse:
			case KNull:
			case TOpenParen:
			case LIdentifier:
			case LInteger:
				{
				_localctx = new SimpleArithmeticExpressionContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 710; arithmeticExpressionTerminator();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			_ctx.stop = _input.Lt(-1);
			State = 723;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,84,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 721;
					_errHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(_input,83,_ctx) ) {
					case 1:
						{
						_localctx = new MulDivExpressionContext(new ArithmeticExpressionContext(_parentctx, _parentState));
						((MulDivExpressionContext)_localctx).left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_arithmeticExpression);
						State = 713;
						if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
						State = 714; opMulDiv();
						State = 715; ((MulDivExpressionContext)_localctx).right = arithmeticExpression(5);
						}
						break;

					case 2:
						{
						_localctx = new PlusMinusExpressionContext(new ArithmeticExpressionContext(_parentctx, _parentState));
						((PlusMinusExpressionContext)_localctx).left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_arithmeticExpression);
						State = 717;
						if (!(Precpred(_ctx, 3))) throw new FailedPredicateException(this, "Precpred(_ctx, 3)");
						State = 718; opAddSub();
						State = 719; ((PlusMinusExpressionContext)_localctx).right = arithmeticExpression(4);
						}
						break;
					}
					} 
				}
				State = 725;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,84,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class OpMulDivContext : ParserRuleContext {
		public ITerminalNode TAsterisk() { return GetToken(PilParser.TAsterisk, 0); }
		public ITerminalNode TSlash() { return GetToken(PilParser.TSlash, 0); }
		public OpMulDivContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_opMulDiv; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterOpMulDiv(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitOpMulDiv(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpMulDiv(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OpMulDivContext opMulDiv() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseOpMulDiv() : _DoParseOpMulDiv();
	}

	internal OpMulDivContext _DoParseOpMulDiv() {
		OpMulDivContext _localctx = new OpMulDivContext(_ctx, State);
		EnterRule(_localctx, 132, RULE_opMulDiv);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 726;
			_la = _input.La(1);
			if ( !(_la==TSlash || _la==TAsterisk) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OpAddSubContext : ParserRuleContext {
		public ITerminalNode TPlus() { return GetToken(PilParser.TPlus, 0); }
		public ITerminalNode TMinus() { return GetToken(PilParser.TMinus, 0); }
		public OpAddSubContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_opAddSub; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterOpAddSub(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitOpAddSub(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpAddSub(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OpAddSubContext opAddSub() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseOpAddSub() : _DoParseOpAddSub();
	}

	internal OpAddSubContext _DoParseOpAddSub() {
		OpAddSubContext _localctx = new OpAddSubContext(_ctx, State);
		EnterRule(_localctx, 134, RULE_opAddSub);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 728;
			_la = _input.La(1);
			if ( !(_la==TPlus || _la==TMinus) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArithmeticExpressionTerminatorContext : ParserRuleContext {
		public ArithmeticExpressionTerminatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arithmeticExpressionTerminator; } }
	 
		public ArithmeticExpressionTerminatorContext() { }
		public virtual void CopyFrom(ArithmeticExpressionTerminatorContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ParenArithmeticExpressionContext : ArithmeticExpressionTerminatorContext {
		public ITerminalNode TOpenParen() { return GetToken(PilParser.TOpenParen, 0); }
		public ArithmeticExpressionContext arithmeticExpression() {
			return GetRuleContext<ArithmeticExpressionContext>(0);
		}
		public ITerminalNode TCloseParen() { return GetToken(PilParser.TCloseParen, 0); }
		public ParenArithmeticExpressionContext(ArithmeticExpressionTerminatorContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterParenArithmeticExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitParenArithmeticExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenArithmeticExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TerminalArithmeticExpressionContext : ArithmeticExpressionTerminatorContext {
		public TerminalExpressionContext terminalExpression() {
			return GetRuleContext<TerminalExpressionContext>(0);
		}
		public TerminalArithmeticExpressionContext(ArithmeticExpressionTerminatorContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterTerminalArithmeticExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitTerminalArithmeticExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTerminalArithmeticExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArithmeticExpressionTerminatorContext arithmeticExpressionTerminator() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseArithmeticExpressionTerminator() : _DoParseArithmeticExpressionTerminator();
	}

	internal ArithmeticExpressionTerminatorContext _DoParseArithmeticExpressionTerminator() {
		ArithmeticExpressionTerminatorContext _localctx = new ArithmeticExpressionTerminatorContext(_ctx, State);
		EnterRule(_localctx, 136, RULE_arithmeticExpressionTerminator);
		try {
			State = 735;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case TOpenParen:
				_localctx = new ParenArithmeticExpressionContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 730; Match(TOpenParen);
				State = 731; arithmeticExpression(0);
				State = 732; Match(TCloseParen);
				}
				break;
			case KTrue:
			case KFalse:
			case KNull:
			case LIdentifier:
			case LInteger:
				_localctx = new TerminalArithmeticExpressionContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 734; terminalExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OpMinusContext : ParserRuleContext {
		public ITerminalNode TMinus() { return GetToken(PilParser.TMinus, 0); }
		public OpMinusContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_opMinus; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterOpMinus(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitOpMinus(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpMinus(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OpMinusContext opMinus() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseOpMinus() : _DoParseOpMinus();
	}

	internal OpMinusContext _DoParseOpMinus() {
		OpMinusContext _localctx = new OpMinusContext(_ctx, State);
		EnterRule(_localctx, 138, RULE_opMinus);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 737; Match(TMinus);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionalExpressionContext : ParserRuleContext {
		public ConditionalExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditionalExpression; } }
	 
		public ConditionalExpressionContext() { }
		public virtual void CopyFrom(ConditionalExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class AndExpressionContext : ConditionalExpressionContext {
		public ConditionalExpressionContext left;
		public ConditionalExpressionContext right;
		public AndAlsoOpContext andAlsoOp() {
			return GetRuleContext<AndAlsoOpContext>(0);
		}
		public ConditionalExpressionContext[] conditionalExpression() {
			return GetRuleContexts<ConditionalExpressionContext>();
		}
		public ConditionalExpressionContext conditionalExpression(int i) {
			return GetRuleContext<ConditionalExpressionContext>(i);
		}
		public AndExpressionContext(ConditionalExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterAndExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitAndExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAndExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OrExpressionContext : ConditionalExpressionContext {
		public ConditionalExpressionContext left;
		public ConditionalExpressionContext right;
		public OrElseOpContext orElseOp() {
			return GetRuleContext<OrElseOpContext>(0);
		}
		public ConditionalExpressionContext[] conditionalExpression() {
			return GetRuleContexts<ConditionalExpressionContext>();
		}
		public ConditionalExpressionContext conditionalExpression(int i) {
			return GetRuleContext<ConditionalExpressionContext>(i);
		}
		public OrExpressionContext(ConditionalExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterOrExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitOrExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOrExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NotExpressionContext : ConditionalExpressionContext {
		public OpExclContext opExcl() {
			return GetRuleContext<OpExclContext>(0);
		}
		public ConditionalExpressionTerminatorContext conditionalExpressionTerminator() {
			return GetRuleContext<ConditionalExpressionTerminatorContext>(0);
		}
		public NotExpressionContext(ConditionalExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterNotExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitNotExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNotExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SimpleConditionalExpressionContext : ConditionalExpressionContext {
		public ConditionalExpressionTerminatorContext conditionalExpressionTerminator() {
			return GetRuleContext<ConditionalExpressionTerminatorContext>(0);
		}
		public SimpleConditionalExpressionContext(ConditionalExpressionContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterSimpleConditionalExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitSimpleConditionalExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimpleConditionalExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConditionalExpressionContext conditionalExpression() {
		return conditionalExpression(0);
	}

	private ConditionalExpressionContext conditionalExpression(int _p) {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseConditionalExpression(_p) : _DoParseConditionalExpression(_p);
	}

	internal ConditionalExpressionContext _DoParseConditionalExpression(int _p) {
		ParserRuleContext _parentctx = _ctx;
		int _parentState = State;
		ConditionalExpressionContext _localctx = new ConditionalExpressionContext(_ctx, _parentState);
		ConditionalExpressionContext _prevctx = _localctx;
		int _startState = 140;
		EnterRecursionRule(_localctx, 140, RULE_conditionalExpression, _p);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 744;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case TExclamation:
				{
				_localctx = new NotExpressionContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;

				State = 740; opExcl();
				State = 741; conditionalExpressionTerminator();
				}
				break;
			case KTrue:
			case KFalse:
			case KNull:
			case TOpenParen:
			case TMinus:
			case LIdentifier:
			case LInteger:
				{
				_localctx = new SimpleConditionalExpressionContext(_localctx);
				_ctx = _localctx;
				_prevctx = _localctx;
				State = 743; conditionalExpressionTerminator();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			_ctx.stop = _input.Lt(-1);
			State = 756;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,88,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					if ( _parseListeners!=null ) TriggerExitRuleEvent();
					_prevctx = _localctx;
					{
					State = 754;
					_errHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(_input,87,_ctx) ) {
					case 1:
						{
						_localctx = new AndExpressionContext(new ConditionalExpressionContext(_parentctx, _parentState));
						((AndExpressionContext)_localctx).left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_conditionalExpression);
						State = 746;
						if (!(Precpred(_ctx, 4))) throw new FailedPredicateException(this, "Precpred(_ctx, 4)");
						State = 747; andAlsoOp();
						State = 748; ((AndExpressionContext)_localctx).right = conditionalExpression(5);
						}
						break;

					case 2:
						{
						_localctx = new OrExpressionContext(new ConditionalExpressionContext(_parentctx, _parentState));
						((OrExpressionContext)_localctx).left = _prevctx;
						PushNewRecursionContext(_localctx, _startState, RULE_conditionalExpression);
						State = 750;
						if (!(Precpred(_ctx, 3))) throw new FailedPredicateException(this, "Precpred(_ctx, 3)");
						State = 751; orElseOp();
						State = 752; ((OrExpressionContext)_localctx).right = conditionalExpression(4);
						}
						break;
					}
					} 
				}
				State = 758;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,88,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			UnrollRecursionContexts(_parentctx);
		}
		return _localctx;
	}

	public partial class AndAlsoOpContext : ParserRuleContext {
		public ITerminalNode TAndAlso() { return GetToken(PilParser.TAndAlso, 0); }
		public AndAlsoOpContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_andAlsoOp; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterAndAlsoOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitAndAlsoOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAndAlsoOp(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AndAlsoOpContext andAlsoOp() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseAndAlsoOp() : _DoParseAndAlsoOp();
	}

	internal AndAlsoOpContext _DoParseAndAlsoOp() {
		AndAlsoOpContext _localctx = new AndAlsoOpContext(_ctx, State);
		EnterRule(_localctx, 142, RULE_andAlsoOp);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 759; Match(TAndAlso);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OrElseOpContext : ParserRuleContext {
		public ITerminalNode TOrElse() { return GetToken(PilParser.TOrElse, 0); }
		public OrElseOpContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_orElseOp; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterOrElseOp(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitOrElseOp(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOrElseOp(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OrElseOpContext orElseOp() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseOrElseOp() : _DoParseOrElseOp();
	}

	internal OrElseOpContext _DoParseOrElseOp() {
		OrElseOpContext _localctx = new OrElseOpContext(_ctx, State);
		EnterRule(_localctx, 144, RULE_orElseOp);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 761; Match(TOrElse);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OpExclContext : ParserRuleContext {
		public ITerminalNode TExclamation() { return GetToken(PilParser.TExclamation, 0); }
		public OpExclContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_opExcl; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterOpExcl(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitOpExcl(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpExcl(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OpExclContext opExcl() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseOpExcl() : _DoParseOpExcl();
	}

	internal OpExclContext _DoParseOpExcl() {
		OpExclContext _localctx = new OpExclContext(_ctx, State);
		EnterRule(_localctx, 146, RULE_opExcl);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 763; Match(TExclamation);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConditionalExpressionTerminatorContext : ParserRuleContext {
		public ConditionalExpressionTerminatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditionalExpressionTerminator; } }
	 
		public ConditionalExpressionTerminatorContext() { }
		public virtual void CopyFrom(ConditionalExpressionTerminatorContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ParenConditionalExpressionContext : ConditionalExpressionTerminatorContext {
		public ITerminalNode TOpenParen() { return GetToken(PilParser.TOpenParen, 0); }
		public ConditionalExpressionContext conditionalExpression() {
			return GetRuleContext<ConditionalExpressionContext>(0);
		}
		public ITerminalNode TCloseParen() { return GetToken(PilParser.TCloseParen, 0); }
		public ParenConditionalExpressionContext(ConditionalExpressionTerminatorContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterParenConditionalExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitParenConditionalExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenConditionalExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ElementOfConditionalExpressionContext : ConditionalExpressionTerminatorContext {
		public ElementOfExpressionContext elementOfExpression() {
			return GetRuleContext<ElementOfExpressionContext>(0);
		}
		public ElementOfConditionalExpressionContext(ConditionalExpressionTerminatorContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterElementOfConditionalExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitElementOfConditionalExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElementOfConditionalExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ComparisonConditionalExpressionContext : ConditionalExpressionTerminatorContext {
		public ComparisonExpressionContext comparisonExpression() {
			return GetRuleContext<ComparisonExpressionContext>(0);
		}
		public ComparisonConditionalExpressionContext(ConditionalExpressionTerminatorContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterComparisonConditionalExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitComparisonConditionalExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitComparisonConditionalExpression(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class TerminalComparisonExpressionContext : ConditionalExpressionTerminatorContext {
		public TerminalExpressionContext terminalExpression() {
			return GetRuleContext<TerminalExpressionContext>(0);
		}
		public TerminalComparisonExpressionContext(ConditionalExpressionTerminatorContext context) { CopyFrom(context); }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterTerminalComparisonExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitTerminalComparisonExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTerminalComparisonExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConditionalExpressionTerminatorContext conditionalExpressionTerminator() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseConditionalExpressionTerminator() : _DoParseConditionalExpressionTerminator();
	}

	internal ConditionalExpressionTerminatorContext _DoParseConditionalExpressionTerminator() {
		ConditionalExpressionTerminatorContext _localctx = new ConditionalExpressionTerminatorContext(_ctx, State);
		EnterRule(_localctx, 148, RULE_conditionalExpressionTerminator);
		try {
			State = 772;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,89,_ctx) ) {
			case 1:
				_localctx = new ParenConditionalExpressionContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 765; Match(TOpenParen);
				State = 766; conditionalExpression(0);
				State = 767; Match(TCloseParen);
				}
				break;

			case 2:
				_localctx = new ElementOfConditionalExpressionContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 769; elementOfExpression();
				}
				break;

			case 3:
				_localctx = new ComparisonConditionalExpressionContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 770; comparisonExpression();
				}
				break;

			case 4:
				_localctx = new TerminalComparisonExpressionContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 771; terminalExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComparisonExpressionContext : ParserRuleContext {
		public ArithmeticExpressionContext left;
		public ComparisonOperatorContext op;
		public ArithmeticExpressionContext right;
		public ArithmeticExpressionContext[] arithmeticExpression() {
			return GetRuleContexts<ArithmeticExpressionContext>();
		}
		public ArithmeticExpressionContext arithmeticExpression(int i) {
			return GetRuleContext<ArithmeticExpressionContext>(i);
		}
		public ComparisonOperatorContext comparisonOperator() {
			return GetRuleContext<ComparisonOperatorContext>(0);
		}
		public ComparisonExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_comparisonExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterComparisonExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitComparisonExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitComparisonExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ComparisonExpressionContext comparisonExpression() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseComparisonExpression() : _DoParseComparisonExpression();
	}

	internal ComparisonExpressionContext _DoParseComparisonExpression() {
		ComparisonExpressionContext _localctx = new ComparisonExpressionContext(_ctx, State);
		EnterRule(_localctx, 150, RULE_comparisonExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 774; _localctx.left = arithmeticExpression(0);
			State = 775; _localctx.op = comparisonOperator();
			State = 776; _localctx.right = arithmeticExpression(0);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComparisonOperatorContext : ParserRuleContext {
		public ITerminalNode TEqual() { return GetToken(PilParser.TEqual, 0); }
		public ITerminalNode TNotEqual() { return GetToken(PilParser.TNotEqual, 0); }
		public ITerminalNode TLessThan() { return GetToken(PilParser.TLessThan, 0); }
		public ITerminalNode TGreaterThan() { return GetToken(PilParser.TGreaterThan, 0); }
		public ITerminalNode TLessThanOrEqual() { return GetToken(PilParser.TLessThanOrEqual, 0); }
		public ITerminalNode TGreaterThanOrEqual() { return GetToken(PilParser.TGreaterThanOrEqual, 0); }
		public ComparisonOperatorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_comparisonOperator; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterComparisonOperator(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitComparisonOperator(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitComparisonOperator(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ComparisonOperatorContext comparisonOperator() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseComparisonOperator() : _DoParseComparisonOperator();
	}

	internal ComparisonOperatorContext _DoParseComparisonOperator() {
		ComparisonOperatorContext _localctx = new ComparisonOperatorContext(_ctx, State);
		EnterRule(_localctx, 152, RULE_comparisonOperator);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 778;
			_la = _input.La(1);
			if ( !(((((_la - 50)) & ~0x3f) == 0 && ((1L << (_la - 50)) & ((1L << (TLessThan - 50)) | (1L << (TGreaterThan - 50)) | (1L << (TLessThanOrEqual - 50)) | (1L << (TGreaterThanOrEqual - 50)) | (1L << (TEqual - 50)) | (1L << (TNotEqual - 50)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElementOfExpressionContext : ParserRuleContext {
		public TerminalExpressionContext terminalExpression() {
			return GetRuleContext<TerminalExpressionContext>(0);
		}
		public ITerminalNode KIn() { return GetToken(PilParser.KIn, 0); }
		public ITerminalNode TOpenBracket() { return GetToken(PilParser.TOpenBracket, 0); }
		public ITerminalNode TCloseBracket() { return GetToken(PilParser.TCloseBracket, 0); }
		public ElementOfValueListContext elementOfValueList() {
			return GetRuleContext<ElementOfValueListContext>(0);
		}
		public ElementOfExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elementOfExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterElementOfExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitElementOfExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElementOfExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElementOfExpressionContext elementOfExpression() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseElementOfExpression() : _DoParseElementOfExpression();
	}

	internal ElementOfExpressionContext _DoParseElementOfExpression() {
		ElementOfExpressionContext _localctx = new ElementOfExpressionContext(_ctx, State);
		EnterRule(_localctx, 154, RULE_elementOfExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 780; terminalExpression();
			State = 781; Match(KIn);
			State = 782; Match(TOpenBracket);
			State = 784;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==LIdentifier) {
				{
				State = 783; elementOfValueList();
				}
			}

			State = 786; Match(TCloseBracket);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElementOfValueListContext : ParserRuleContext {
		public ElementOfValueContext[] elementOfValue() {
			return GetRuleContexts<ElementOfValueContext>();
		}
		public ElementOfValueContext elementOfValue(int i) {
			return GetRuleContext<ElementOfValueContext>(i);
		}
		public ITerminalNode[] TComma() { return GetTokens(PilParser.TComma); }
		public ITerminalNode TComma(int i) {
			return GetToken(PilParser.TComma, i);
		}
		public ElementOfValueListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elementOfValueList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterElementOfValueList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitElementOfValueList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElementOfValueList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElementOfValueListContext elementOfValueList() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseElementOfValueList() : _DoParseElementOfValueList();
	}

	internal ElementOfValueListContext _DoParseElementOfValueList() {
		ElementOfValueListContext _localctx = new ElementOfValueListContext(_ctx, State);
		EnterRule(_localctx, 156, RULE_elementOfValueList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 788; elementOfValue();
			State = 793;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==TComma) {
				{
				{
				State = 789; Match(TComma);
				State = 790; elementOfValue();
				}
				}
				State = 795;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElementOfValueContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ElementOfValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elementOfValue; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterElementOfValue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitElementOfValue(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElementOfValue(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElementOfValueContext elementOfValue() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseElementOfValue() : _DoParseElementOfValue();
	}

	internal ElementOfValueContext _DoParseElementOfValue() {
		ElementOfValueContext _localctx = new ElementOfValueContext(_ctx, State);
		EnterRule(_localctx, 158, RULE_elementOfValue);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 796; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TerminalExpressionContext : ParserRuleContext {
		public VariableReferenceContext variableReference() {
			return GetRuleContext<VariableReferenceContext>(0);
		}
		public FunctionCallExpressionContext functionCallExpression() {
			return GetRuleContext<FunctionCallExpressionContext>(0);
		}
		public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public TerminalExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_terminalExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterTerminalExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitTerminalExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTerminalExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TerminalExpressionContext terminalExpression() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseTerminalExpression() : _DoParseTerminalExpression();
	}

	internal TerminalExpressionContext _DoParseTerminalExpression() {
		TerminalExpressionContext _localctx = new TerminalExpressionContext(_ctx, State);
		EnterRule(_localctx, 160, RULE_terminalExpression);
		try {
			State = 801;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,92,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 798; variableReference();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 799; functionCallExpression();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 800; literal();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionCallExpressionContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public ITerminalNode TOpenParen() { return GetToken(PilParser.TOpenParen, 0); }
		public ITerminalNode TCloseParen() { return GetToken(PilParser.TCloseParen, 0); }
		public ExpressionListContext expressionList() {
			return GetRuleContext<ExpressionListContext>(0);
		}
		public FunctionCallExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionCallExpression; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterFunctionCallExpression(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitFunctionCallExpression(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionCallExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionCallExpressionContext functionCallExpression() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseFunctionCallExpression() : _DoParseFunctionCallExpression();
	}

	internal FunctionCallExpressionContext _DoParseFunctionCallExpression() {
		FunctionCallExpressionContext _localctx = new FunctionCallExpressionContext(_ctx, State);
		EnterRule(_localctx, 162, RULE_functionCallExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 803; identifier();
			State = 804; Match(TOpenParen);
			State = 806;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (((((_la - 31)) & ~0x3f) == 0 && ((1L << (_la - 31)) & ((1L << (KTrue - 31)) | (1L << (KFalse - 31)) | (1L << (KNull - 31)) | (1L << (TOpenParen - 31)) | (1L << (TMinus - 31)) | (1L << (TExclamation - 31)) | (1L << (LIdentifier - 31)) | (1L << (LInteger - 31)))) != 0)) {
				{
				State = 805; expressionList();
				}
			}

			State = 808; Match(TCloseParen);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariableReferenceContext : ParserRuleContext {
		public VariableReferenceIdentifierContext[] variableReferenceIdentifier() {
			return GetRuleContexts<VariableReferenceIdentifierContext>();
		}
		public VariableReferenceIdentifierContext variableReferenceIdentifier(int i) {
			return GetRuleContext<VariableReferenceIdentifierContext>(i);
		}
		public ITerminalNode[] TDot() { return GetTokens(PilParser.TDot); }
		public ITerminalNode TDot(int i) {
			return GetToken(PilParser.TDot, i);
		}
		public VariableReferenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variableReference; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterVariableReference(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitVariableReference(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariableReference(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VariableReferenceContext variableReference() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseVariableReference() : _DoParseVariableReference();
	}

	internal VariableReferenceContext _DoParseVariableReference() {
		VariableReferenceContext _localctx = new VariableReferenceContext(_ctx, State);
		EnterRule(_localctx, 164, RULE_variableReference);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 810; variableReferenceIdentifier();
			State = 815;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,94,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 811; Match(TDot);
					State = 812; variableReferenceIdentifier();
					}
					} 
				}
				State = 817;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,94,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariableReferenceIdentifierContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public VariableReferenceIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variableReferenceIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterVariableReferenceIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitVariableReferenceIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariableReferenceIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VariableReferenceIdentifierContext variableReferenceIdentifier() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseVariableReferenceIdentifier() : _DoParseVariableReferenceIdentifier();
	}

	internal VariableReferenceIdentifierContext _DoParseVariableReferenceIdentifier() {
		VariableReferenceIdentifierContext _localctx = new VariableReferenceIdentifierContext(_ctx, State);
		EnterRule(_localctx, 166, RULE_variableReferenceIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 818; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CommentContext : ParserRuleContext {
		public ITerminalNode LString() { return GetToken(PilParser.LString, 0); }
		public CommentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_comment; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterComment(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitComment(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitComment(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CommentContext comment() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseComment() : _DoParseComment();
	}

	internal CommentContext _DoParseComment() {
		CommentContext _localctx = new CommentContext(_ctx, State);
		EnterRule(_localctx, 168, RULE_comment);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 820; Match(LString);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralContext : ParserRuleContext {
		public ITerminalNode LInteger() { return GetToken(PilParser.LInteger, 0); }
		public ITerminalNode KTrue() { return GetToken(PilParser.KTrue, 0); }
		public ITerminalNode KFalse() { return GetToken(PilParser.KFalse, 0); }
		public ITerminalNode KNull() { return GetToken(PilParser.KNull, 0); }
		public LiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literal; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterLiteral(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitLiteral(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralContext literal() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseLiteral() : _DoParseLiteral();
	}

	internal LiteralContext _DoParseLiteral() {
		LiteralContext _localctx = new LiteralContext(_ctx, State);
		EnterRule(_localctx, 170, RULE_literal);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 822;
			_la = _input.La(1);
			if ( !(((((_la - 31)) & ~0x3f) == 0 && ((1L << (_la - 31)) & ((1L << (KTrue - 31)) | (1L << (KFalse - 31)) | (1L << (KNull - 31)) | (1L << (LInteger - 31)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeReferenceContext : ParserRuleContext {
		public BuiltInTypeContext builtInType() {
			return GetRuleContext<BuiltInTypeContext>(0);
		}
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public TypeReferenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeReference; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterTypeReference(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitTypeReference(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeReference(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeReferenceContext typeReference() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseTypeReference() : _DoParseTypeReference();
	}

	internal TypeReferenceContext _DoParseTypeReference() {
		TypeReferenceContext _localctx = new TypeReferenceContext(_ctx, State);
		EnterRule(_localctx, 172, RULE_typeReference);
		try {
			State = 826;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case KInt:
			case KBool:
			case KString:
			case KObjectType:
				EnterOuterAlt(_localctx, 1);
				{
				State = 824; builtInType();
				}
				break;
			case LIdentifier:
				EnterOuterAlt(_localctx, 2);
				{
				State = 825; identifier();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BuiltInTypeContext : ParserRuleContext {
		public ITerminalNode KBool() { return GetToken(PilParser.KBool, 0); }
		public ITerminalNode KInt() { return GetToken(PilParser.KInt, 0); }
		public ITerminalNode KString() { return GetToken(PilParser.KString, 0); }
		public ITerminalNode KObjectType() { return GetToken(PilParser.KObjectType, 0); }
		public BuiltInTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_builtInType; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterBuiltInType(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitBuiltInType(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBuiltInType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BuiltInTypeContext builtInType() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseBuiltInType() : _DoParseBuiltInType();
	}

	internal BuiltInTypeContext _DoParseBuiltInType() {
		BuiltInTypeContext _localctx = new BuiltInTypeContext(_ctx, State);
		EnterRule(_localctx, 174, RULE_builtInType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 828;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << KInt) | (1L << KBool) | (1L << KString) | (1L << KObjectType))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QualifierListContext : ParserRuleContext {
		public QualifierContext[] qualifier() {
			return GetRuleContexts<QualifierContext>();
		}
		public QualifierContext qualifier(int i) {
			return GetRuleContext<QualifierContext>(i);
		}
		public ITerminalNode[] TComma() { return GetTokens(PilParser.TComma); }
		public ITerminalNode TComma(int i) {
			return GetToken(PilParser.TComma, i);
		}
		public QualifierListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_qualifierList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterQualifierList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitQualifierList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQualifierList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QualifierListContext qualifierList() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseQualifierList() : _DoParseQualifierList();
	}

	internal QualifierListContext _DoParseQualifierList() {
		QualifierListContext _localctx = new QualifierListContext(_ctx, State);
		EnterRule(_localctx, 176, RULE_qualifierList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 830; qualifier();
			State = 835;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==TComma) {
				{
				{
				State = 831; Match(TComma);
				State = 832; qualifier();
				}
				}
				State = 837;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QualifierContext : ParserRuleContext {
		public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		public ITerminalNode[] TDot() { return GetTokens(PilParser.TDot); }
		public ITerminalNode TDot(int i) {
			return GetToken(PilParser.TDot, i);
		}
		public QualifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_qualifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterQualifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitQualifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQualifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QualifierContext qualifier() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseQualifier() : _DoParseQualifier();
	}

	internal QualifierContext _DoParseQualifier() {
		QualifierContext _localctx = new QualifierContext(_ctx, State);
		EnterRule(_localctx, 178, RULE_qualifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 838; identifier();
			State = 843;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==TDot) {
				{
				{
				State = 839; Match(TDot);
				State = 840; identifier();
				}
				}
				State = 845;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NameContext : ParserRuleContext {
		public IdentifierContext identifier() {
			return GetRuleContext<IdentifierContext>(0);
		}
		public NameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_name; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitName(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NameContext name() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseName() : _DoParseName();
	}

	internal NameContext _DoParseName() {
		NameContext _localctx = new NameContext(_ctx, State);
		EnterRule(_localctx, 180, RULE_name);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 846; identifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierListContext : ParserRuleContext {
		public IdentifierContext[] identifier() {
			return GetRuleContexts<IdentifierContext>();
		}
		public IdentifierContext identifier(int i) {
			return GetRuleContext<IdentifierContext>(i);
		}
		public ITerminalNode[] TComma() { return GetTokens(PilParser.TComma); }
		public ITerminalNode TComma(int i) {
			return GetToken(PilParser.TComma, i);
		}
		public IdentifierListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifierList; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterIdentifierList(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitIdentifierList(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifierList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierListContext identifierList() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseIdentifierList() : _DoParseIdentifierList();
	}

	internal IdentifierListContext _DoParseIdentifierList() {
		IdentifierListContext _localctx = new IdentifierListContext(_ctx, State);
		EnterRule(_localctx, 182, RULE_identifierList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 848; identifier();
			State = 853;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==TComma) {
				{
				{
				State = 849; Match(TComma);
				State = 850; identifier();
				}
				}
				State = 855;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifierContext : ParserRuleContext {
		public ITerminalNode LIdentifier() { return GetToken(PilParser.LIdentifier, 0); }
		public IdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdentifierContext identifier() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseIdentifier() : _DoParseIdentifier();
	}

	internal IdentifierContext _DoParseIdentifier() {
		IdentifierContext _localctx = new IdentifierContext(_ctx, State);
		EnterRule(_localctx, 184, RULE_identifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 856; Match(LIdentifier);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ResultIdentifierContext : ParserRuleContext {
		public ITerminalNode KResult() { return GetToken(PilParser.KResult, 0); }
		public ResultIdentifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_resultIdentifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.EnterResultIdentifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPilParserListener typedListener = listener as IPilParserListener;
			if (typedListener != null) typedListener.ExitResultIdentifier(this);
		}
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IPilParserVisitor<TResult> typedVisitor = visitor as IPilParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitResultIdentifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ResultIdentifierContext resultIdentifier() {
		return this.SyntaxParser != null && this.SyntaxParser.IsIncremental ? this.SyntaxParser._Antlr4ParseResultIdentifier() : _DoParseResultIdentifier();
	}

	internal ResultIdentifierContext _DoParseResultIdentifier() {
		ResultIdentifierContext _localctx = new ResultIdentifierContext(_ctx, State);
		EnterRule(_localctx, 186, RULE_resultIdentifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 858; Match(KResult);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public override bool Sempred(RuleContext _localctx, int ruleIndex, int predIndex) {
		switch (ruleIndex) {
		case 65: return arithmeticExpression_sempred((ArithmeticExpressionContext)_localctx, predIndex);

		case 70: return conditionalExpression_sempred((ConditionalExpressionContext)_localctx, predIndex);
		}
		return true;
	}
	private bool arithmeticExpression_sempred(ArithmeticExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 0: return Precpred(_ctx, 4);

		case 1: return Precpred(_ctx, 3);
		}
		return true;
	}
	private bool conditionalExpression_sempred(ConditionalExpressionContext _localctx, int predIndex) {
		switch (predIndex) {
		case 2: return Precpred(_ctx, 4);

		case 3: return Precpred(_ctx, 3);
		}
		return true;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3^\x35F\x4\x2\t\x2"+
		"\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t\t"+
		"\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10\t"+
		"\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15"+
		"\x4\x16\t\x16\x4\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x4\x1B"+
		"\t\x1B\x4\x1C\t\x1C\x4\x1D\t\x1D\x4\x1E\t\x1E\x4\x1F\t\x1F\x4 \t \x4!"+
		"\t!\x4\"\t\"\x4#\t#\x4$\t$\x4%\t%\x4&\t&\x4\'\t\'\x4(\t(\x4)\t)\x4*\t"+
		"*\x4+\t+\x4,\t,\x4-\t-\x4.\t.\x4/\t/\x4\x30\t\x30\x4\x31\t\x31\x4\x32"+
		"\t\x32\x4\x33\t\x33\x4\x34\t\x34\x4\x35\t\x35\x4\x36\t\x36\x4\x37\t\x37"+
		"\x4\x38\t\x38\x4\x39\t\x39\x4:\t:\x4;\t;\x4<\t<\x4=\t=\x4>\t>\x4?\t?\x4"+
		"@\t@\x4\x41\t\x41\x4\x42\t\x42\x4\x43\t\x43\x4\x44\t\x44\x4\x45\t\x45"+
		"\x4\x46\t\x46\x4G\tG\x4H\tH\x4I\tI\x4J\tJ\x4K\tK\x4L\tL\x4M\tM\x4N\tN"+
		"\x4O\tO\x4P\tP\x4Q\tQ\x4R\tR\x4S\tS\x4T\tT\x4U\tU\x4V\tV\x4W\tW\x4X\t"+
		"X\x4Y\tY\x4Z\tZ\x4[\t[\x4\\\t\\\x4]\t]\x4^\t^\x4_\t_\x3\x2\a\x2\xC0\n"+
		"\x2\f\x2\xE\x2\xC3\v\x2\x3\x2\x3\x2\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3"+
		"\x5\x3\xCD\n\x3\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x3\x5\x3\x5\x3\x5"+
		"\x3\x5\x3\x5\x3\x5\x5\x5\xDB\n\x5\x3\x5\x3\x5\x3\x6\x3\x6\x3\x6\x3\x6"+
		"\x3\x6\x3\x6\x3\x6\x3\a\x3\a\x3\a\a\a\xE9\n\a\f\a\xE\a\xEC\v\a\x3\b\x3"+
		"\b\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\t\x3\n\x3\n\x3\n\x5\n\xFB\n\n"+
		"\x3\n\x3\n\x3\v\x3\v\x3\v\a\v\x102\n\v\f\v\xE\v\x105\v\v\x3\f\x3\f\x3"+
		"\r\a\r\x10A\n\r\f\r\xE\r\x10D\v\r\x3\xE\a\xE\x110\n\xE\f\xE\xE\xE\x113"+
		"\v\xE\x3\xF\a\xF\x116\n\xF\f\xF\xE\xF\x119\v\xF\x3\x10\x3\x10\x3\x10\x5"+
		"\x10\x11E\n\x10\x3\x10\x3\x10\x5\x10\x122\n\x10\x3\x10\x3\x10\x3\x11\x3"+
		"\x11\x3\x11\x5\x11\x129\n\x11\x3\x11\x3\x11\x3\x11\x3\x11\x3\x12\x3\x12"+
		"\x3\x12\a\x12\x132\n\x12\f\x12\xE\x12\x135\v\x12\x3\x13\x3\x13\x3\x13"+
		"\x3\x13\x3\x14\x3\x14\x3\x14\x5\x14\x13E\n\x14\x3\x14\x3\x14\a\x14\x142"+
		"\n\x14\f\x14\xE\x14\x145\v\x14\x3\x14\a\x14\x148\n\x14\f\x14\xE\x14\x14B"+
		"\v\x14\x3\x14\a\x14\x14E\n\x14\f\x14\xE\x14\x151\v\x14\x3\x14\a\x14\x154"+
		"\n\x14\f\x14\xE\x14\x157\v\x14\x3\x14\x3\x14\x5\x14\x15B\n\x14\x3\x14"+
		"\x3\x14\x3\x15\x3\x15\x3\x15\x5\x15\x162\n\x15\x3\x15\x3\x15\x3\x16\x5"+
		"\x16\x167\n\x16\x3\x16\x3\x16\x3\x16\a\x16\x16C\n\x16\f\x16\xE\x16\x16F"+
		"\v\x16\x3\x16\x5\x16\x172\n\x16\x3\x17\x3\x17\x3\x17\x3\x17\a\x17\x178"+
		"\n\x17\f\x17\xE\x17\x17B\v\x17\x3\x17\x5\x17\x17E\n\x17\x3\x18\x3\x18"+
		"\x3\x18\x3\x18\a\x18\x184\n\x18\f\x18\xE\x18\x187\v\x18\x3\x18\x5\x18"+
		"\x18A\n\x18\x3\x19\x3\x19\x3\x19\x3\x19\a\x19\x190\n\x19\f\x19\xE\x19"+
		"\x193\v\x19\x3\x19\x5\x19\x196\n\x19\x3\x1A\x3\x1A\x3\x1B\x3\x1B\x3\x1C"+
		"\x3\x1C\x3\x1D\x3\x1D\x3\x1D\x5\x1D\x1A1\n\x1D\x3\x1D\x3\x1D\a\x1D\x1A5"+
		"\n\x1D\f\x1D\xE\x1D\x1A8\v\x1D\x3\x1D\a\x1D\x1AB\n\x1D\f\x1D\xE\x1D\x1AE"+
		"\v\x1D\x3\x1D\a\x1D\x1B1\n\x1D\f\x1D\xE\x1D\x1B4\v\x1D\x3\x1D\x3\x1D\x5"+
		"\x1D\x1B8\n\x1D\x3\x1D\x3\x1D\x3\x1E\x3\x1E\x3\x1F\x3\x1F\x3 \x3 \x5 "+
		"\x1C2\n \x3!\x3!\x3!\x5!\x1C7\n!\x3!\x3!\x5!\x1CB\n!\x3\"\x3\"\x3\"\a"+
		"\"\x1D0\n\"\f\"\xE\"\x1D3\v\"\x3#\x3#\x3#\x5#\x1D8\n#\x3$\x3$\x3$\x5$"+
		"\x1DD\n$\x3$\x3$\x5$\x1E1\n$\x3%\x3%\x3%\a%\x1E6\n%\f%\xE%\x1E9\v%\x3"+
		"&\x3&\x3\'\a\'\x1EE\n\'\f\'\xE\'\x1F1\v\'\x3(\x3(\x3(\x3(\x3(\x3(\x3("+
		"\x3(\x5(\x1FB\n(\x3)\x3)\x5)\x1FF\n)\x3)\a)\x202\n)\f)\xE)\x205\v)\x3"+
		")\x5)\x208\n)\x3)\x3)\x3*\x3*\x3*\x5*\x20F\n*\x3*\x3*\x5*\x213\n*\x3+"+
		"\x3+\x5+\x217\n+\x3+\x5+\x21A\n+\x3,\x3,\x3,\a,\x21F\n,\f,\xE,\x222\v"+
		",\x3,\a,\x225\n,\f,\xE,\x228\v,\x3,\x3,\x3-\x3-\x5-\x22E\n-\x3-\x3-\x5"+
		"-\x232\n-\x3.\x3.\x3.\x3.\x3/\x3/\x3/\x5/\x23B\n/\x3/\x3/\x5/\x23F\n/"+
		"\x3/\x3/\x3\x30\x3\x30\x3\x30\x3\x30\x5\x30\x247\n\x30\x3\x30\x5\x30\x24A"+
		"\n\x30\x3\x31\x3\x31\x5\x31\x24E\n\x31\x3\x31\x3\x31\x3\x32\x3\x32\x5"+
		"\x32\x254\n\x32\x3\x32\x3\x32\x3\x33\x3\x33\x5\x33\x25A\n\x33\x3\x33\x5"+
		"\x33\x25D\n\x33\x3\x33\x3\x33\x3\x34\x3\x34\x5\x34\x263\n\x34\x3\x34\x5"+
		"\x34\x266\n\x34\x3\x35\x3\x35\x3\x36\x3\x36\x3\x37\x3\x37\x3\x37\x5\x37"+
		"\x26F\n\x37\x3\x37\x5\x37\x272\n\x37\x3\x37\x5\x37\x275\n\x37\x3\x37\x3"+
		"\x37\x3\x38\x3\x38\x5\x38\x27B\n\x38\x3\x39\x3\x39\x3\x39\x3:\x3:\x3:"+
		"\x5:\x283\n:\x3:\x5:\x286\n:\x3:\x3:\x5:\x28A\n:\x3;\x3;\x3;\x5;\x28F"+
		"\n;\x3;\x5;\x292\n;\x3;\x3;\x5;\x296\n;\x3<\x3<\x3<\x5<\x29B\n<\x3<\x5"+
		"<\x29E\n<\x3<\x3<\x5<\x2A2\n<\x3=\x3=\x3>\x3>\x3>\x3>\x3>\x3>\x5>\x2AC"+
		"\n>\x3>\x3>\x3?\x3?\x3?\x3?\x3?\x3@\x3@\x5@\x2B7\n@\x3\x41\x3\x41\x3\x41"+
		"\a\x41\x2BC\n\x41\f\x41\xE\x41\x2BF\v\x41\x3\x42\x3\x42\x5\x42\x2C3\n"+
		"\x42\x3\x43\x3\x43\x3\x43\x3\x43\x3\x43\x5\x43\x2CA\n\x43\x3\x43\x3\x43"+
		"\x3\x43\x3\x43\x3\x43\x3\x43\x3\x43\x3\x43\a\x43\x2D4\n\x43\f\x43\xE\x43"+
		"\x2D7\v\x43\x3\x44\x3\x44\x3\x45\x3\x45\x3\x46\x3\x46\x3\x46\x3\x46\x3"+
		"\x46\x5\x46\x2E2\n\x46\x3G\x3G\x3H\x3H\x3H\x3H\x3H\x5H\x2EB\nH\x3H\x3"+
		"H\x3H\x3H\x3H\x3H\x3H\x3H\aH\x2F5\nH\fH\xEH\x2F8\vH\x3I\x3I\x3J\x3J\x3"+
		"K\x3K\x3L\x3L\x3L\x3L\x3L\x3L\x3L\x5L\x307\nL\x3M\x3M\x3M\x3M\x3N\x3N"+
		"\x3O\x3O\x3O\x3O\x5O\x313\nO\x3O\x3O\x3P\x3P\x3P\aP\x31A\nP\fP\xEP\x31D"+
		"\vP\x3Q\x3Q\x3R\x3R\x3R\x5R\x324\nR\x3S\x3S\x3S\x5S\x329\nS\x3S\x3S\x3"+
		"T\x3T\x3T\aT\x330\nT\fT\xET\x333\vT\x3U\x3U\x3V\x3V\x3W\x3W\x3X\x3X\x5"+
		"X\x33D\nX\x3Y\x3Y\x3Z\x3Z\x3Z\aZ\x344\nZ\fZ\xEZ\x347\vZ\x3[\x3[\x3[\a"+
		"[\x34C\n[\f[\xE[\x34F\v[\x3\\\x3\\\x3]\x3]\x3]\a]\x356\n]\f]\xE]\x359"+
		"\v]\x3^\x3^\x3_\x3_\x3_\x2\x2\x4\x84\x8E`\x2\x2\x4\x2\x6\x2\b\x2\n\x2"+
		"\f\x2\xE\x2\x10\x2\x12\x2\x14\x2\x16\x2\x18\x2\x1A\x2\x1C\x2\x1E\x2 \x2"+
		"\"\x2$\x2&\x2(\x2*\x2,\x2.\x2\x30\x2\x32\x2\x34\x2\x36\x2\x38\x2:\x2<"+
		"\x2>\x2@\x2\x42\x2\x44\x2\x46\x2H\x2J\x2L\x2N\x2P\x2R\x2T\x2V\x2X\x2Z"+
		"\x2\\\x2^\x2`\x2\x62\x2\x64\x2\x66\x2h\x2j\x2l\x2n\x2p\x2r\x2t\x2v\x2"+
		"x\x2z\x2|\x2~\x2\x80\x2\x82\x2\x84\x2\x86\x2\x88\x2\x8A\x2\x8C\x2\x8E"+
		"\x2\x90\x2\x92\x2\x94\x2\x96\x2\x98\x2\x9A\x2\x9C\x2\x9E\x2\xA0\x2\xA2"+
		"\x2\xA4\x2\xA6\x2\xA8\x2\xAA\x2\xAC\x2\xAE\x2\xB0\x2\xB2\x2\xB4\x2\xB6"+
		"\x2\xB8\x2\xBA\x2\xBC\x2\x2\b\x3\x2\x1B\x1C\x3\x2\x43\x44\x3\x2?@\x4\x2"+
		"\x34\x35\x46I\x5\x2!\"((UU\x3\x2#&\x370\x2\xC1\x3\x2\x2\x2\x4\xCC\x3\x2"+
		"\x2\x2\x6\xCE\x3\x2\x2\x2\b\xD4\x3\x2\x2\x2\n\xDE\x3\x2\x2\x2\f\xE5\x3"+
		"\x2\x2\x2\xE\xED\x3\x2\x2\x2\x10\xEF\x3\x2\x2\x2\x12\xF7\x3\x2\x2\x2\x14"+
		"\xFE\x3\x2\x2\x2\x16\x106\x3\x2\x2\x2\x18\x10B\x3\x2\x2\x2\x1A\x111\x3"+
		"\x2\x2\x2\x1C\x117\x3\x2\x2\x2\x1E\x11A\x3\x2\x2\x2 \x125\x3\x2\x2\x2"+
		"\"\x12E\x3\x2\x2\x2$\x136\x3\x2\x2\x2&\x13A\x3\x2\x2\x2(\x15E\x3\x2\x2"+
		"\x2*\x166\x3\x2\x2\x2,\x173\x3\x2\x2\x2.\x17F\x3\x2\x2\x2\x30\x18B\x3"+
		"\x2\x2\x2\x32\x197\x3\x2\x2\x2\x34\x199\x3\x2\x2\x2\x36\x19B\x3\x2\x2"+
		"\x2\x38\x19D\x3\x2\x2\x2:\x1BB\x3\x2\x2\x2<\x1BD\x3\x2\x2\x2>\x1C1\x3"+
		"\x2\x2\x2@\x1C3\x3\x2\x2\x2\x42\x1CC\x3\x2\x2\x2\x44\x1D4\x3\x2\x2\x2"+
		"\x46\x1D9\x3\x2\x2\x2H\x1E2\x3\x2\x2\x2J\x1EA\x3\x2\x2\x2L\x1EF\x3\x2"+
		"\x2\x2N\x1FA\x3\x2\x2\x2P\x1FC\x3\x2\x2\x2R\x20B\x3\x2\x2\x2T\x214\x3"+
		"\x2\x2\x2V\x21B\x3\x2\x2\x2X\x22B\x3\x2\x2\x2Z\x233\x3\x2\x2\x2\\\x23A"+
		"\x3\x2\x2\x2^\x242\x3\x2\x2\x2`\x24B\x3\x2\x2\x2\x62\x251\x3\x2\x2\x2"+
		"\x64\x257\x3\x2\x2\x2\x66\x260\x3\x2\x2\x2h\x267\x3\x2\x2\x2j\x269\x3"+
		"\x2\x2\x2l\x26B\x3\x2\x2\x2n\x27A\x3\x2\x2\x2p\x27C\x3\x2\x2\x2r\x27F"+
		"\x3\x2\x2\x2t\x28B\x3\x2\x2\x2v\x297\x3\x2\x2\x2x\x2A3\x3\x2\x2\x2z\x2A5"+
		"\x3\x2\x2\x2|\x2AF\x3\x2\x2\x2~\x2B6\x3\x2\x2\x2\x80\x2B8\x3\x2\x2\x2"+
		"\x82\x2C2\x3\x2\x2\x2\x84\x2C9\x3\x2\x2\x2\x86\x2D8\x3\x2\x2\x2\x88\x2DA"+
		"\x3\x2\x2\x2\x8A\x2E1\x3\x2\x2\x2\x8C\x2E3\x3\x2\x2\x2\x8E\x2EA\x3\x2"+
		"\x2\x2\x90\x2F9\x3\x2\x2\x2\x92\x2FB\x3\x2\x2\x2\x94\x2FD\x3\x2\x2\x2"+
		"\x96\x306\x3\x2\x2\x2\x98\x308\x3\x2\x2\x2\x9A\x30C\x3\x2\x2\x2\x9C\x30E"+
		"\x3\x2\x2\x2\x9E\x316\x3\x2\x2\x2\xA0\x31E\x3\x2\x2\x2\xA2\x323\x3\x2"+
		"\x2\x2\xA4\x325\x3\x2\x2\x2\xA6\x32C\x3\x2\x2\x2\xA8\x334\x3\x2\x2\x2"+
		"\xAA\x336\x3\x2\x2\x2\xAC\x338\x3\x2\x2\x2\xAE\x33C\x3\x2\x2\x2\xB0\x33E"+
		"\x3\x2\x2\x2\xB2\x340\x3\x2\x2\x2\xB4\x348\x3\x2\x2\x2\xB6\x350\x3\x2"+
		"\x2\x2\xB8\x352\x3\x2\x2\x2\xBA\x35A\x3\x2\x2\x2\xBC\x35C\x3\x2\x2\x2"+
		"\xBE\xC0\x5\x4\x3\x2\xBF\xBE\x3\x2\x2\x2\xC0\xC3\x3\x2\x2\x2\xC1\xBF\x3"+
		"\x2\x2\x2\xC1\xC2\x3\x2\x2\x2\xC2\xC4\x3\x2\x2\x2\xC3\xC1\x3\x2\x2\x2"+
		"\xC4\xC5\a\x2\x2\x3\xC5\x3\x3\x2\x2\x2\xC6\xCD\x5\x6\x4\x2\xC7\xCD\x5"+
		"\b\x5\x2\xC8\xCD\x5\n\x6\x2\xC9\xCD\x5\x10\t\x2\xCA\xCD\x5\x1E\x10\x2"+
		"\xCB\xCD\x5&\x14\x2\xCC\xC6\x3\x2\x2\x2\xCC\xC7\x3\x2\x2\x2\xCC\xC8\x3"+
		"\x2\x2\x2\xCC\xC9\x3\x2\x2\x2\xCC\xCA\x3\x2\x2\x2\xCC\xCB\x3\x2\x2\x2"+
		"\xCD\x5\x3\x2\x2\x2\xCE\xCF\a\x3\x2\x2\xCF\xD0\x5\xB6\\\x2\xD0\xD1\a*"+
		"\x2\x2\xD1\xD2\x5\xAEX\x2\xD2\xD3\a)\x2\x2\xD3\a\x3\x2\x2\x2\xD4\xD5\a"+
		"\x1F\x2\x2\xD5\xD6\x5\xB6\\\x2\xD6\xD7\a*\x2\x2\xD7\xDA\x5\xAEX\x2\xD8"+
		"\xD9\a-\x2\x2\xD9\xDB\x5\x82\x42\x2\xDA\xD8\x3\x2\x2\x2\xDA\xDB\x3\x2"+
		"\x2\x2\xDB\xDC\x3\x2\x2\x2\xDC\xDD\a)\x2\x2\xDD\t\x3\x2\x2\x2\xDE\xDF"+
		"\a\x4\x2\x2\xDF\xE0\x5\xB6\\\x2\xE0\xE1\a\x30\x2\x2\xE1\xE2\x5\f\a\x2"+
		"\xE2\xE3\a\x31\x2\x2\xE3\xE4\a)\x2\x2\xE4\v\x3\x2\x2\x2\xE5\xEA\x5\xE"+
		"\b\x2\xE6\xE7\a,\x2\x2\xE7\xE9\x5\xE\b\x2\xE8\xE6\x3\x2\x2\x2\xE9\xEC"+
		"\x3\x2\x2\x2\xEA\xE8\x3\x2\x2\x2\xEA\xEB\x3\x2\x2\x2\xEB\r\x3\x2\x2\x2"+
		"\xEC\xEA\x3\x2\x2\x2\xED\xEE\x5\xB6\\\x2\xEE\xF\x3\x2\x2\x2\xEF\xF0\a"+
		"\x12\x2\x2\xF0\xF1\x5\x12\n\x2\xF1\xF2\a)\x2\x2\xF2\xF3\x5\x18\r\x2\xF3"+
		"\xF4\x5\x1A\xE\x2\xF4\xF5\x5\x1C\xF\x2\xF5\xF6\a\x13\x2\x2\xF6\x11\x3"+
		"\x2\x2\x2\xF7\xF8\x5\xB6\\\x2\xF8\xFA\a.\x2\x2\xF9\xFB\x5\x14\v\x2\xFA"+
		"\xF9\x3\x2\x2\x2\xFA\xFB\x3\x2\x2\x2\xFB\xFC\x3\x2\x2\x2\xFC\xFD\a/\x2"+
		"\x2\xFD\x13\x3\x2\x2\x2\xFE\x103\x5\x16\f\x2\xFF\x100\a,\x2\x2\x100\x102"+
		"\x5\x16\f\x2\x101\xFF\x3\x2\x2\x2\x102\x105\x3\x2\x2\x2\x103\x101\x3\x2"+
		"\x2\x2\x103\x104\x3\x2\x2\x2\x104\x15\x3\x2\x2\x2\x105\x103\x3\x2\x2\x2"+
		"\x106\x107\x5\xB6\\\x2\x107\x17\x3\x2\x2\x2\x108\x10A\x5\b\x5\x2\x109"+
		"\x108\x3\x2\x2\x2\x10A\x10D\x3\x2\x2\x2\x10B\x109\x3\x2\x2\x2\x10B\x10C"+
		"\x3\x2\x2\x2\x10C\x19\x3\x2\x2\x2\x10D\x10B\x3\x2\x2\x2\x10E\x110\x5z"+
		">\x2\x10F\x10E\x3\x2\x2\x2\x110\x113\x3\x2\x2\x2\x111\x10F\x3\x2\x2\x2"+
		"\x111\x112\x3\x2\x2\x2\x112\x1B\x3\x2\x2\x2\x113\x111\x3\x2\x2\x2\x114"+
		"\x116\x5\x1E\x10\x2\x115\x114\x3\x2\x2\x2\x116\x119\x3\x2\x2\x2\x117\x115"+
		"\x3\x2\x2\x2\x117\x118\x3\x2\x2\x2\x118\x1D\x3\x2\x2\x2\x119\x117\x3\x2"+
		"\x2\x2\x11A\x11B\a\x5\x2\x2\x11B\x11D\x5 \x11\x2\x11C\x11E\x5\xAAV\x2"+
		"\x11D\x11C\x3\x2\x2\x2\x11D\x11E\x3\x2\x2\x2\x11E\x11F\x3\x2\x2\x2\x11F"+
		"\x121\a)\x2\x2\x120\x122\x5L\'\x2\x121\x120\x3\x2\x2\x2\x121\x122\x3\x2"+
		"\x2\x2\x122\x123\x3\x2\x2\x2\x123\x124\a\x6\x2\x2\x124\x1F\x3\x2\x2\x2"+
		"\x125\x126\x5\xB6\\\x2\x126\x128\a.\x2\x2\x127\x129\x5\"\x12\x2\x128\x127"+
		"\x3\x2\x2\x2\x128\x129\x3\x2\x2\x2\x129\x12A\x3\x2\x2\x2\x12A\x12B\a/"+
		"\x2\x2\x12B\x12C\a*\x2\x2\x12C\x12D\x5\xAEX\x2\x12D!\x3\x2\x2\x2\x12E"+
		"\x133\x5$\x13\x2\x12F\x130\a,\x2\x2\x130\x132\x5$\x13\x2\x131\x12F\x3"+
		"\x2\x2\x2\x132\x135\x3\x2\x2\x2\x133\x131\x3\x2\x2\x2\x133\x134\x3\x2"+
		"\x2\x2\x134#\x3\x2\x2\x2\x135\x133\x3\x2\x2\x2\x136\x137\x5\xB6\\\x2\x137"+
		"\x138\a*\x2\x2\x138\x139\x5\xAEX\x2\x139%\x3\x2\x2\x2\x13A\x13B\a\xE\x2"+
		"\x2\x13B\x13D\x5(\x15\x2\x13C\x13E\x5\xAAV\x2\x13D\x13C\x3\x2\x2\x2\x13D"+
		"\x13E\x3\x2\x2\x2\x13E\x13F\x3\x2\x2\x2\x13F\x143\a)\x2\x2\x140\x142\x5"+
		"\x32\x1A\x2\x141\x140\x3\x2\x2\x2\x142\x145\x3\x2\x2\x2\x143\x141\x3\x2"+
		"\x2\x2\x143\x144\x3\x2\x2\x2\x144\x149\x3\x2\x2\x2\x145\x143\x3\x2\x2"+
		"\x2\x146\x148\x5\x34\x1B\x2\x147\x146\x3\x2\x2\x2\x148\x14B\x3\x2\x2\x2"+
		"\x149\x147\x3\x2\x2\x2\x149\x14A\x3\x2\x2\x2\x14A\x14F\x3\x2\x2\x2\x14B"+
		"\x149\x3\x2\x2\x2\x14C\x14E\x5\x1E\x10\x2\x14D\x14C\x3\x2\x2\x2\x14E\x151"+
		"\x3\x2\x2\x2\x14F\x14D\x3\x2\x2\x2\x14F\x150\x3\x2\x2\x2\x150\x155\x3"+
		"\x2\x2\x2\x151\x14F\x3\x2\x2\x2\x152\x154\x5\x38\x1D\x2\x153\x152\x3\x2"+
		"\x2\x2\x154\x157\x3\x2\x2\x2\x155\x153\x3\x2\x2\x2\x155\x156\x3\x2\x2"+
		"\x2\x156\x158\x3\x2\x2\x2\x157\x155\x3\x2\x2\x2\x158\x15A\a\xF\x2\x2\x159"+
		"\x15B\x5\xBA^\x2\x15A\x159\x3\x2\x2\x2\x15A\x15B\x3\x2\x2\x2\x15B\x15C"+
		"\x3\x2\x2\x2\x15C\x15D\a)\x2\x2\x15D\'\x3\x2\x2\x2\x15E\x15F\x5\xB6\\"+
		"\x2\x15F\x161\a.\x2\x2\x160\x162\x5*\x16\x2\x161\x160\x3\x2\x2\x2\x161"+
		"\x162\x3\x2\x2\x2\x162\x163\x3\x2\x2\x2\x163\x164\a/\x2\x2\x164)\x3\x2"+
		"\x2\x2\x165\x167\a\x1A\x2\x2\x166\x165\x3\x2\x2\x2\x166\x167\x3\x2\x2"+
		"\x2\x167\x168\x3\x2\x2\x2\x168\x16D\x5$\x13\x2\x169\x16A\a,\x2\x2\x16A"+
		"\x16C\x5$\x13\x2\x16B\x169\x3\x2\x2\x2\x16C\x16F\x3\x2\x2\x2\x16D\x16B"+
		"\x3\x2\x2\x2\x16D\x16E\x3\x2\x2\x2\x16E\x171\x3\x2\x2\x2\x16F\x16D\x3"+
		"\x2\x2\x2\x170\x172\a)\x2\x2\x171\x170\x3\x2\x2\x2\x171\x172\x3\x2\x2"+
		"\x2\x172+\x3\x2\x2\x2\x173\x174\a\x1B\x2\x2\x174\x179\x5$\x13\x2\x175"+
		"\x176\a,\x2\x2\x176\x178\x5$\x13\x2\x177\x175\x3\x2\x2\x2\x178\x17B\x3"+
		"\x2\x2\x2\x179\x177\x3\x2\x2\x2\x179\x17A\x3\x2\x2\x2\x17A\x17D\x3\x2"+
		"\x2\x2\x17B\x179\x3\x2\x2\x2\x17C\x17E\a)\x2\x2\x17D\x17C\x3\x2\x2\x2"+
		"\x17D\x17E\x3\x2\x2\x2\x17E-\x3\x2\x2\x2\x17F\x180\a\x1C\x2\x2\x180\x185"+
		"\x5$\x13\x2\x181\x182\a,\x2\x2\x182\x184\x5$\x13\x2\x183\x181\x3\x2\x2"+
		"\x2\x184\x187\x3\x2\x2\x2\x185\x183\x3\x2\x2\x2\x185\x186\x3\x2\x2\x2"+
		"\x186\x189\x3\x2\x2\x2\x187\x185\x3\x2\x2\x2\x188\x18A\a)\x2\x2\x189\x188"+
		"\x3\x2\x2\x2\x189\x18A\x3\x2\x2\x2\x18A/\x3\x2\x2\x2\x18B\x18C\a\x1D\x2"+
		"\x2\x18C\x191\x5$\x13\x2\x18D\x18E\a,\x2\x2\x18E\x190\x5$\x13\x2\x18F"+
		"\x18D\x3\x2\x2\x2\x190\x193\x3\x2\x2\x2\x191\x18F\x3\x2\x2\x2\x191\x192"+
		"\x3\x2\x2\x2\x192\x195\x3\x2\x2\x2\x193\x191\x3\x2\x2\x2\x194\x196\a)"+
		"\x2\x2\x195\x194\x3\x2\x2\x2\x195\x196\x3\x2\x2\x2\x196\x31\x3\x2\x2\x2"+
		"\x197\x198\x5\b\x5\x2\x198\x33\x3\x2\x2\x2\x199\x19A\x5z>\x2\x19A\x35"+
		"\x3\x2\x2\x2\x19B\x19C\x5\x1E\x10\x2\x19C\x37\x3\x2\x2\x2\x19D\x19E\a"+
		"\x12\x2\x2\x19E\x1A0\x5\xB6\\\x2\x19F\x1A1\x5\xAAV\x2\x1A0\x19F\x3\x2"+
		"\x2\x2\x1A0\x1A1\x3\x2\x2\x2\x1A1\x1A2\x3\x2\x2\x2\x1A2\x1A6\a)\x2\x2"+
		"\x1A3\x1A5\x5:\x1E\x2\x1A4\x1A3\x3\x2\x2\x2\x1A5\x1A8\x3\x2\x2\x2\x1A6"+
		"\x1A4\x3\x2\x2\x2\x1A6\x1A7\x3\x2\x2\x2\x1A7\x1AC\x3\x2\x2\x2\x1A8\x1A6"+
		"\x3\x2\x2\x2\x1A9\x1AB\x5<\x1F\x2\x1AA\x1A9\x3\x2\x2\x2\x1AB\x1AE\x3\x2"+
		"\x2\x2\x1AC\x1AA\x3\x2\x2\x2\x1AC\x1AD\x3\x2\x2\x2\x1AD\x1B2\x3\x2\x2"+
		"\x2\x1AE\x1AC\x3\x2\x2\x2\x1AF\x1B1\x5> \x2\x1B0\x1AF\x3\x2\x2\x2\x1B1"+
		"\x1B4\x3\x2\x2\x2\x1B2\x1B0\x3\x2\x2\x2\x1B2\x1B3\x3\x2\x2\x2\x1B3\x1B5"+
		"\x3\x2\x2\x2\x1B4\x1B2\x3\x2\x2\x2\x1B5\x1B7\a\x13\x2\x2\x1B6\x1B8\x5"+
		"\xBA^\x2\x1B7\x1B6\x3\x2\x2\x2\x1B7\x1B8\x3\x2\x2\x2\x1B8\x1B9\x3\x2\x2"+
		"\x2\x1B9\x1BA\a)\x2\x2\x1BA\x39\x3\x2\x2\x2\x1BB\x1BC\x5z>\x2\x1BC;\x3"+
		"\x2\x2\x2\x1BD\x1BE\x5\x1E\x10\x2\x1BE=\x3\x2\x2\x2\x1BF\x1C2\x5@!\x2"+
		"\x1C0\x1C2\x5\x46$\x2\x1C1\x1BF\x3\x2\x2\x2\x1C1\x1C0\x3\x2\x2\x2\x1C2"+
		"?\x3\x2\x2\x2\x1C3\x1C4\a\x15\x2\x2\x1C4\x1C6\x5\x42\"\x2\x1C5\x1C7\x5"+
		"\xAAV\x2\x1C6\x1C5\x3\x2\x2\x2\x1C6\x1C7\x3\x2\x2\x2\x1C7\x1C8\x3\x2\x2"+
		"\x2\x1C8\x1CA\a)\x2\x2\x1C9\x1CB\x5L\'\x2\x1CA\x1C9\x3\x2\x2\x2\x1CA\x1CB"+
		"\x3\x2\x2\x2\x1CB\x41\x3\x2\x2\x2\x1CC\x1D1\x5\x44#\x2\x1CD\x1CE\a,\x2"+
		"\x2\x1CE\x1D0\x5\x44#\x2\x1CF\x1CD\x3\x2\x2\x2\x1D0\x1D3\x3\x2\x2\x2\x1D1"+
		"\x1CF\x3\x2\x2\x2\x1D1\x1D2\x3\x2\x2\x2\x1D2\x43\x3\x2\x2\x2\x1D3\x1D1"+
		"\x3\x2\x2\x2\x1D4\x1D7\x5\xBA^\x2\x1D5\x1D6\a+\x2\x2\x1D6\x1D8\x5\xBA"+
		"^\x2\x1D7\x1D5\x3\x2\x2\x2\x1D7\x1D8\x3\x2\x2\x2\x1D8\x45\x3\x2\x2\x2"+
		"\x1D9\x1DA\a\x14\x2\x2\x1DA\x1DC\x5H%\x2\x1DB\x1DD\x5\xAAV\x2\x1DC\x1DB"+
		"\x3\x2\x2\x2\x1DC\x1DD\x3\x2\x2\x2\x1DD\x1DE\x3\x2\x2\x2\x1DE\x1E0\a)"+
		"\x2\x2\x1DF\x1E1\x5L\'\x2\x1E0\x1DF\x3\x2\x2\x2\x1E0\x1E1\x3\x2\x2\x2"+
		"\x1E1G\x3\x2\x2\x2\x1E2\x1E7\x5J&\x2\x1E3\x1E4\a,\x2\x2\x1E4\x1E6\x5J"+
		"&\x2\x1E5\x1E3\x3\x2\x2\x2\x1E6\x1E9\x3\x2\x2\x2\x1E7\x1E5\x3\x2\x2\x2"+
		"\x1E7\x1E8\x3\x2\x2\x2\x1E8I\x3\x2\x2\x2\x1E9\x1E7\x3\x2\x2\x2\x1EA\x1EB"+
		"\x5\xBA^\x2\x1EBK\x3\x2\x2\x2\x1EC\x1EE\x5N(\x2\x1ED\x1EC\x3\x2\x2\x2"+
		"\x1EE\x1F1\x3\x2\x2\x2\x1EF\x1ED\x3\x2\x2\x2\x1EF\x1F0\x3\x2\x2\x2\x1F0"+
		"M\x3\x2\x2\x2\x1F1\x1EF\x3\x2\x2\x2\x1F2\x1FB\x5x=\x2\x1F3\x1FB\x5\\/"+
		"\x2\x1F4\x1FB\x5P)\x2\x1F5\x1FB\x5l\x37\x2\x1F6\x1FB\x5V,\x2\x1F7\x1FB"+
		"\x5\x62\x32\x2\x1F8\x1FB\x5\x64\x33\x2\x1F9\x1FB\x5|?\x2\x1FA\x1F2\x3"+
		"\x2\x2\x2\x1FA\x1F3\x3\x2\x2\x2\x1FA\x1F4\x3\x2\x2\x2\x1FA\x1F5\x3\x2"+
		"\x2\x2\x1FA\x1F6\x3\x2\x2\x2\x1FA\x1F7\x3\x2\x2\x2\x1FA\x1F8\x3\x2\x2"+
		"\x2\x1FA\x1F9\x3\x2\x2\x2\x1FBO\x3\x2\x2\x2\x1FC\x1FE\a\b\x2\x2\x1FD\x1FF"+
		"\x5\x82\x42\x2\x1FE\x1FD\x3\x2\x2\x2\x1FE\x1FF\x3\x2\x2\x2\x1FF\x203\x3"+
		"\x2\x2\x2\x200\x202\x5R*\x2\x201\x200\x3\x2\x2\x2\x202\x205\x3\x2\x2\x2"+
		"\x203\x201\x3\x2\x2\x2\x203\x204\x3\x2\x2\x2\x204\x207\x3\x2\x2\x2\x205"+
		"\x203\x3\x2\x2\x2\x206\x208\x5T+\x2\x207\x206\x3\x2\x2\x2\x207\x208\x3"+
		"\x2\x2\x2\x208\x209\x3\x2\x2\x2\x209\x20A\a\t\x2\x2\x20AQ\x3\x2\x2\x2"+
		"\x20B\x20C\a\n\x2\x2\x20C\x20E\x5\x82\x42\x2\x20D\x20F\x5\xAAV\x2\x20E"+
		"\x20D\x3\x2\x2\x2\x20E\x20F\x3\x2\x2\x2\x20F\x210\x3\x2\x2\x2\x210\x212"+
		"\a)\x2\x2\x211\x213\x5L\'\x2\x212\x211\x3\x2\x2\x2\x212\x213\x3\x2\x2"+
		"\x2\x213S\x3\x2\x2\x2\x214\x216\a\v\x2\x2\x215\x217\x5\xAAV\x2\x216\x215"+
		"\x3\x2\x2\x2\x216\x217\x3\x2\x2\x2\x217\x219\x3\x2\x2\x2\x218\x21A\x5"+
		"L\'\x2\x219\x218\x3\x2\x2\x2\x219\x21A\x3\x2\x2\x2\x21AU\x3\x2\x2\x2\x21B"+
		"\x21C\a\f\x2\x2\x21C\x220\x5X-\x2\x21D\x21F\x5Z.\x2\x21E\x21D\x3\x2\x2"+
		"\x2\x21F\x222\x3\x2\x2\x2\x220\x21E\x3\x2\x2\x2\x220\x221\x3\x2\x2\x2"+
		"\x221\x226\x3\x2\x2\x2\x222\x220\x3\x2\x2\x2\x223\x225\x5T+\x2\x224\x223"+
		"\x3\x2\x2\x2\x225\x228\x3\x2\x2\x2\x226\x224\x3\x2\x2\x2\x226\x227\x3"+
		"\x2\x2\x2\x227\x229\x3\x2\x2\x2\x228\x226\x3\x2\x2\x2\x229\x22A\a\r\x2"+
		"\x2\x22AW\x3\x2\x2\x2\x22B\x22D\x5\x8EH\x2\x22C\x22E\x5\xAAV\x2\x22D\x22C"+
		"\x3\x2\x2\x2\x22D\x22E\x3\x2\x2\x2\x22E\x22F\x3\x2\x2\x2\x22F\x231\a)"+
		"\x2\x2\x230\x232\x5L\'\x2\x231\x230\x3\x2\x2\x2\x231\x232\x3\x2\x2\x2"+
		"\x232Y\x3\x2\x2\x2\x233\x234\a\v\x2\x2\x234\x235\a\f\x2\x2\x235\x236\x5"+
		"X-\x2\x236[\x3\x2\x2\x2\x237\x238\x5~@\x2\x238\x239\a-\x2\x2\x239\x23B"+
		"\x3\x2\x2\x2\x23A\x237\x3\x2\x2\x2\x23A\x23B\x3\x2\x2\x2\x23B\x23C\x3"+
		"\x2\x2\x2\x23C\x23E\x5^\x30\x2\x23D\x23F\x5\x66\x34\x2\x23E\x23D\x3\x2"+
		"\x2\x2\x23E\x23F\x3\x2\x2\x2\x23F\x240\x3\x2\x2\x2\x240\x241\a)\x2\x2"+
		"\x241]\x3\x2\x2\x2\x242\x243\a\x1A\x2\x2\x243\x246\x5\xBA^\x2\x244\x245"+
		"\a+\x2\x2\x245\x247\x5\xBA^\x2\x246\x244\x3\x2\x2\x2\x246\x247\x3\x2\x2"+
		"\x2\x247\x249\x3\x2\x2\x2\x248\x24A\x5`\x31\x2\x249\x248\x3\x2\x2\x2\x249"+
		"\x24A\x3\x2\x2\x2\x24A_\x3\x2\x2\x2\x24B\x24D\a.\x2\x2\x24C\x24E\x5\x80"+
		"\x41\x2\x24D\x24C\x3\x2\x2\x2\x24D\x24E\x3\x2\x2\x2\x24E\x24F\x3\x2\x2"+
		"\x2\x24F\x250\a/\x2\x2\x250\x61\x3\x2\x2\x2\x251\x253\x5h\x35\x2\x252"+
		"\x254\x5\x66\x34\x2\x253\x252\x3\x2\x2\x2\x253\x254\x3\x2\x2\x2\x254\x255"+
		"\x3\x2\x2\x2\x255\x256\a)\x2\x2\x256\x63\x3\x2\x2\x2\x257\x259\x5j\x36"+
		"\x2\x258\x25A\x5\xBA^\x2\x259\x258\x3\x2\x2\x2\x259\x25A\x3\x2\x2\x2\x25A"+
		"\x25C\x3\x2\x2\x2\x25B\x25D\x5\x66\x34\x2\x25C\x25B\x3\x2\x2\x2\x25C\x25D"+
		"\x3\x2\x2\x2\x25D\x25E\x3\x2\x2\x2\x25E\x25F\a)\x2\x2\x25F\x65\x3\x2\x2"+
		"\x2\x260\x262\a*\x2\x2\x261\x263\x5\x82\x42\x2\x262\x261\x3\x2\x2\x2\x262"+
		"\x263\x3\x2\x2\x2\x263\x265\x3\x2\x2\x2\x264\x266\x5\xAAV\x2\x265\x264"+
		"\x3\x2\x2\x2\x265\x266\x3\x2\x2\x2\x266g\x3\x2\x2\x2\x267\x268\t\x2\x2"+
		"\x2\x268i\x3\x2\x2\x2\x269\x26A\a\x1D\x2\x2\x26Ak\x3\x2\x2\x2\x26B\x26C"+
		"\a\b\x2\x2\x26C\x26E\x5n\x38\x2\x26D\x26F\x5r:\x2\x26E\x26D\x3\x2\x2\x2"+
		"\x26E\x26F\x3\x2\x2\x2\x26F\x271\x3\x2\x2\x2\x270\x272\x5t;\x2\x271\x270"+
		"\x3\x2\x2\x2\x271\x272\x3\x2\x2\x2\x272\x274\x3\x2\x2\x2\x273\x275\x5"+
		"v<\x2\x274\x273\x3\x2\x2\x2\x274\x275\x3\x2\x2\x2\x275\x276\x3\x2\x2\x2"+
		"\x276\x277\a\t\x2\x2\x277m\x3\x2\x2\x2\x278\x27B\x5p\x39\x2\x279\x27B"+
		"\x5\\/\x2\x27A\x278\x3\x2\x2\x2\x27A\x279\x3\x2\x2\x2\x27Bo\x3\x2\x2\x2"+
		"\x27C\x27D\x5\xBA^\x2\x27D\x27E\a)\x2\x2\x27Eq\x3\x2\x2\x2\x27F\x280\a"+
		"\n\x2\x2\x280\x282\a\x1B\x2\x2\x281\x283\x5\x82\x42\x2\x282\x281\x3\x2"+
		"\x2\x2\x282\x283\x3\x2\x2\x2\x283\x285\x3\x2\x2\x2\x284\x286\x5\xAAV\x2"+
		"\x285\x284\x3\x2\x2\x2\x285\x286\x3\x2\x2\x2\x286\x287\x3\x2\x2\x2\x287"+
		"\x289\a)\x2\x2\x288\x28A\x5L\'\x2\x289\x288\x3\x2\x2\x2\x289\x28A\x3\x2"+
		"\x2\x2\x28As\x3\x2\x2\x2\x28B\x28C\a\n\x2\x2\x28C\x28E\a\x1C\x2\x2\x28D"+
		"\x28F\x5\x82\x42\x2\x28E\x28D\x3\x2\x2\x2\x28E\x28F\x3\x2\x2\x2\x28F\x291"+
		"\x3\x2\x2\x2\x290\x292\x5\xAAV\x2\x291\x290\x3\x2\x2\x2\x291\x292\x3\x2"+
		"\x2\x2\x292\x293\x3\x2\x2\x2\x293\x295\a)\x2\x2\x294\x296\x5L\'\x2\x295"+
		"\x294\x3\x2\x2\x2\x295\x296\x3\x2\x2\x2\x296u\x3\x2\x2\x2\x297\x298\a"+
		"\n\x2\x2\x298\x29A\a\x1D\x2\x2\x299\x29B\x5\x82\x42\x2\x29A\x299\x3\x2"+
		"\x2\x2\x29A\x29B\x3\x2\x2\x2\x29B\x29D\x3\x2\x2\x2\x29C\x29E\x5\xAAV\x2"+
		"\x29D\x29C\x3\x2\x2\x2\x29D\x29E\x3\x2\x2\x2\x29E\x29F\x3\x2\x2\x2\x29F"+
		"\x2A1\a)\x2\x2\x2A0\x2A2\x5L\'\x2\x2A1\x2A0\x3\x2\x2\x2\x2A1\x2A2\x3\x2"+
		"\x2\x2\x2A2w\x3\x2\x2\x2\x2A3\x2A4\x5z>\x2\x2A4y\x3\x2\x2\x2\x2A5\x2A6"+
		"\a\x1E\x2\x2\x2A6\x2A7\x5\xB6\\\x2\x2A7\x2A8\a*\x2\x2\x2A8\x2AB\x5\xAE"+
		"X\x2\x2A9\x2AA\a-\x2\x2\x2AA\x2AC\x5\x82\x42\x2\x2AB\x2A9\x3\x2\x2\x2"+
		"\x2AB\x2AC\x3\x2\x2\x2\x2AC\x2AD\x3\x2\x2\x2\x2AD\x2AE\a)\x2\x2\x2AE{"+
		"\x3\x2\x2\x2\x2AF\x2B0\x5~@\x2\x2B0\x2B1\a-\x2\x2\x2B1\x2B2\x5\x82\x42"+
		"\x2\x2B2\x2B3\a)\x2\x2\x2B3}\x3\x2\x2\x2\x2B4\x2B7\x5\xBA^\x2\x2B5\x2B7"+
		"\x5\xBC_\x2\x2B6\x2B4\x3\x2\x2\x2\x2B6\x2B5\x3\x2\x2\x2\x2B7\x7F\x3\x2"+
		"\x2\x2\x2B8\x2BD\x5\x82\x42\x2\x2B9\x2BA\a,\x2\x2\x2BA\x2BC\x5\x82\x42"+
		"\x2\x2BB\x2B9\x3\x2\x2\x2\x2BC\x2BF\x3\x2\x2\x2\x2BD\x2BB\x3\x2\x2\x2"+
		"\x2BD\x2BE\x3\x2\x2\x2\x2BE\x81\x3\x2\x2\x2\x2BF\x2BD\x3\x2\x2\x2\x2C0"+
		"\x2C3\x5\x84\x43\x2\x2C1\x2C3\x5\x8EH\x2\x2C2\x2C0\x3\x2\x2\x2\x2C2\x2C1"+
		"\x3\x2\x2\x2\x2C3\x83\x3\x2\x2\x2\x2C4\x2C5\b\x43\x1\x2\x2C5\x2C6\x5\x8C"+
		"G\x2\x2C6\x2C7\x5\x8A\x46\x2\x2C7\x2CA\x3\x2\x2\x2\x2C8\x2CA\x5\x8A\x46"+
		"\x2\x2C9\x2C4\x3\x2\x2\x2\x2C9\x2C8\x3\x2\x2\x2\x2CA\x2D5\x3\x2\x2\x2"+
		"\x2CB\x2CC\f\x6\x2\x2\x2CC\x2CD\x5\x86\x44\x2\x2CD\x2CE\x5\x84\x43\a\x2CE"+
		"\x2D4\x3\x2\x2\x2\x2CF\x2D0\f\x5\x2\x2\x2D0\x2D1\x5\x88\x45\x2\x2D1\x2D2"+
		"\x5\x84\x43\x6\x2D2\x2D4\x3\x2\x2\x2\x2D3\x2CB\x3\x2\x2\x2\x2D3\x2CF\x3"+
		"\x2\x2\x2\x2D4\x2D7\x3\x2\x2\x2\x2D5\x2D3\x3\x2\x2\x2\x2D5\x2D6\x3\x2"+
		"\x2\x2\x2D6\x85\x3\x2\x2\x2\x2D7\x2D5\x3\x2\x2\x2\x2D8\x2D9\t\x3\x2\x2"+
		"\x2D9\x87\x3\x2\x2\x2\x2DA\x2DB\t\x4\x2\x2\x2DB\x89\x3\x2\x2\x2\x2DC\x2DD"+
		"\a.\x2\x2\x2DD\x2DE\x5\x84\x43\x2\x2DE\x2DF\a/\x2\x2\x2DF\x2E2\x3\x2\x2"+
		"\x2\x2E0\x2E2\x5\xA2R\x2\x2E1\x2DC\x3\x2\x2\x2\x2E1\x2E0\x3\x2\x2\x2\x2E2"+
		"\x8B\x3\x2\x2\x2\x2E3\x2E4\a@\x2\x2\x2E4\x8D\x3\x2\x2\x2\x2E5\x2E6\bH"+
		"\x1\x2\x2E6\x2E7\x5\x94K\x2\x2E7\x2E8\x5\x96L\x2\x2E8\x2EB\x3\x2\x2\x2"+
		"\x2E9\x2EB\x5\x96L\x2\x2EA\x2E5\x3\x2\x2\x2\x2EA\x2E9\x3\x2\x2\x2\x2EB"+
		"\x2F6\x3\x2\x2\x2\x2EC\x2ED\f\x6\x2\x2\x2ED\x2EE\x5\x90I\x2\x2EE\x2EF"+
		"\x5\x8EH\a\x2EF\x2F5\x3\x2\x2\x2\x2F0\x2F1\f\x5\x2\x2\x2F1\x2F2\x5\x92"+
		"J\x2\x2F2\x2F3\x5\x8EH\x6\x2F3\x2F5\x3\x2\x2\x2\x2F4\x2EC\x3\x2\x2\x2"+
		"\x2F4\x2F0\x3\x2\x2\x2\x2F5\x2F8\x3\x2\x2\x2\x2F6\x2F4\x3\x2\x2\x2\x2F6"+
		"\x2F7\x3\x2\x2\x2\x2F7\x8F\x3\x2\x2\x2\x2F8\x2F6\x3\x2\x2\x2\x2F9\x2FA"+
		"\a;\x2\x2\x2FA\x91\x3\x2\x2\x2\x2FB\x2FC\a<\x2\x2\x2FC\x93\x3\x2\x2\x2"+
		"\x2FD\x2FE\a\x42\x2\x2\x2FE\x95\x3\x2\x2\x2\x2FF\x300\a.\x2\x2\x300\x301"+
		"\x5\x8EH\x2\x301\x302\a/\x2\x2\x302\x307\x3\x2\x2\x2\x303\x307\x5\x9C"+
		"O\x2\x304\x307\x5\x98M\x2\x305\x307\x5\xA2R\x2\x306\x2FF\x3\x2\x2\x2\x306"+
		"\x303\x3\x2\x2\x2\x306\x304\x3\x2\x2\x2\x306\x305\x3\x2\x2\x2\x307\x97"+
		"\x3\x2\x2\x2\x308\x309\x5\x84\x43\x2\x309\x30A\x5\x9AN\x2\x30A\x30B\x5"+
		"\x84\x43\x2\x30B\x99\x3\x2\x2\x2\x30C\x30D\t\x5\x2\x2\x30D\x9B\x3\x2\x2"+
		"\x2\x30E\x30F\x5\xA2R\x2\x30F\x310\a\'\x2\x2\x310\x312\a\x30\x2\x2\x311"+
		"\x313\x5\x9EP\x2\x312\x311\x3\x2\x2\x2\x312\x313\x3\x2\x2\x2\x313\x314"+
		"\x3\x2\x2\x2\x314\x315\a\x31\x2\x2\x315\x9D\x3\x2\x2\x2\x316\x31B\x5\xA0"+
		"Q\x2\x317\x318\a,\x2\x2\x318\x31A\x5\xA0Q\x2\x319\x317\x3\x2\x2\x2\x31A"+
		"\x31D\x3\x2\x2\x2\x31B\x319\x3\x2\x2\x2\x31B\x31C\x3\x2\x2\x2\x31C\x9F"+
		"\x3\x2\x2\x2\x31D\x31B\x3\x2\x2\x2\x31E\x31F\x5\xBA^\x2\x31F\xA1\x3\x2"+
		"\x2\x2\x320\x324\x5\xA6T\x2\x321\x324\x5\xA4S\x2\x322\x324\x5\xACW\x2"+
		"\x323\x320\x3\x2\x2\x2\x323\x321\x3\x2\x2\x2\x323\x322\x3\x2\x2\x2\x324"+
		"\xA3\x3\x2\x2\x2\x325\x326\x5\xBA^\x2\x326\x328\a.\x2\x2\x327\x329\x5"+
		"\x80\x41\x2\x328\x327\x3\x2\x2\x2\x328\x329\x3\x2\x2\x2\x329\x32A\x3\x2"+
		"\x2\x2\x32A\x32B\a/\x2\x2\x32B\xA5\x3\x2\x2\x2\x32C\x331\x5\xA8U\x2\x32D"+
		"\x32E\a+\x2\x2\x32E\x330\x5\xA8U\x2\x32F\x32D\x3\x2\x2\x2\x330\x333\x3"+
		"\x2\x2\x2\x331\x32F\x3\x2\x2\x2\x331\x332\x3\x2\x2\x2\x332\xA7\x3\x2\x2"+
		"\x2\x333\x331\x3\x2\x2\x2\x334\x335\x5\xBA^\x2\x335\xA9\x3\x2\x2\x2\x336"+
		"\x337\aX\x2\x2\x337\xAB\x3\x2\x2\x2\x338\x339\t\x6\x2\x2\x339\xAD\x3\x2"+
		"\x2\x2\x33A\x33D\x5\xB0Y\x2\x33B\x33D\x5\xBA^\x2\x33C\x33A\x3\x2\x2\x2"+
		"\x33C\x33B\x3\x2\x2\x2\x33D\xAF\x3\x2\x2\x2\x33E\x33F\t\a\x2\x2\x33F\xB1"+
		"\x3\x2\x2\x2\x340\x345\x5\xB4[\x2\x341\x342\a,\x2\x2\x342\x344\x5\xB4"+
		"[\x2\x343\x341\x3\x2\x2\x2\x344\x347\x3\x2\x2\x2\x345\x343\x3\x2\x2\x2"+
		"\x345\x346\x3\x2\x2\x2\x346\xB3\x3\x2\x2\x2\x347\x345\x3\x2\x2\x2\x348"+
		"\x34D\x5\xBA^\x2\x349\x34A\a+\x2\x2\x34A\x34C\x5\xBA^\x2\x34B\x349\x3"+
		"\x2\x2\x2\x34C\x34F\x3\x2\x2\x2\x34D\x34B\x3\x2\x2\x2\x34D\x34E\x3\x2"+
		"\x2\x2\x34E\xB5\x3\x2\x2\x2\x34F\x34D\x3\x2\x2\x2\x350\x351\x5\xBA^\x2"+
		"\x351\xB7\x3\x2\x2\x2\x352\x357\x5\xBA^\x2\x353\x354\a,\x2\x2\x354\x356"+
		"\x5\xBA^\x2\x355\x353\x3\x2\x2\x2\x356\x359\x3\x2\x2\x2\x357\x355\x3\x2"+
		"\x2\x2\x357\x358\x3\x2\x2\x2\x358\xB9\x3\x2\x2\x2\x359\x357\x3\x2\x2\x2"+
		"\x35A\x35B\aT\x2\x2\x35B\xBB\x3\x2\x2\x2\x35C\x35D\a\a\x2\x2\x35D\xBD"+
		"\x3\x2\x2\x2\x65\xC1\xCC\xDA\xEA\xFA\x103\x10B\x111\x117\x11D\x121\x128"+
		"\x133\x13D\x143\x149\x14F\x155\x15A\x161\x166\x16D\x171\x179\x17D\x185"+
		"\x189\x191\x195\x1A0\x1A6\x1AC\x1B2\x1B7\x1C1\x1C6\x1CA\x1D1\x1D7\x1DC"+
		"\x1E0\x1E7\x1EF\x1FA\x1FE\x203\x207\x20E\x212\x216\x219\x220\x226\x22D"+
		"\x231\x23A\x23E\x246\x249\x24D\x253\x259\x25C\x262\x265\x26E\x271\x274"+
		"\x27A\x282\x285\x289\x28E\x291\x295\x29A\x29D\x2A1\x2AB\x2B6\x2BD\x2C2"+
		"\x2C9\x2D3\x2D5\x2E1\x2EA\x2F4\x2F6\x306\x312\x31B\x323\x328\x331\x33C"+
		"\x345\x34D\x357";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace PilV2.Syntax.InternalSyntax
