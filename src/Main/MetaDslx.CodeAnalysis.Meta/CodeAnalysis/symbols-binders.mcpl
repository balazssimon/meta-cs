namespace MetaDslx.CodeAnalysis.Symbols
{
    abstract symbol Symbol
    {
        LanguageSymbolKind Kind;

        string Name;
        string MetadataName;
        bool CanBeReferencedByName;
        LexicalSortKey GetLexicalSortKey();

        Symbol ContainingSymbol;

        ImmutableArray<Location> Locations;
        ImmutableArray<AttributeData> GetAttributes();
        bool IsFromCompilation(LanguageCompilation compilation);
        bool Dangerous_IsFromSomeCompilation;
        bool IsDefinedInSourceTree(SyntaxTree tree, TextSpan? definedWithinSpan, CancellationToken cancellationToken = default(CancellationToken));
        string GetDocumentationCommentId();
        string GetDocumentationCommentXml(CultureInfo preferredCulture = null, bool expandIncludes = false, CancellationToken cancellationToken = default(CancellationToken));
        string GetDebuggerDisplay();

        void AddDeclarationDiagnostics(DiagnosticBag diagnostics);
        bool HasUseSiteError;
        DiagnosticInfo GetUseSiteDiagnostic();
        ErrorCode HighestPriorityUseSiteError;
        bool HasUnsupportedMetadata;
        DiagnosticInfo GetUseSiteDiagnosticForSymbolOrContainingType();
        bool MergeUseSiteDiagnostics(ref DiagnosticInfo result, DiagnosticInfo info);
        static bool ReportUseSiteDiagnostic(DiagnosticInfo info, DiagnosticBag diagnostics, Location location);
        bool DeriveUseSiteDiagnosticFromType(ref DiagnosticInfo result, TypeSymbol type);
        bool DeriveUseSiteDiagnosticFromCustomModifiers(ref DiagnosticInfo result, ImmutableArray<CustomModifier> customModifiers);
        static bool GetUnificationUseSiteDiagnosticRecursive<T>(ref DiagnosticInfo result, ImmutableArray<T> types, Symbol owner, ref HashSet<TypeSymbol> checkedTypes) where T : TypeSymbol;
        static bool GetUnificationUseSiteDiagnosticRecursive(ref DiagnosticInfo result, ImmutableArray<CustomModifier> modifiers, Symbol owner, ref HashSet<TypeSymbol> checkedTypes);

        string ToDisplayString(SymbolDisplayFormat format = null);
        ImmutableArray<SymbolDisplayPart> ToDisplayParts(SymbolDisplayFormat format = null);
        string ToMinimalDisplayString(SemanticModel semanticModel, int position, SymbolDisplayFormat format = null);
        ImmutableArray<SymbolDisplayPart> ToMinimalDisplayParts(SemanticModel semanticModel, int position, SymbolDisplayFormat format = null);

        ThreeState ObsoleteState;
        ObsoleteAttributeKind ObsoleteKind;
        ObsoleteAttributeData ObsoleteAttributeData;
        void ForceCompleteObsoleteAttribute();

        void Accept(Microsoft.CodeAnalysis.SymbolVisitor visitor);
        TResult Accept<TResult>(Microsoft.CodeAnalysis.SymbolVisitor<TResult> visitor);
        void Accept(SymbolVisitor visitor);
        TResult Accept<TResult>(SymbolVisitor<TResult> visitor);
        TResult Accept<TArgument, TResult>(SymbolVisitor<TArgument, TResult> visitor, TArgument argument);
    }

    abstract symbol DeclaredSymbol : Symbol
    {
        NamedTypeSymbol ContainingType;
        NamespaceSymbol ContainingNamespace;
        AssemblySymbol ContainingAssembly;
        LanguageCompilation DeclaringCompilation;
        ModuleSymbol ContainingModule;
        Symbol OriginalDefinition;
        bool IsDefinition;
        ImmutableArray<SyntaxReference> DeclaringSyntaxReferences;
        Accessibility DeclaredAccessibility;
        bool IsStatic;
        bool IsVirtual;
        bool IsOverride;
        bool IsAbstract;
        bool IsSealed;
        bool IsExtern;
        bool IsImplicitlyDeclared;
        
        static void ForceCompleteMemberByLocation(SourceLocation locationOpt, Symbol member, CancellationToken cancellationToken);
        Symbol ConstructedFrom => this;
        Symbol AsMember(NamedTypeSymbol newOwner);
        Symbol GetLeastOverriddenMember(NamedTypeSymbol accessingTypeOpt);
        Symbol GetConstructedLeastOverriddenMember(NamedTypeSymbol accessingTypeOpt);
        
        ImmutableArray<Symbol> GetMembers();
        ImmutableArray<Symbol> GetMembersUnordered();
        ImmutableArray<Symbol> GetMembers(string name);
        ImmutableArray<Symbol> GetMembers(string name, string metadataName);
        ImmutableArray<NamedTypeSymbol> GetTypeMembersUnordered();
        ImmutableArray<NamedTypeSymbol> GetTypeMembers();
        ImmutableArray<NamedTypeSymbol> GetTypeMembers(string name);
        ImmutableArray<NamedTypeSymbol> GetTypeMembers(string name, string metadataName);
        MergedDeclaration MergedDeclaration;
        void CheckMembers(Dictionary<string, ImmutableArray<Symbol>> result, DiagnosticBag diagnostics);
        DeclaredSymbol GetSourceMember(SyntaxNodeOrToken syntax);
    }

    abstract symbol AssemblySymbol : Symbol
    {
    }

    abstract symbol NonMissingAssemblySymbol : AssemblySymbol
    {
    }

    abstract symbol MetadataOrSourceAssemblySymbol : NonMissingAssemblySymbol
    {
    }

    symbol MissingAssemblySymbol : AssemblySymbol
    {
    }

    symbol MissingCorLibrarySymbol : MissingAssemblySymbol
    {
    }

    abstract symbol ModuleSymbol : Symbol
    {
    }

    symbol MissingModuleSymbol : ModuleSymbol
    {
    }

    symbol MissingModuleSymbolWithName : MissingModuleSymbol
    {
    }

    abstract symbol NamespaceOrTypeSymbol : DeclaredSymbol
    {
    }

    abstract symbol NamespaceSymbol : NamespaceOrTypeSymbol
    {
    }

    symbol MergedNamespaceSymbol : NamespaceSymbol
    {
    }

    symbol MissingNamespaceSymbol : NamespaceSymbol
    {
    }

    abstract symbol TypeSymbol : NamespaceOrTypeSymbol
    {
    }

    abstract symbol ErrorTypeSymbol : NamedTypeSymbol
    {
    }

    abstract symbol MissingMetadataTypeSymbol : ErrorTypeSymbol
    {
    }

    symbol UnsupportedSymbol : Symbol, IMetaErrorSymbol
    {
    }

    abstract symbol MemberSymbol : DeclaredSymbol
    {
    }

    abstract symbol MethodSymbol : MemberSymbol
    {
    }

    symbol DiscardSymbol : Symbol
    {
    }
    
    
    // ================================================
    
    symbol CSharpAssemblySymbol : NonMissingAssemblySymbol
    {
    }
    
    symbol CSharpModuleSymbol : NonMissingModuleSymbol
    {
    }
    
    symbol CSharpNamespaceSymbol : NamespaceSymbol
    {
    }
    
    symbol CSharpNamedTypeSymbol : NamedTypeSymbol
    {
    }

    // ================================================

    symbol MetaModuleSymbol : NonMissingModuleSymbol
    {
    }

    symbol MetaNamespaceSymbol : NamespaceSymbol
    {
    }

    symbol MetaGlobalNamespaceSymbol : NamespaceSymbol
    {
    }

    symbol MetaNamedTypeSymbol : NamedTypeSymbol
    {
    }

    symbol MetaMemberSymbol : MemberSymbol
    {
    }
    
    // ================================================

    symbol SourceAssemblySymbol : MetadataOrSourceAssemblySymbol
    {
    }

    symbol SourceModuleSymbol : NonMissingModuleSymbol
    {
    }

    symbol SourceNamespaceSymbol : NamespaceSymbol
    {
    }

    abstract symbol SourceMemberContainerTypeSymbol : NamedTypeSymbol
    {
    }

    symbol SourceNamedTypeSymbol : SourceMemberContainerTypeSymbol
    {
    }

    symbol SourceAnonymousTypeSymbol : SourceNamedTypeSymbol
    {
    }    
    
    symbol ImplicitNamedTypeSymbol : SourceMemberContainerTypeSymbol
    {
    }

    symbol DynamicTypeSymbol : TypeSymbol
    {
    }

    symbol SourceMemberSymbol : MemberSymbol
    {
    }
    
    symbol AliasSymbol : Symbol
    {
    }
}


namespace MetaDslx.CodeAnalysis.Binding.Binders
{
    binder Binder
    {
    }

    binder BuckStopsHereBinder : Binder
    {
    }

    binder class HostObjectModelBinder : Binder
    {
    }

    binder ValueBinder : Binder
    {
    }
    
    binder EnumValueBinder : ValueBinder
    {
    }

    binder SymbolDefBinder : Binder
    {
    }

    binder SymbolUseBinder : Binder
    {
    }

    binder AttributeBinder : SymbolUseBinder
    {
    }
    
    binder SpecialSymbolBinder : Binder
    {
    }

    binder InContainerBinder : Binder
    {
    }

    binder ScopeBinder : Binder
    {
    }

    binder LocalScopeBinder : Binder
    {
    }
    
    binder PropertyBinder : Binder
    {
    }

    binder NameBinder : Binder
    {
    }

    binder QualifierBinder : Binder
    {
    }

    binder IdentifierBinder : Binder
    {
    }
    
    binder CustomBinder : Binder
    {
    }    
}

