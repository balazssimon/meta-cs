namespace MetaDslx.Languages.Meta.Generator;
generator MetaModelGenerator for IEnumerable<ImmutableObject>;

using MetaDslx.Modeling;
using MetaDslx.Languages.Meta.Model;
using System.Collections.Immutable;
using Roslyn.Utilities;

extern function string EscapeName(string name)
extern function string ToCSharpAlias(string name)
extern function string GenerateDefaultValue(MetaProperty property)
extern function IEnumerable<ValueTuple<MetaProperty,MetaProperty>> GetAssociations(IEnumerable<ImmutableObject> objects)
extern function MetaElement GetType(MetaTypedElement melem)
extern function MetaElement GetReturnType(MetaOperation mop)

template Generate(MetaModel metaModel)
namespace [metaModel.Namespace.FullName]
{
    metamodel [metaModel.Name.EscapeName()](Uri="[metaModel.Uri]",Prefix="[metaModel.Prefix]"); 
^
	[loop(Instances->cst:typeof(MetaConstant))]
    [GenerateConstant(cst)]
	[end loop]
	[loop(Instances->enm:typeof(MetaEnum))]
^
    [GenerateEnum(enm)]
	[end loop]
	[loop(Instances->cls:typeof(MetaClass))]
^
    [GenerateClass(cls)]
	[end loop]
^
	[loop(assoc:GetAssociations(Instances))]
    [GenerateAssociation(assoc)]
	[end loop]
}
end template

template GenerateConstant(MetaConstant cst)
[GenerateComment(cst)]
const [GenerateType(GetType(cst))] [cst.Name.EscapeName()];
end template

template GenerateEnum(MetaEnum enm)
[GenerateComment(enm)]
enum [enm.Name.EscapeName()]
{
	[loop(enm->lit:EnumLiterals; separator sep = ",")]
    [GenerateComment(lit)]
    [lit.Name.EscapeName()][sep]
	[end loop]
}
end template

template GenerateClass(MetaClass cls)
[GenerateComment(cls)]
[cls.IsAbstract ? "abstract " : ""]class [cls.Name.EscapeName()][GenerateBaseClasses(cls)]
{
	[loop(cls->prop:Properties)]
	[GenerateProperty(prop)]
	[end loop]
	[loop(cls->op:Operations)]
	[GenerateOperation(op)]
	[end loop]
}
end template

template GenerateBaseClasses(MetaClass cls)
[string sep = " : "]
[loop(cls->gen:SuperClasses)]
[sep][gen.Name.EscapeName()]\
[sep = ", "]
[end loop]
end template

template GenerateProperty(MetaProperty prop)
[GenerateComment(prop)]
[GenerateContainment(prop)][GenerateModifiers(prop)][GenerateType(GetType(prop))] [prop.Name.EscapeName()][prop.GenerateDefaultValue()][GenerateRedefines(prop)][GenerateSubsets(prop)];
end template

function string GenerateContainment(MetaProperty prop)
	return prop.IsContainment ? "containment " : "";
end function

function string GenerateModifiers(MetaProperty prop)
	switch (prop.Kind)
	case MetaPropertyKind.Readonly: return "readonly ";
	case MetaPropertyKind.Lazy: return "lazy ";
	case MetaPropertyKind.Derived: return "derived ";
	case MetaPropertyKind.DerivedUnion: return "union ";
	end switch
	return "";
end function

function string GenerateType(MetaElement t)
	if (t is MetaCollectionType)
		string typeName = GenerateType(((MetaCollectionType)t).InnerType);
		switch (((MetaCollectionType)t).Kind)
		case MetaCollectionKind.Enumerable: return "enumerable<"+typeName+">";
		case MetaCollectionKind.Set: return "set<"+typeName+">";
		case MetaCollectionKind.List: return "list<"+typeName+">";
		case MetaCollectionKind.MultiSet: return "multi_set<"+typeName+">";
		case MetaCollectionKind.MultiList: return "multi_list<"+typeName+">";
		default: return typeName;
		end switch
	else if (t is MetaNullableType)
		return GenerateNullableType((MetaNullableType)t);
	else if (t is MetaPrimitiveType)
		return GeneratePrimitiveType((MetaPrimitiveType)t);
	else if (t is MetaClass)
		return ((MetaClass)t).Name.EscapeName();
	else if (t is MetaEnum)
		return ((MetaEnum)t).Name.EscapeName();
	else if (t is MetaConstant)
		return ((MetaConstant)t).Name.EscapeName();
	else
		return "ERROR";
	end if
end function

function string GenerateNullableType(MetaNullableType t)
	return GenerateType((MetaNullableType)t)+"?";
end function

function string GeneratePrimitiveType(MetaPrimitiveType t)
	return t.DotNetName.ToCSharpAlias();
end function

template GenerateRedefines(MetaProperty prop)
[string sep = " redefines "]
[loop(prop->rprop:RedefinedProperties)]
	[if (rprop.Class != null)]
[sep][rprop.Class.Name.EscapeName()].[rprop.Name.EscapeName()]\
[sep = ", "]
	[end if]
[end loop]
end template

template GenerateSubsets(MetaProperty prop)
[string sep = " subsets "]
[loop(prop->sprop:SubsettedProperties)]
	[if (sprop.Class != null)]
[sep][sprop.Class.Name.EscapeName()].[sprop.Name.EscapeName()]\
[sep = ", "]
	[end if]
[end loop]
end template

template GenerateOperation(MetaOperation op)
[GenerateComment(op)]
[GenerateReturnType(op)] [op.Name.EscapeName()]([GenerateParams(op)]);
end template

template GenerateReturnType(MetaOperation op)
[var returnType = GetReturnType(op)]
[if (op.IsReadonly)]
readonly \
[end if]
[if (op.IsBuilder)]
builder \
[end if]
[if (returnType == null)]
void
[else]
[GenerateType(returnType)]
[end if]
end template

template GenerateParams(MetaOperation op)
[loop(op->param:Parameters; separator sep = ", ")]
[GenerateType(GetType(param))] [param.Name.EscapeName()][sep]\
[end loop]
end template

template GenerateAssociation(ValueTuple<MetaProperty,MetaProperty> assoc)
[MetaProperty first = assoc.Item1]
[MetaProperty second = assoc.Item2]
association [first.Class.Name.EscapeName()].[first.Name.EscapeName()] with [second.Class.Name.EscapeName()].[second.Name.EscapeName()];
end template

template GenerateComment(MetaDocumentedElement elem)
[loop (elem->line:GetDocumentationLines())]
/// [line]
[end loop]
end template

