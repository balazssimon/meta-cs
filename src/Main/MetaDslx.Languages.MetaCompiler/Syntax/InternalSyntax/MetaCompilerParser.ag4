parser grammar MetaCompilerParser;

@header 
{
using MetaDslx.Languages.MetaCompiler.Model;
}

options
{
    tokenVocab = MetaCompilerLexer; 
	generateCompiler=true;
}

main: namespaceDeclaration EOF;

$Name
name : identifier;

$Name
qualifiedName : qualifier;

$Qualifier
qualifier : identifier (TDot identifier)*;

$Property(Annotations)
$SymbolUse(Annotation)
attribute : TOpenBracket qualifier TCloseBracket;

$SymbolDef(type=Namespace,nestingProperty=Declarations,merge=true)
namespaceDeclaration: attribute* KNamespace qualifiedName namespaceBody;

$Scope
namespaceBody : TOpenBrace declaration* TCloseBrace;

$Property(Declarations) 
declaration : compilerDeclaration | phaseDeclaration | enumDeclaration | classDeclaration | typedefDeclaration;

$SymbolDef(EnumType)
compilerDeclaration : attribute* KCompiler name TSemicolon;

$SymbolDef(Phase)
phaseDeclaration : attribute* locked? KPhase name phaseJoin? afterPhases? beforePhases? TSemicolon;
$Property(name=IsLocked,value=true)
locked: KLocked;
$Property(JoinsPhase)
phaseJoin: KJoins phaseRef;
$Property(AfterPhases)
afterPhases: KAfter phaseRef (TComma phaseRef)*;
$Property(BeforePhases)
beforePhases: KBefore phaseRef (TComma phaseRef)*;
phaseRef: $SymbolUse(Phase) qualifier;

$SymbolDef(EnumType)
enumDeclaration : attribute* KEnum name enumBody;
$Scope
enumBody : TOpenBrace $Property(EnumLiterals) enumValues (TSemicolon enumMemberDeclaration*)? TCloseBrace;
enumValues : enumValue (TComma enumValue)*;
$SymbolDef(EnumLiteral)
enumValue : attribute* name;
enumMemberDeclaration : $Property(Operations) operationDeclaration;

$Property(Visibility)
visibility 
	: $Value(VisibilityKind.Private) KPrivate 
	| $Value(VisibilityKind.Protected) KProtected
	| $Value(VisibilityKind.Public) KPublic
	| $Value(VisibilityKind.Internal) KInternal
	;

$SymbolDef(Class)
classDeclaration : attribute* visibility? classModifier* classKind name (TColon $Property(SuperClasses) classAncestors)? classBody;
classModifier : abstract_ | sealed_ | fixed_ | partial_ | static_;
classAncestors : classAncestor (TComma classAncestor)*;
classAncestor : $SymbolUse(type=Class) qualifier;
$Scope
classBody : TOpenBrace classPhases? classMemberDeclaration* TCloseBrace;
$Property(Phases)
classPhases: KPhase phaseRef (TComma phaseRef)* TSemicolon;
classMemberDeclaration 
	: $Property(Properties) fieldDeclaration 
	| $Property(Operations) operationDeclaration
	;
$Property(Kind)
classKind
	: $Value(ClassKind.Class) KClass 
	| $Value(ClassKind.Symbol) KSymbol
	| $Value(ClassKind.Binder) KBinder
	;

$SymbolDef(Property)
fieldDeclaration : attribute* visibility? memberModifier* fieldContainment? fieldKind? $Property(Type) typeReference name defaultValue? phase? TSemicolon;
$Property(name=IsContainment,value=true)
fieldContainment : KContainment;
$Property(Kind)
fieldKind
	: $Value(PropertyKind.Readonly) KReadonly 
	| $Value(PropertyKind.Lazy) KLazy 
	| $Value(PropertyKind.Derived) KDerived
	;
memberModifier : partial_ | static_ | virtual_ | abstract_ | sealed_ | new_ | override_;
$Property(DefaultValue)
defaultValue : TAssign $Value stringLiteral;
$Property(Phase)
phase: KPhase phaseRef;

$SymbolUse(Property)
nameUseList : qualifier (TComma qualifier)*;

$SymbolDef(TypeDefType)
typedefDeclaration : KTypeDef name typedefValue TSemicolon;
$Property(DotNetType)
typedefValue : TAssign $Value stringLiteral;

$SymbolUse(DataType)
returnType : typeReference | voidType;
$SymbolUse(DataType)
typeOfReference : typeReference;
$SymbolUse(DataType)
typeReference : simpleOrDictionaryType;
simpleOrDictionaryType : simpleOrArrayType | dictionaryType;
simpleOrArrayType : simpleOrGenericType | arrayType;
simpleOrGenericType: simpleType | genericType;
$SymbolUse(DataType)
simpleType : primitiveType | objectType | nullableType | classType;

$SymbolUse(types=(Class,EnumType,TypeDefType))
classType : qualifier;

$Identifier
objectType 
	: KObject 
	| KString
	;

$Identifier
primitiveType 
	: KInt 
	| KLong 
	| KFloat 
	| KDouble 
	| KByte 
	| KBool
	;

$Identifier
voidType 
	: KVoid
	;

$SymbolDef(NullableType)
nullableType : $Property(InnerType) primitiveType TQuestion;

$SymbolDef(GenericType)
genericType : $Property(Type) classType TLessThan typeArguments TGreaterThan;
$Property(TypeArguments)
typeArguments : typeReference (TComma typeReference)*;
	
$SymbolDef(ArrayType)
arrayType : $Property(InnerType) simpleOrGenericType TOpenBracket TCloseBracket;

$SymbolDef(DictionaryType)
dictionaryType : $Property(KeyType) key=simpleOrArrayType TRightArrow $Property(ValueType) value=simpleOrArrayType;

$SymbolDef(Operation)
operationDeclaration : attribute* visibility? memberModifier* $Property(ReturnType) returnType name TOpenParen $Property(Parameters) parameterList? TCloseParen TSemicolon;

parameterList : parameter (TComma parameter)*;

$SymbolDef(Parameter)
parameter : attribute* $Property(Type) typeReference name defaultValue?;

$Property(name=IsStatic,value=true)
static_ : KStatic;
$Property(name=IsFixed,value=true)
fixed_ : KFixed;
$Property(name=IsPartial,value=true)
partial_ : KPartial;
$Property(name=IsAbstract,value=true)
abstract_ : KAbstract;
$Property(name=IsVirtual,value=true)
virtual_ : KVirtual;
$Property(name=IsSealed,value=true)
sealed_ : KSealed;
$Property(name=IsOverride,value=true)
override_ : KOverride;
$Property(name=IsNew,value=true)
new_ : KNew;

// Additional rules for lexer:

// Identifiers
$Identifier
identifier 
	: IdentifierNormal 
	| IdentifierVerbatim
	;

// Literals
literal 
    : nullLiteral
	| booleanLiteral
	| integerLiteral
	| decimalLiteral
	| scientificLiteral
    | stringLiteral
	;

// Null literal
$Value
nullLiteral : KNull;

// Boolean literals
$Value
booleanLiteral : KTrue | KFalse;

// Number literals
$Value
integerLiteral : LInteger;
$Value
decimalLiteral : LDecimal;
$Value
scientificLiteral : LScientific;

// String literals
$Value
stringLiteral : LRegularString;
