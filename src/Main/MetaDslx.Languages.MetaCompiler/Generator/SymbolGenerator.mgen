namespace MetaDslx.Languages.MetaCompiler.Generator;
generator SymbolGenerator for IEnumerable<ImmutableObject>;

using MetaDslx.Modeling;
using MetaDslx.Languages.MetaCompiler.Model;
using System.Collections.Immutable;
using Roslyn.Utilities;

extern function string GenerateDefaultValue(Property property)
extern function string GenerateType(DataType typ)
extern function string Start(Phase phase)
extern function string Finish(Phase phase)
extern function string SymbolNamespace()
extern function string Visibility(MemberDeclaration member, string defaultValue)
extern function string VirtualModifier(MemberDeclaration member, string defaultValue)
extern function string GetVisitName(Symbol symbol)
extern function bool IsBaseSymbol(Symbol symbol)
extern function bool IsMetaSymbol(Symbol symbol)
extern function bool IsSourceSymbol(Symbol symbol)
extern function bool VisitSymbol(Symbol symbol)

template GenerateSymbols()
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Reflection.PortableExecutable;
using System.Threading;
using System.Threading.Tasks;
using MetaDslx.CodeAnalysis.Declarations;
using MetaDslx.CodeAnalysis.Symbols;
using MetaDslx.CodeAnalysis.Syntax;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.PooledObjects;
using Microsoft.CodeAnalysis.Text;
using Roslyn.Utilities;
^
[GenerateCompletionGraph()]
[GenerateSymbolKind()]
^
[loop (Instances->ns:typeof(Namespace) where ns.Declarations.OfType<Symbol>().Any())]
[GenerateSymbolsNamespace(ns)]
[end loop]
^
[GenerateSymbolVisitor()]
end template

template GenerateSymbolsNamespace(Namespace ns)
[var symbols = ns.Declarations.OfType<Symbol>()]
namespace [ns.FullName].Base
{
	[loop(symbol:symbols)]
    ^
	[GenerateSymbolClass(symbol)]
	[end loop]
}
end template

template GenerateMetaSymbols()
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Reflection.PortableExecutable;
using System.Threading;
using System.Threading.Tasks;
using MetaDslx.CodeAnalysis.Declarations;
using MetaDslx.CodeAnalysis.Symbols;
using MetaDslx.CodeAnalysis.Syntax;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.PooledObjects;
using Microsoft.CodeAnalysis.Text;
using Roslyn.Utilities;
^
[loop (Instances->ns:typeof(Namespace) where ns.Declarations.OfType<Symbol>().Any())]
[GenerateMetaSymbolsNamespace(ns)]
[end loop]
end template

template GenerateMetaSymbolsNamespace(Namespace ns)
[var symbols = ns.Declarations.OfType<Symbol>()]
namespace [ns.FullName].Metadata
{
    using [ns.FullName];
    ^
	[loop(symbol:symbols)]
    ^
	[GenerateMetaSymbolClass(symbol)]
	[end loop]
}
end template

template GenerateSourceSymbols()
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Reflection.PortableExecutable;
using System.Threading;
using System.Threading.Tasks;
using MetaDslx.CodeAnalysis.Declarations;
using MetaDslx.CodeAnalysis.Symbols;
using MetaDslx.CodeAnalysis.Syntax;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.PooledObjects;
using Microsoft.CodeAnalysis.Text;
using Roslyn.Utilities;
^
[loop (Instances->ns:typeof(Namespace) where ns.Declarations.OfType<Symbol>().Any())]
[GenerateSourceSymbolsNamespace(ns)]
[end loop]
end template

template GenerateSourceSymbolsNamespace(Namespace ns)
[var symbols = ns.Declarations.OfType<Symbol>()]
namespace [ns.FullName].Source
{
    using [ns.FullName];
    using [ns.FullName].Metadata;
    ^
	[loop(symbol:symbols)]
	[GenerateSourceSymbolClass(symbol)]
	[end loop]
}
end template

template GenerateCompletionGraph()
namespace [SymbolNamespace()]
{
	public sealed partial class CompletionPart
	{
		[loop(Instances->phase:typeof(Phase))]
            [if (phase.IsLocked)]
		public static readonly CompletionPart [phase.Start()] = new CompletionPart(nameof([phase.Start()]));
		public static readonly CompletionPart [phase.Finish()] = new CompletionPart(nameof([phase.Finish()]));
            [else]
		public static readonly CompletionPart [phase.Name] = new CompletionPart(nameof([phase.Name]));
            [end if]
		[end loop]
		^
		[loop(Instances->symbol:typeof(Symbol) where symbol.Kind == ClassKind.Symbol)]
			[if (hasloop(symbol->prop:GetAllProperties(true) where prop.Phase != null))]
		public static readonly ImmutableHashSet<CompletionPart> [symbol.Name]All = CompletionPart.Combine([loop(symbol->prop:GetAllProperties(true) where prop.Phase != null; separator comma = ", ")][if (prop.Phase.IsLocked)][prop.Phase.Start()], [prop.Phase.Finish()][else][prop.Phase.Name][end if][comma][end loop]);
			[end if]
		[end loop]
        ^
		public static CompletionGraphBuilder ConstructCompletionGraph()
		{
			CompletionGraphBuilder builder = new CompletionGraphBuilder();
			[loop(Instances->phase:typeof(Phase))]
                [if (phase.AfterPhases.Count+phase.BeforePhases.Count > 0)]
                    [if (phase.IsLocked)]
			builder.Add([phase.Start()]);
		   	builder.Add([phase.Finish()]);
                    [else]
			builder.Add([phase.Name]);
                    [end if]
                [else]
                    [if (phase.IsLocked)]
			builder.AddLast([phase.Start()]);
		   	builder.AddLast([phase.Finish()]);
                    [else]
			builder.AddLast([phase.Name]);
                    [end if]
                [end if]
			[end loop]
			[loop(Instances->phase:typeof(Phase))]
                [if (phase.IsLocked)]
			builder.Precedes([phase.Start()], [phase.Finish()]);
                [end if]
                [loop(phase->after:AfterPhases)]
			builder.Precedes([after.Finish()], [phase.Start()]);
                [end loop]
                [loop(phase->before:BeforePhases)]
			builder.Precedes([phase.Finish()], [before.Start()]);
                [end loop]
			[end loop]
			return builder;
		}
	}
}
end template

template GenerateSymbolKind()
namespace [SymbolNamespace()]
{
    /// <summary>
    /// Specifies the possible kinds of symbols.
    /// </summary>
    public class LanguageSymbolKind : EnumObject
    {
        /// <summary>
        /// Symbol is an unknown symbol.
        /// </summary>
        public const string None = nameof(None);
        [loop(Instances->symbol:typeof(Symbol) where symbol.VisitSymbol())]
        ^
        /// <summary>
        /// Symbol is an [symbol.GetVisitName()].
        /// </summary>
        public const string [symbol.GetVisitName()] = nameof([symbol.GetVisitName()]);
        [end loop]
        ^
        protected LanguageSymbolKind(string name)
            : base(name)
        {
        }
        ^
        protected LanguageSymbolKind(EnumObject retargetedValue)
            : base(retargetedValue)
        {
        }
        ^
        static LanguageSymbolKind()
        {
            EnumObject.RegisterDefault<LanguageSymbolKind>(None);
            EnumObject.AutoInit<LanguageSymbolKind>();
        }
        ^
        public static implicit operator LanguageSymbolKind(string name)
        {
            return FromString<LanguageSymbolKind>(name);
        }
        ^
        public static explicit operator LanguageSymbolKind(int value)
        {
            return FromIntUnsafe<LanguageSymbolKind>(value);
        }
    }
}
end template

template GenerateMethodSignature(Operation op)
[GenerateType(op.ReturnType)] [op.Name]([loop (op->param:Parameters; separator comma = ", ")][GenerateType(param.Type)] [param.Name][if (!string.IsNullOrEmpty(param.DefaultValue))] = [param.DefaultValue][end if][comma][end loop])
end template

template GenerateSymbolClass(Symbol symbol)
[var allSuperPhases = symbol.GetAllPhases(false)]
[var allPhases = symbol.GetAllPhases(true)]
[var phases = symbol.GetPhases()]
[var allProps = symbol.GetAllProperties(true)]
public abstract partial class MetadataOrSource[symbol.Name][if (symbol.SuperClasses.Count > 0)] : [loop(symbol->sup:SuperClasses; separator comma = ", ")]MetadataOrSource[sup.Name][end loop][end if]
{
	[loop(symbol->prop:Properties where prop.Phase != null)]
	private [GenerateType(prop.Type)] _[prop.Name.ToCamelCase()]Lazy;
	[end loop]
	^
    [if (symbol.VisitSymbol())]
    public sealed override LanguageSymbolKind Kind => LanguageSymbolKind.[symbol.GetVisitName()];
    [end if]
    ^
	[loop(symbol->prop:Properties where prop.Phase == null && !prop.IsPartial)]
        [if (!string.IsNullOrEmpty(prop.DefaultValue))]
	[prop.Visibility("public")][prop.VirtualModifier("")][GenerateType(prop.Type)] [prop.Name] => [prop.DefaultValue];
        [else]
	[prop.Visibility("public")][prop.VirtualModifier("abstract")][GenerateType(prop.Type)] [prop.Name] { get; }
        [end if]
	[end loop]
    ^
	[loop(symbol->op:Operations where !op.IsPartial)]
	[op.Visibility("public")][op.VirtualModifier("abstract")][GenerateMethodSignature(op)];
	[end loop]
	^
	[loop(symbol->prop:Properties where prop.Phase != null)]
	[prop.Visibility.ToString().ToLower()] [GenerateType(prop.Type)] [prop.Name] 
	{
		get
		{
			if (_[prop.Name.ToCamelCase()]Lazy == default) ForceComplete(CompletionPart.[prop.Phase.Finish()]);
			return _[prop.Name.ToCamelCase()]Lazy;
		}
	}
	[end loop]
	^
	[if (phases.Count > 0)]
    private CompletionState _state;
    ^
	public sealed override bool RequiresCompletion => true;
    ^
    private CompletionState CompletionState
    {
        get
        {
            if (_state == null) Interlocked.CompareExchange(ref _state, CompletionState.Create(this.Language), null);
            return _state;
        }
    }
    ^
    public override void ForceComplete(CompletionPart part = null, SourceLocation locationOpt = null, CancellationToken cancellationToken = default)
    {
        if (part == null) part = CompletionPart.All;
        while (true)
        {
            if (HasComplete(part)) goto done;
            cancellationToken.ThrowIfCancellationRequested();
            var incompletePart = CompletionState.NextIncompletePart;
            [loop (phase:allPhases)]
                [if (phase.IsLocked)]
            if (incompletePart == CompletionPart.[phase.Start()] || incompletePart == CompletionPart.[phase.Finish()])
            {
                if (CompletionState.NotePartComplete(CompletionPart.[phase.Start()]))
                {
                    Compute[phase.Name](cancellationToken);
                    [if (phase.JoinsPhase != null)]
                    [GenerateJoinPhase(phase, allProps.Where(p => p.Phase == phase))]
                    [else]
                    var thisThreadCompleted = CompletionState.NotePartComplete(CompletionPart.[phase.Finish()]);
                    Debug.Assert(thisThreadCompleted);
                    [end if]
                }
            }
                [else]
            if (incompletePart == CompletionPart.[phase.Name])
            {
                Compute[phase.Name](cancellationToken);
                    [if (phase.JoinsPhase != null)]
                [GenerateJoinPhase(phase, allProps.Where(p => p.Phase == phase))]
                    [end if]
            }
                [end if]
            else
            [end loop]
            if (incompletePart == null)
            {
                goto done;
            }
            else
            {
                // This assert will trigger if we forgot to handle any of the completion parts
                Debug.Assert(!CompletionPart.[symbol.Name]All.Contains(incompletePart));
                // any other values are completion parts intended for other kinds of symbols
                CompletionState.NotePartComplete(incompletePart);
            }
            CompletionState.SpinWaitComplete(incompletePart, cancellationToken);
        }
        ^
    done:
        // Don't return until we've seen all of the CompletionParts. This ensures all
        // diagnostics have been reported (not necessarily on this thread).
        CompletionState.SpinWaitComplete(part, cancellationToken);
    }
    ^
    public override bool HasComplete(CompletionPart part)
    {
        return CompletionState.HasComplete(part);
    }
        [loop (phase:phases)]
    ^
    protected [allSuperPhases.Contains(phase) ? "override" : "virtual"] void Compute[phase.Name](CancellationToken cancellationToken)
    {
        [if (allSuperPhases.Contains(phase))]
        base.Compute[phase.Name](cancellationToken);
        [else]
        ForceComplete[phase.Name](cancellationToken);
        [end if]
        [loop (symbol->prop:Properties where prop.Phase == phase)]
        Debug.Assert(_[prop.Name.ToCamelCase()]Lazy != default);
        [end loop]
    }
    ^
    protected [allSuperPhases.Contains(phase) ? "override" : "virtual"] void ForceComplete[phase.Name](CancellationToken cancellationToken)
    {
    }
        [end loop]
    [else if (symbol.Name == "Symbol")]
    ^
    /// <summary>
    /// True if this Symbol should be completed by calling ForceComplete.
    /// Intuitively, true for source entities (from any compilation).
    /// </summary>
    public virtual bool RequiresCompletion => false;
    ^
    public virtual void ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken)
    {
        // must be overridden by source symbols, no-op for other symbols
        Debug.Assert(!this.RequiresCompletion);
    }
    ^
    public virtual bool HasComplete(CompletionPart part)
    {
        // must be overridden by source symbols, no-op for other symbols
        Debug.Assert(!this.RequiresCompletion);
        return true;
    }
    [end if]
    [if (symbol.VisitSymbol())]
    ^
    public override void Accept(SymbolVisitor visitor)
    {
        visitor.Visit[symbol.GetVisitName()](this);
    }
    ^
    public override TResult Accept<TResult>(SymbolVisitor<TResult> visitor)
    {
        return visitor.Visit[symbol.GetVisitName()](this);
    }
    ^
    public override TResult Accept<TArgument, TResult>(SymbolVisitor<TArgument, TResult> visitor, TArgument argument)
    {
        return visitor.Visit[symbol.GetVisitName()](this, argument);
    }
    [end if]
}
end template

template GenerateJoinPhase(Phase phase, IEnumerable<Property> joinedProps)
var children = ArrayBuilder<Symbol>.GetInstance();
[loop(prop:joinedProps)]
children.AddRange([prop.Name]);
[end loop]
^
bool allCompleted = true;
^
if (this.DeclaringCompilation.Options.ConcurrentBuild)
{
    var po = cancellationToken.CanBeCanceled
        ? new ParallelOptions() { CancellationToken = cancellationToken }
        : LanguageCompilation.DefaultParallelOptions;
    ^
    Parallel.For(0, children.Count, po, UICultureUtilities.WithCurrentUICulture<int>(i =>
    {
        var child = children["[i]"];
        ForceCompleteChildByLocation(CompletionPart.[phase.JoinsPhase.Finish()], locationOpt, child, cancellationToken);
    }));
    ^
    foreach (var child in children)
    {
        if (!child.HasComplete(CompletionPart.[phase.JoinsPhase.Finish()]))
        {
            allCompleted = false;
            break;
        }
    }
}
else
{
    foreach (var child in children)
    {
        ForceCompleteChildByLocation(CompletionPart.[phase.JoinsPhase.Finish()], locationOpt, child, cancellationToken);
        allCompleted = allCompleted && child.HasComplete(CompletionPart.[phase.JoinsPhase.Finish()]);
    }
}
^
if (allCompleted)
{
    [if (phase.IsLocked)]
    var thisThreadCompleted = CompletionState.NotePartComplete(CompletionPart.[phase.Finish()]);
    Debug.Assert(thisThreadCompleted);
    [else]
    CompletionState.NotePartComplete(CompletionPart.[phase.Name]);
    [end if]
}
else
{
    // NOTE: we're going to kick out of the completion part loop after this,
    // so not making progress isn't a problem.
    goto done;
}
end template

template GenerateMetaSymbolClass(Symbol symbol)
public partial class Meta[symbol.Name] : MetadataOrSource[symbol.Name]
{
}
end template

template GenerateSourceSymbolClass(Symbol symbol)
public partial class Source[symbol.Name] : Meta[symbol.Name]
{
}
end template

template GenerateSymbolVisitor()
namespace [SymbolNamespace()]
{
    /// <summary>
    /// Virtual dispatch based on a symbol's particular class. 
    /// </summary>
    public class SymbolVisitor
    {
        /// <summary>
        /// Call the correct VisitXXX method in this class based on the particular type of symbol that is passed in.
        /// </summary>
        public virtual void Visit(Symbol symbol)
        {
            if ((object)symbol != null)
            {
                symbol.Accept(this);
            }
        }
        ^
        /// <summary>
        /// The default Visit method called when visiting any <see cref="Symbol" /> and 
        /// if visiting specific symbol method VisitXXX is not overridden
        /// </summary>
        /// <param name="symbol">The visited symbol</param>
        public virtual void DefaultVisit(Symbol symbol)
        {
        }
        [loop(Instances->symbol:typeof(Symbol) where symbol.VisitSymbol())]
        ^
        /// <summary>
        /// Called when visiting an <see cref="[symbol.Name]" />; Override this method with
        /// specific implementation; Calling default <see cref="DefaultVisit" /> if it's not
        /// overridden 
        /// </summary>
        /// <param name="symbol">The visited symbol</param>
        public virtual void Visit[symbol.GetVisitName()]([symbol.Name] symbol)
        {
            DefaultVisit(symbol);
        }
        [end loop]
    }
    ^
    /// <summary>
    /// Virtual dispatch based on a symbol's particular class. 
    /// </summary>
    /// <typeparam name="TResult">Result type</typeparam>
    public class SymbolVisitor<TResult>
    {
        /// <summary>
        /// Call the correct VisitXXX method in this class based on the particular type of symbol that is passed in.
        /// Return default(TResult) if symbol is null
        /// </summary>
        public virtual TResult Visit(Symbol symbol)
        {
            return (object)symbol == null
                ? default(TResult)
                : symbol.Accept(this);
        }
        ^
        /// <summary>
        /// The default Visit method called when visiting any <see cref="Symbol" /> and 
        /// if visiting specific symbol method VisitXXX is not overridden
        /// </summary>
        /// <param name="symbol">The visited symbol</param>
        /// <returns></returns>
        public virtual TResult DefaultVisit(Symbol symbol)
        {
            return default(TResult);
        }
        [loop(Instances->symbol:typeof(Symbol) where symbol.VisitSymbol())]
        ^
        /// <summary>
        /// Called when visiting an <see cref="[symbol.Name]" />; Override this method with
        /// specific implementation; Calling default <see cref="DefaultVisit" /> if it's not
        /// overridden 
        /// </summary>
        /// <param name="symbol">The visited symbol</param>
        /// <returns></returns>
        public virtual TResult Visit[symbol.GetVisitName()]([symbol.Name] symbol)
        {
            return DefaultVisit(symbol);
        }
        [end loop]
    }
    ^
    /// <summary>
    /// Virtual dispatch based on a symbol's particular class. 
    /// </summary>
    /// <typeparam name="TArgument">Additional argument type</typeparam>
    /// <typeparam name="TResult">Result type</typeparam>
    public class SymbolVisitor<TArgument, TResult>
    {
        /// <summary>
        /// Call the correct VisitXXX method in this class based on the particular type of symbol that is passed in.
        /// Return default(TResult) if symbol is null
        /// </summary>
        public virtual TResult Visit(Symbol symbol, TArgument argument = default(TArgument))
        {
            if ((object)symbol == null)
            {
                return default(TResult);
            }

            return symbol.Accept(this, argument);
        }
        ^
        /// <summary>
        /// The default Visit method called when visiting any <see cref="Symbol" /> and 
        /// if visiting specific symbol method VisitXXX is not overridden
        /// </summary>
        /// <param name="symbol">The visited symbol</param>
        /// <param name="argument">Additional argument</param>
        /// <returns></returns>
        public virtual TResult DefaultVisit(Symbol symbol, TArgument argument)
        {
            return default(TResult);
        }
        ^
        [loop(Instances->symbol:typeof(Symbol) where symbol.VisitSymbol())]
        ^
        /// <summary>
        /// Called when visiting an <see cref="[symbol.Name]" />; Override this method with
        /// specific implementation; Calling default <see cref="DefaultVisit" /> if it's not
        /// overridden 
        /// </summary>
        /// <param name="symbol">The visited symbol</param>
        /// <param name="argument">Additional argument</param>
        /// <returns></returns>
        public virtual TResult Visit[symbol.GetVisitName()]([symbol.Name] symbol, TArgument argument)
        {
            return DefaultVisit(symbol, argument);
        }
        [end loop]
    }
}
end template

