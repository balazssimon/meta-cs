namespace MetaDslx.Languages.MetaCompiler.Generator;
generator SymbolGenerator for IEnumerable<ImmutableObject>;

using MetaDslx.Modeling;
using MetaDslx.Languages.MetaCompiler.Model;
using System.Collections.Immutable;
using Roslyn.Utilities;

extern function string GenerateDefaultValue(Property property)
extern function string GenerateType(DataType typ)
extern function string Start(Phase phase)
extern function string Finish(Phase phase)
extern function string SymbolNamespace()
extern function string TrimSymbolSuffix(string name)
extern function string Visibility(MemberDeclaration member, string defaultValue)
extern function string VirtualModifier(MemberDeclaration member, string defaultValue)

template Generate()
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Reflection.PortableExecutable;
using System.Threading;
using System.Threading.Tasks;
using MetaDslx.CodeAnalysis.Declarations;
using MetaDslx.CodeAnalysis.Symbols;
using MetaDslx.CodeAnalysis.Syntax;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.PooledObjects;
using Microsoft.CodeAnalysis.Text;
using Roslyn.Utilities;
^
[GenerateCompletionGraph()]
[GenerateSymbolKind()]
^
[loop (Instances->ns:typeof(Namespace))]
[GenerateNamespace(ns)]
[end loop]
^
[GenerateSymbolVisitor()]
end template

template GenerateNamespace(Namespace ns)
[var symbols = ns.Declarations.OfType<Class>().Where(cls => cls.Kind == ClassKind.Symbol)]
[var compilers = ns.Declarations.OfType<Compiler>()]
namespace [ns.FullName]
{
	[loop(symbol:symbols)]
	[GenerateSymbol(symbol)]
	[end loop]
}
end template

template GenerateSymbol(Class symbol)
[GenerateSymbolClass(symbol)]
^
[if (!symbol.IsAbstract && !symbol.IsPartial && !symbol.IsSealed)]
[GenerateMetaSymbolClass(symbol)]
^
[GenerateSourceSymbolClass(symbol)]
^
[end if]
end template

template GenerateCompletionGraph()
namespace [SymbolNamespace()]
{
	public sealed partial class CompletionPart
	{
		[loop(Instances->phase:typeof(Phase))]
            [if (phase.IsLocked)]
		public static readonly CompletionPart [phase.Start()] = new CompletionPart(nameof([phase.Start()]));
		public static readonly CompletionPart [phase.Finish()] = new CompletionPart(nameof([phase.Finish()]));
            [else]
		public static readonly CompletionPart [phase.Name] = new CompletionPart(nameof([phase.Name]));
            [end if]
		[end loop]
		^
		[loop(Instances->symbol:typeof(Class) where symbol.Kind == ClassKind.Symbol)]
			[if (hasloop(symbol->prop:GetAllProperties(true) where prop.Phase != null))]
		public static readonly ImmutableHashSet<CompletionPart> [symbol.Name]All = CompletionPart.Combine([loop(symbol->prop:GetAllProperties(true) where prop.Phase != null; separator comma = ", ")][if (prop.Phase.IsLocked)][prop.Phase.Start()], [prop.Phase.Finish()][else][prop.Phase.Name][end if][comma][end loop]);
			[end if]
		[end loop]
        ^
		public static CompletionGraphBuilder ConstructCompletionGraph()
		{
			CompletionGraphBuilder builder = new CompletionGraphBuilder();
			[loop(Instances->phase:typeof(Phase))]
                [if (phase.AfterPhases.Count+phase.BeforePhases.Count > 0)]
                    [if (phase.IsLocked)]
			builder.Add([phase.Start()]);
		   	builder.Add([phase.Finish()]);
                    [else]
			builder.Add([phase.Name]);
                    [end if]
                [else]
                    [if (phase.IsLocked)]
			builder.AddLast([phase.Start()]);
		   	builder.AddLast([phase.Finish()]);
                    [else]
			builder.AddLast([phase.Name]);
                    [end if]
                [end if]
			[end loop]
			[loop(Instances->phase:typeof(Phase))]
                [if (phase.IsLocked)]
			builder.Precedes([phase.Start()], [phase.Finish()]);
                [end if]
                [loop(phase->after:AfterPhases)]
			builder.Precedes([after.Finish()], [phase.Start()]);
                [end loop]
                [loop(phase->before:BeforePhases)]
			builder.Precedes([phase.Finish()], [before.Start()]);
                [end loop]
			[end loop]
			return builder;
		}
	}
}
end template

template GenerateSymbolKind()
namespace [SymbolNamespace()]
{
    /// <summary>
    /// Specifies the possible kinds of symbols.
    /// </summary>
    public class LanguageSymbolKind : EnumObject
    {
        /// <summary>
        /// Symbol is an unknown symbol.
        /// </summary>
        public const string None = nameof(None);
        [loop(Instances->symbol:typeof(Class) where symbol.Kind == ClassKind.Symbol && symbol.IsFixed)]
        ^
        /// <summary>
        /// Symbol is an [symbol.Name.TrimSymbolSuffix()].
        /// </summary>
        public const string [symbol.Name.TrimSymbolSuffix()] = nameof([symbol.Name.TrimSymbolSuffix()]);
        [end loop]
        ^
        protected LanguageSymbolKind(string name)
            : base(name)
        {
        }
        ^
        protected LanguageSymbolKind(EnumObject retargetedValue)
            : base(retargetedValue)
        {
        }
        ^
        static LanguageSymbolKind()
        {
            EnumObject.RegisterDefault<LanguageSymbolKind>(None);
            EnumObject.AutoInit<LanguageSymbolKind>();
        }
        ^
        public static implicit operator LanguageSymbolKind(string name)
        {
            return FromString<LanguageSymbolKind>(name);
        }
        ^
        public static explicit operator LanguageSymbolKind(int value)
        {
            return FromIntUnsafe<LanguageSymbolKind>(value);
        }
    }
}
end template

template GenerateSymbolInterface(Class symbol)
public interface I[symbol.Name][if (symbol.SuperClasses.Count > 0)] : [loop(symbol->sup:SuperClasses; separator comma = ", ")]I[sup.Name][end loop][end if]
{
    [if (symbol.Name == "Symbol")]
    LanguageSymbolKind Kind { get; }
    [end if]
	[loop(symbol->prop:Properties where prop.Visibility == VisibilityKind.Public)]
[prop.IsNew ? "    new ": "    "][GenerateType(prop.Type)] [prop.Name] { get; }
	[end loop]
	[loop(symbol->op:Operations where op.Visibility == VisibilityKind.Public)]
[op.IsNew ? "    new ": "    "][GenerateMethodSignature(op)];
	[end loop]
}
end template

template GenerateMethodSignature(Operation op)
[GenerateType(op.ReturnType)] [op.Name]([loop (op->param:Parameters; separator comma = ", ")][GenerateType(param.Type)] [param.Name][if (!string.IsNullOrEmpty(param.DefaultValue))] = [param.DefaultValue][end if][comma][end loop])
end template

template GenerateSymbolClass(Class symbol)
[var allSuperPhases = symbol.GetAllPhases(false)]
[var allPhases = symbol.GetAllPhases(true)]
[var phases = symbol.GetPhases()]
[var allProps = symbol.GetAllProperties(true)]
public abstract partial class [symbol.Name] : [if (symbol.SuperClasses.Count > 0)][loop(symbol->sup:SuperClasses; separator comma = ", ")][sup.Name][end loop], [else][if (symbol.Name != "Symbol")]Symbol, [end if][end if]I[symbol.Name]
{
	[loop(symbol->prop:Properties where prop.Phase != null)]
	private [GenerateType(prop.Type)] _[prop.Name.ToCamelCase()]Lazy;
	[end loop]
	^
    [if (symbol.Name == "Symbol")]
    public abstract LanguageSymbolKind Kind { get; }
    [else if (symbol.IsFixed)]
    public sealed override LanguageSymbolKind Kind => LanguageSymbolKind.[symbol.Name.TrimSymbolSuffix()];
    [end if]
    ^
	[loop(symbol->prop:Properties where prop.Phase == null && !prop.IsPartial)]
        [if (!string.IsNullOrEmpty(prop.DefaultValue))]
	[prop.Visibility("public")][prop.VirtualModifier("")][GenerateType(prop.Type)] [prop.Name] => [prop.DefaultValue];
        [else]
	[prop.Visibility("public")][prop.VirtualModifier("abstract")][GenerateType(prop.Type)] [prop.Name] { get; }
        [end if]
	[end loop]
    ^
	[loop(symbol->op:Operations where !op.IsPartial)]
	[op.Visibility("public")][op.VirtualModifier("abstract")][GenerateMethodSignature(op)];
	[end loop]
	^
	[loop(symbol->prop:Properties where prop.Phase != null)]
	[prop.Visibility.ToString().ToLower()] [GenerateType(prop.Type)] [prop.Name] 
	{
		get
		{
			if (_[prop.Name.ToCamelCase()]Lazy == default) ForceComplete(CompletionPart.[prop.Phase.Finish()]);
			return _[prop.Name.ToCamelCase()]Lazy;
		}
	}
	[end loop]
	^
	[if (phases.Count > 0)]
    private CompletionState _state;
    ^
	public sealed override bool RequiresCompletion => true;
    ^
    private CompletionState CompletionState
    {
        get
        {
            if (_state == null) Interlocked.CompareExchange(ref _state, CompletionState.Create(this.Language), null);
            return _state;
        }
    }
    ^
    public override void ForceComplete(CompletionPart part = null, SourceLocation locationOpt = null, CancellationToken cancellationToken = default)
    {
        if (part == null) part = CompletionPart.All;
        while (true)
        {
            if (HasComplete(part)) goto done;
            cancellationToken.ThrowIfCancellationRequested();
            var incompletePart = CompletionState.NextIncompletePart;
            [loop (phase:allPhases)]
                [if (phase.IsLocked)]
            if (incompletePart == CompletionPart.[phase.Start()] || incompletePart == CompletionPart.[phase.Finish()])
            {
                if (CompletionState.NotePartComplete(CompletionPart.[phase.Start()]))
                {
                    Complete[phase.Name](cancellationToken);
                    [if (phase.JoinsPhase != null)]
                    [GenerateJoinPhase(phase, allProps.Where(p => p.Phase == phase))]
                    [else]
                    var thisThreadCompleted = CompletionState.NotePartComplete(CompletionPart.[phase.Finish()]);
                    Debug.Assert(thisThreadCompleted);
                    [end if]
                }
            }
                [else]
            if (incompletePart == CompletionPart.[phase.Name])
            {
                Complete[phase.Name](cancellationToken);
                    [if (phase.JoinsPhase != null)]
                [GenerateJoinPhase(phase, allProps.Where(p => p.Phase == phase))]
                    [end if]
            }
                [end if]
            else
            [end loop]
            if (incompletePart == null)
            {
                goto done;
            }
            else
            {
                // This assert will trigger if we forgot to handle any of the completion parts
                Debug.Assert(!CompletionPart.[symbol.Name]All.Contains(incompletePart));
                // any other values are completion parts intended for other kinds of symbols
                CompletionState.NotePartComplete(incompletePart);
            }
            CompletionState.SpinWaitComplete(incompletePart, cancellationToken);
        }
        ^
    done:
        // Don't return until we've seen all of the CompletionParts. This ensures all
        // diagnostics have been reported (not necessarily on this thread).
        CompletionState.SpinWaitComplete(part, cancellationToken);
    }
    ^
    public override bool HasComplete(CompletionPart part)
    {
        return CompletionState.HasComplete(part);
    }
        [loop (phase:phases)]
    ^
    protected [allSuperPhases.Contains(phase) ? "override" : "virtual"] void Complete[phase.Name](CancellationToken cancellationToken)
    {
        [if (allSuperPhases.Contains(phase))]
        base.ComputePhase[phase.Name](cancellationToken);
        [else]
        ComputePhase[phase.Name](cancellationToken);
        [end if]
        [loop (symbol->prop:Properties where prop.Phase == phase)]
        Debug.Assert(_[prop.Name.ToCamelCase()]Lazy != default);
        [end loop]
    }
    ^
    protected abstract void ComputePhase[phase.Name](CancellationToken cancellationToken);
        [end loop]
    [else if (symbol.Name == "Symbol")]
    ^
    /// <summary>
    /// True if this Symbol should be completed by calling ForceComplete.
    /// Intuitively, true for source entities (from any compilation).
    /// </summary>
    public virtual bool RequiresCompletion => false;
    ^
    public virtual void ForceComplete(SourceLocation locationOpt, CancellationToken cancellationToken)
    {
        // must be overridden by source symbols, no-op for other symbols
        Debug.Assert(!this.RequiresCompletion);
    }
    ^
    public virtual bool HasComplete(CompletionPart part)
    {
        // must be overridden by source symbols, no-op for other symbols
        Debug.Assert(!this.RequiresCompletion);
        return true;
    }
    [end if]
    [if (symbol.Name == "Symbol")]
    ^
    protected static void ForceCompleteChildByLocation(CompletionPart part, SourceLocation locationOpt, Symbol child, CancellationToken cancellationToken)
    {
        if (locationOpt == null || child.IsDefinedInSourceTree(locationOpt.SourceTree, locationOpt?.SourceSpan, cancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            child.ForceComplete(part, locationOpt, cancellationToken);
        }
    }
    ^
    /// <summary>
    /// Helper for implementing <see cref="DeclaringSyntaxReferences"/> for derived classes that store a location but not a 
    /// <see cref="LanguageSyntaxNode"/> or <see cref="SyntaxReference"/>.
    /// </summary>
    protected static ImmutableArray<SyntaxReference> GetDeclaringSyntaxReferenceHelper<TNode>(ImmutableArray<Location> locations)
        where TNode : LanguageSyntaxNode
    {
        if (locations.IsEmpty)
        {
            return ImmutableArray<SyntaxReference>.Empty;
        }
        ^
        ArrayBuilder<SyntaxReference> builder = ArrayBuilder<SyntaxReference>.GetInstance();
        foreach (Location location in locations)
        {
            // Location may be null. See https://github.com/dotnet/roslyn/issues/28862.
            if (location == null)
            {
                continue;
            }
            if (location.IsInSource)
            {
                SyntaxToken token = (SyntaxToken)location.SourceTree.GetRoot().FindToken(location.SourceSpan.Start);
                if (token.GetKind() != SyntaxKind.None)
                {
                    LanguageSyntaxNode node = token.Parent.FirstAncestorOrSelf<TNode>();
                    if (node != null)
                        builder.Add(node.GetReference());
                }
            }
        }
        ^
        return builder.ToImmutableAndFree();
    }
    ^
    public virtual bool IsDefinedInSourceTree(SyntaxTree tree, TextSpan? definedWithinSpan, CancellationToken cancellationToken = default(CancellationToken))
    {
        var declaringReferences = this.DeclaringSyntaxReferences;
        var container = this.ContainingSymbol;
        if (this.IsImplicitlyDeclared && declaringReferences.Length == 0 && container != null)
        {
            return container.IsDefinedInSourceTree(tree, definedWithinSpan, cancellationToken);
        }
        ^
        foreach (var syntaxRef in declaringReferences)
        {
            cancellationToken.ThrowIfCancellationRequested();

            if (syntaxRef.SyntaxTree == tree &&
                (!definedWithinSpan.HasValue || syntaxRef.Span.IntersectsWith(definedWithinSpan.Value)))
            {
                return true;
            }
        }
        ^
        return false;
    }
    ^
    public abstract void Accept(SymbolVisitor visitor);
    ^
    public abstract TResult Accept<TResult>(SymbolVisitor<TResult> visitor);
    ^
    public abstract TResult Accept<TArgument, TResult>(SymbolVisitor<TArgument, TResult> visitor, TArgument argument);
    [else if (symbol.IsFixed)]
    ^
    public override void Accept(SymbolVisitor visitor)
    {
        visitor.Visit[symbol.Name.TrimSymbolSuffix()](this);
    }
    ^
    public override TResult Accept<TResult>(SymbolVisitor<TResult> visitor)
    {
        return visitor.Visit[symbol.Name.TrimSymbolSuffix()](this);
    }
    ^
    public override TResult Accept<TArgument, TResult>(SymbolVisitor<TArgument, TResult> visitor, TArgument argument)
    {
        return visitor.Visit[symbol.Name.TrimSymbolSuffix()](this, argument);
    }
    [end if]
}
end template

template GenerateJoinPhase(Phase phase, IEnumerable<Property> joinedProps)
var children = ArrayBuilder<Symbol>.GetInstance();
[loop(prop:joinedProps)]
children.AddRange([prop.Name]);
[end loop]
^
bool allCompleted = true;
^
if (this.DeclaringCompilation.Options.ConcurrentBuild)
{
    var po = cancellationToken.CanBeCanceled
        ? new ParallelOptions() { CancellationToken = cancellationToken }
        : LanguageCompilation.DefaultParallelOptions;
    ^
    Parallel.For(0, children.Count, po, UICultureUtilities.WithCurrentUICulture<int>(i =>
    {
        var child = children["[i]"];
        ForceCompleteChildByLocation(CompletionPart.[phase.JoinsPhase.Finish()], locationOpt, child, cancellationToken);
    }));
    ^
    foreach (var child in children)
    {
        if (!child.HasComplete(CompletionPart.[phase.JoinsPhase.Finish()]))
        {
            allCompleted = false;
            break;
        }
    }
}
else
{
    foreach (var child in children)
    {
        ForceCompleteChildByLocation(CompletionPart.[phase.JoinsPhase.Finish()], locationOpt, child, cancellationToken);
        allCompleted = allCompleted && child.HasComplete(CompletionPart.[phase.JoinsPhase.Finish()]);
    }
}
^
if (allCompleted)
{
    [if (phase.IsLocked)]
    var thisThreadCompleted = CompletionState.NotePartComplete(CompletionPart.[phase.Finish()]);
    Debug.Assert(thisThreadCompleted);
    [else]
    CompletionState.NotePartComplete(CompletionPart.[phase.Name]);
    [end if]
}
else
{
    // NOTE: we're going to kick out of the completion part loop after this,
    // so not making progress isn't a problem.
    goto done;
}
end template

template GenerateMetaSymbolClass(Class symbol)
public partial class Meta[symbol.Name] : [symbol.Name]
{
}
end template

template GenerateSourceSymbolClass(Class symbol)
public partial class Source[symbol.Name] : Meta[symbol.Name]
{
}
end template

template GenerateSymbolVisitor()
namespace [SymbolNamespace()]
{
    /// <summary>
    /// Virtual dispatch based on a symbol's particular class. 
    /// </summary>
    public class SymbolVisitor
    {
        /// <summary>
        /// Call the correct VisitXXX method in this class based on the particular type of symbol that is passed in.
        /// </summary>
        public virtual void Visit(Symbol symbol)
        {
            if ((object)symbol != null)
            {
                symbol.Accept(this);
            }
        }
        ^
        /// <summary>
        /// The default Visit method called when visiting any <see cref="Symbol" /> and 
        /// if visiting specific symbol method VisitXXX is not overridden
        /// </summary>
        /// <param name="symbol">The visited symbol</param>
        public virtual void DefaultVisit(Symbol symbol)
        {
        }
        [loop(Instances->symbol:typeof(Class) where symbol.Kind == ClassKind.Symbol && symbol.IsFixed && symbol.Name != "Symbol")]
        ^
        /// <summary>
        /// Called when visiting an <see cref="[symbol.Name]" />; Override this method with
        /// specific implementation; Calling default <see cref="DefaultVisit" /> if it's not
        /// overridden 
        /// </summary>
        /// <param name="symbol">The visited symbol</param>
        public virtual void Visit[symbol.Name.TrimSymbolSuffix()]([symbol.Name] symbol)
        {
            DefaultVisit(symbol);
        }
        [end loop]
    }
    ^
    /// <summary>
    /// Virtual dispatch based on a symbol's particular class. 
    /// </summary>
    /// <typeparam name="TResult">Result type</typeparam>
    public class SymbolVisitor<TResult>
    {
        /// <summary>
        /// Call the correct VisitXXX method in this class based on the particular type of symbol that is passed in.
        /// Return default(TResult) if symbol is null
        /// </summary>
        public virtual TResult Visit(Symbol symbol)
        {
            return (object)symbol == null
                ? default(TResult)
                : symbol.Accept(this);
        }
        ^
        /// <summary>
        /// The default Visit method called when visiting any <see cref="Symbol" /> and 
        /// if visiting specific symbol method VisitXXX is not overridden
        /// </summary>
        /// <param name="symbol">The visited symbol</param>
        /// <returns></returns>
        public virtual TResult DefaultVisit(Symbol symbol)
        {
            return default(TResult);
        }
        [loop(Instances->symbol:typeof(Class) where symbol.Kind == ClassKind.Symbol && symbol.IsFixed && symbol.Name != "Symbol")]
        ^
        /// <summary>
        /// Called when visiting an <see cref="[symbol.Name]" />; Override this method with
        /// specific implementation; Calling default <see cref="DefaultVisit" /> if it's not
        /// overridden 
        /// </summary>
        /// <param name="symbol">The visited symbol</param>
        /// <returns></returns>
        public virtual TResult Visit[symbol.Name.TrimSymbolSuffix()]([symbol.Name] symbol)
        {
            return DefaultVisit(symbol);
        }
        [end loop]
    }
    ^
    /// <summary>
    /// Virtual dispatch based on a symbol's particular class. 
    /// </summary>
    /// <typeparam name="TArgument">Additional argument type</typeparam>
    /// <typeparam name="TResult">Result type</typeparam>
    public class SymbolVisitor<TArgument, TResult>
    {
        /// <summary>
        /// Call the correct VisitXXX method in this class based on the particular type of symbol that is passed in.
        /// Return default(TResult) if symbol is null
        /// </summary>
        public virtual TResult Visit(Symbol symbol, TArgument argument = default(TArgument))
        {
            if ((object)symbol == null)
            {
                return default(TResult);
            }

            return symbol.Accept(this, argument);
        }
        ^
        /// <summary>
        /// The default Visit method called when visiting any <see cref="Symbol" /> and 
        /// if visiting specific symbol method VisitXXX is not overridden
        /// </summary>
        /// <param name="symbol">The visited symbol</param>
        /// <param name="argument">Additional argument</param>
        /// <returns></returns>
        public virtual TResult DefaultVisit(Symbol symbol, TArgument argument)
        {
            return default(TResult);
        }
        ^
        [loop(Instances->symbol:typeof(Class) where symbol.Kind == ClassKind.Symbol && symbol.IsFixed && symbol.Name != "Symbol")]
        ^
        /// <summary>
        /// Called when visiting an <see cref="[symbol.Name]" />; Override this method with
        /// specific implementation; Calling default <see cref="DefaultVisit" /> if it's not
        /// overridden 
        /// </summary>
        /// <param name="symbol">The visited symbol</param>
        /// <param name="argument">Additional argument</param>
        /// <returns></returns>
        public virtual TResult Visit[symbol.Name.TrimSymbolSuffix()]([symbol.Name] symbol, TArgument argument)
        {
            return DefaultVisit(symbol, argument);
        }
        [end loop]
    }
}
end template

