namespace MetaDslx.Languages.Antlr4Roslyn.Generator;
generator CompilerGenerator for Antlr4Grammar;

using MetaDslx.Languages.Meta;
using MetaDslx.Languages.Antlr4Roslyn.Compilation;

properties Properties
	string DefaultNamespace;
	string LanguageName;
end properties

template GenerateLanguage()
using System;
using System.Diagnostics;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Symbols;
using MetaDslx.CodeAnalysis.Syntax;
using MetaDslx.CodeAnalysis.Syntax.InternalSyntax;
using [Properties.DefaultNamespace].Symbols;
using [Properties.DefaultNamespace].Syntax;
using [Properties.DefaultNamespace].Syntax.InternalSyntax;
^
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace]
{
    public sealed class [lang]Language : Language
    {
        public static readonly [lang]Language Instance = new [lang]Language();
^
		private [lang]SyntaxFacts _syntaxFacts;
		private [lang]SymbolFacts _symbolFacts;
		private [lang]InternalSyntaxFactory _internalSyntaxFactory;
		private [lang]SyntaxFactory _syntaxFactory;
		private [lang]CompilationFactory _compilationFactory;
^
		private [lang]Language()
		{
			_syntaxFacts = new [lang]SyntaxFacts();
			_internalSyntaxFactory = new [lang]InternalSyntaxFactory(_syntaxFacts);
			_syntaxFactory = new [lang]SyntaxFactory(_internalSyntaxFactory);
			_symbolFacts = new [lang]SymbolFacts();
			_compilationFactory = new [lang]CompilationFactory();
		}
^
        public override string Name => "[lang]";
^
        public new [lang]SyntaxFacts SyntaxFacts => _syntaxFacts;
        protected override SyntaxFacts SyntaxFactsCore => this.SyntaxFacts;
^
        public new [lang]SymbolFacts SymbolFacts => _symbolFacts;
        protected override SymbolFacts SymbolFactsCore => this.SymbolFacts;
^
        internal new [lang]InternalSyntaxFactory InternalSyntaxFactory => _internalSyntaxFactory;
        protected override InternalSyntaxFactory InternalSyntaxFactoryCore => this.InternalSyntaxFactory;
^
        public new [lang]SyntaxFactory SyntaxFactory => _syntaxFactory;
        protected override SyntaxFactory SyntaxFactoryCore => this.SyntaxFactory;
^
        public new [lang]CompilationFactory CompilationFactory => _compilationFactory;
        protected override CompilationFactory CompilationFactoryCore => this.CompilationFactory;
    }
}
end template

template GenerateParseOptions()
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Syntax;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.PooledObjects;
using Roslyn.Utilities;
^
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace].Syntax
{
    /// <summary>
    /// This class stores several source parsing related options and offers access to their values.
    /// </summary>
    public sealed class [lang]ParseOptions : LanguageParseOptions, IEquatable<[lang]ParseOptions>
    {
        /// <summary>
        /// The default parse options.
        /// </summary>
        public static [lang]ParseOptions Default { get; } = new [lang]ParseOptions();

        public [lang]ParseOptions(
            [lang]LanguageVersion languageVersion = null,
            DocumentationMode documentationMode = DocumentationMode.Parse,
            SourceCodeKind kind = SourceCodeKind.Regular,
            IEnumerable<string> preprocessorSymbols = null)
            : this(languageVersion ?? [lang]LanguageVersion.[lang]1,
                  documentationMode,
                  kind,
                  preprocessorSymbols.ToImmutableArrayOrEmpty(),
                  ImmutableDictionary<string, string>.Empty)
        {
        }

        internal [lang]ParseOptions(
            [lang]LanguageVersion languageVersion,
            DocumentationMode documentationMode,
            SourceCodeKind kind,
            ImmutableArray<string> preprocessorSymbols,
            IReadOnlyDictionary<string, string> features)
            : base(languageVersion, documentationMode, kind, preprocessorSymbols, features)
        {
        }

        private [lang]ParseOptions([lang]ParseOptions other) : this(
            languageVersion: ([lang]LanguageVersion)other.LanguageVersion,
            documentationMode: other.DocumentationMode,
            kind: other.Kind,
            preprocessorSymbols: other.PreprocessorSymbols,
            features: other.Features)
        {
        }

        public override Language Language => [lang]Language.Instance;

        public new [lang]ParseOptions WithKind(SourceCodeKind kind)
        {
            if (kind == this.SpecifiedKind)
            {
                return this;
            }

            var effectiveKind = kind.MapSpecifiedToEffectiveKind();
            return new [lang]ParseOptions(this) { SpecifiedKind = kind, Kind = effectiveKind };
        }

        public [lang]ParseOptions WithLanguageVersion([lang]LanguageVersion version)
        {
            if (version == this.SpecifiedLanguageVersion)
            {
                return this;
            }

            var effectiveLanguageVersion = ([lang]LanguageVersion)version.MapSpecifiedToEffectiveVersion();
            return new [lang]ParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion };
        }

        public [lang]ParseOptions WithPreprocessorSymbols(IEnumerable<string> preprocessorSymbols)
        {
            return WithPreprocessorSymbols(preprocessorSymbols.AsImmutableOrNull());
        }

        public [lang]ParseOptions WithPreprocessorSymbols(params string["[]"] preprocessorSymbols)
        {
            return WithPreprocessorSymbols(ImmutableArray.Create(preprocessorSymbols));
        }

        public [lang]ParseOptions WithPreprocessorSymbols(ImmutableArray<string> symbols)
        {
            if (symbols.IsDefault)
            {
                symbols = ImmutableArray<string>.Empty;
            }

            if (symbols.Equals(this.PreprocessorSymbols))
            {
                return this;
            }

            return new [lang]ParseOptions(this) { PreprocessorSymbols = symbols };
        }

        public new [lang]ParseOptions WithDocumentationMode(DocumentationMode documentationMode)
        {
            if (documentationMode == this.DocumentationMode)
            {
                return this;
            }

            return new [lang]ParseOptions(this) { DocumentationMode = documentationMode };
        }

        public override ParseOptions CommonWithKind(SourceCodeKind kind)
        {
            return WithKind(kind);
        }

        protected override ParseOptions CommonWithDocumentationMode(DocumentationMode documentationMode)
        {
            return WithDocumentationMode(documentationMode);
        }

        protected override ParseOptions CommonWithFeatures(IEnumerable<KeyValuePair<string, string>> features)
        {
            return WithFeatures(features);
        }

        /// <summary>
        /// Enable some experimental language features for testing.
        /// </summary>
        public new [lang]ParseOptions WithFeatures(IEnumerable<KeyValuePair<string, string>> features)
        {
            ImmutableDictionary<string, string> dictionary =
                features?.ToImmutableDictionary(StringComparer.OrdinalIgnoreCase)
                ?? ImmutableDictionary<string, string>.Empty;

            return new [lang]ParseOptions(this) { Features = dictionary };
        }

        public override void ValidateOptions(ArrayBuilder<Diagnostic> builder)
        {
            base.ValidateOptions(builder);

            // Validate LanguageVersion not SpecifiedLanguageVersion, after Latest/Default has been converted:
            if (!LanguageVersion.IsValid())
            {
                builder.Add([lang]ErrorCode.ERR_BadLanguageVersion.ToDiagnosticWithNoLocation(LanguageVersion.ToString()));
            }
        }

        public bool IsFeatureEnabled(string feature)
        {
            throw new NotImplementedException("TODO:MetaDslx");
            /*string featureFlag = feature.RequiredFeature();
            if (featureFlag != null)
            {
                return Features.ContainsKey(featureFlag);
            }
            LanguageVersion availableVersion = LanguageVersion;
            LanguageVersion requiredVersion = feature.RequiredVersion();
            return availableVersion >= requiredVersion;*/
        }

        public override bool Equals(object obj)
        {
            return this.Equals(obj as [lang]ParseOptions);
        }

        public bool Equals([lang]ParseOptions other)
        {
            if (object.ReferenceEquals(this, other))
            {
                return true;
            }

            if (!base.EqualsHelper(other))
            {
                return false;
            }

            return this.LanguageVersion == other.LanguageVersion;
        }

        public override int GetHashCode()
        {
            return
                Hash.Combine(base.GetHashCodeHelper(),
                Hash.Combine((int)this.LanguageVersion, 0));
        }
    }
}
end template

template GenerateFeature()
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
^
namespace [Properties.DefaultNamespace]
{
    public enum [Properties.LanguageName]Feature
    {
        None
    }
^
    public static partial class [Properties.LanguageName]FeatureExtensions
    {
        internal static string RequiredFeature(this [Properties.LanguageName]Feature feature)
        {
            switch (feature)
            {
                default:
                    return null;
            }
        }
^
        internal static LanguageVersion RequiredVersion(this [Properties.LanguageName]Feature feature)
        {
            switch (feature)
            {
                case [Properties.LanguageName]Feature.None:
                    return LanguageVersion.[Properties.LanguageName]1;

                default:
                    throw new ArgumentOutOfRangeException(nameof(feature), "Unexpected value: "+feature);
            }
        }
    }
^
}
end template

template GenerateLanguageVersion()
using System;
using MetaDslx.CodeAnalysis;
using Microsoft.CodeAnalysis;
using Roslyn.Utilities;
^
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace]
{
    /// <summary>
    /// Specifies the language version.
    /// </summary>
    public class [lang]LanguageVersion : LanguageVersion
    {
        /// <summary>
        /// [lang] language version 1
        /// </summary>
        public const string [lang]1 = nameof([lang]1);

        protected [lang]LanguageVersion(string name)
            : base(name)
        {
        }

        protected [lang]LanguageVersion(EnumObject retargetedValue)
            : base(retargetedValue)
        {
        }

        static [lang]LanguageVersion()
        {
            EnumObject.AutoInit<[lang]LanguageVersion>();
        }

        public static implicit operator [lang]LanguageVersion(string name)
        {
            return FromString<[lang]LanguageVersion>(name);
        }

        public static explicit operator [lang]LanguageVersion(int value)
        {
            return FromIntUnsafe<[lang]LanguageVersion>(value);
        }

        public override bool IsValid()
        {
            if (this == [lang]1) return true;
            return false;
        }

        /// <summary>
        /// Map a language version (such as Default, Latest, or CSharpN) to a specific version (CSharpM).
        /// </summary>
        public override LanguageVersion MapSpecifiedToEffectiveVersion()
        {
            if (this == Latest || this == Default || this == LatestMajor || this == Preview)
            {
                return [lang]1;
            }
            return this;
        }

        public override ErrorCode GetErrorCode()
        {
            switch (this.Switch())
            {
                case [lang]1:
                    return [lang]ErrorCode.ERR_FeatureNotAvailableInVersion1;
                default:
                    throw ExceptionUtilities.UnexpectedValue(this);
            }
        }
    }

    public class [lang]RequiredLanguageVersion : RequiredLanguageVersion
    {
        internal LanguageVersion Version { get; }

        internal [lang]RequiredLanguageVersion(LanguageVersion version)
        {
            [lang]LanguageVersion preview = [lang]LanguageVersion.Preview;
            Version = (version == preview.MapSpecifiedToEffectiveVersion()) ? [lang]LanguageVersion.Preview : version;
        }

        public override string ToString() => Version.ToDisplayString();
    }

    public static class LanguageVersionFacts
    {
        /// <summary>
        /// Displays the version number in the format expected on the command-line (/langver flag).
        /// For instance, "6", "7", "7.1", "latest".
        /// </summary>
        public static string ToDisplayString(this LanguageVersion version)
        {
            if (version == [lang]LanguageVersion.[lang]1) return "1";
            if (version == [lang]LanguageVersion.Default) return "default";
            if (version == [lang]LanguageVersion.Latest) return "latest";
            if (version == [lang]LanguageVersion.LatestMajor) return "latestmajor";
            if (version == [lang]LanguageVersion.Preview) return "preview";
            throw ExceptionUtilities.UnexpectedValue(version);
        }

        /// <summary>
        /// Try parse a <see cref="LanguageVersion"/> from a string input, returning default if input was null.
        /// </summary>
        public static bool TryParse(string version, out LanguageVersion result)
        {
            if (version == null)
            {
                result = LanguageVersion.Default;
                return true;
            }

            switch (CaseInsensitiveComparison.ToLower(version))
            {
                case "default":
                    result = LanguageVersion.Default;
                    return true;

                case "latest":
                    result = LanguageVersion.Latest;
                    return true;

                case "latestmajor":
                    result = LanguageVersion.LatestMajor;
                    return true;

                case "preview":
                    result = LanguageVersion.Preview;
                    return true;

                case "1":
                case "1.0":
                    result = [lang]LanguageVersion.[lang]1;
                    return true;
                default:
                    result = LanguageVersion.Default;
                    return false;
            }
        }
        
        public static LanguageVersion CurrentVersion => [lang]LanguageVersion.[lang]1;

    }
}
end template

template GenerateCompilation()
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Text;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Declarations;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
^
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace]
{
    public class [lang]Compilation : LanguageCompilation
    {
        #region Constructors and Factories

        private static readonly [lang]CompilationOptions s_defaultOptions = new [lang]CompilationOptions([lang]Language.Instance, OutputKind.ConsoleApplication);
        private static readonly [lang]CompilationOptions s_defaultSubmissionOptions = new [lang]CompilationOptions([lang]Language.Instance, OutputKind.DynamicallyLinkedLibrary).WithReferencesSupersedeLowerVersions(true);

        /// <summary>
        /// Creates a new compilation from scratch. Methods such as AddSyntaxTrees or AddReferences
        /// on the returned object will allow to continue building up the Compilation incrementally.
        /// </summary>
        /// <param name="assemblyName">Simple assembly name.</param>
        /// <param name="syntaxTrees">The syntax trees with the source code for the new compilation.</param>
        /// <param name="references">The references for the new compilation.</param>
        /// <param name="options">The compiler options to use.</param>
        /// <returns>A new compilation.</returns>
        public static [lang]Compilation Create(
            string assemblyName,
            IEnumerable<SyntaxTree> syntaxTrees = null,
            IEnumerable<MetadataReference> references = null,
            [lang]CompilationOptions options = null)
        {
            return Create(
                assemblyName,
                options ?? s_defaultOptions,
                syntaxTrees,
                references,
                previousSubmission: null,
                returnType: null,
                hostObjectType: null,
                isSubmission: false);
        }

        /// <summary>
        /// Creates a new compilation that can be used in scripting.
        /// </summary>
        public static [lang]Compilation CreateScriptCompilation(
            string assemblyName,
            SyntaxTree syntaxTree = null,
            IEnumerable<MetadataReference> references = null,
            [lang]CompilationOptions options = null,
            [lang]Compilation previousScriptCompilation = null,
            Type returnType = null,
            Type globalsType = null)
        {
            CheckSubmissionOptions(options);
            ValidateScriptCompilationParameters(previousScriptCompilation, returnType, ref globalsType);

            return Create(
                assemblyName,
                options?.WithReferencesSupersedeLowerVersions(true) ?? s_defaultSubmissionOptions,
                (syntaxTree != null) ? new["[]"] { syntaxTree } : NoSyntaxTrees,
                references,
                previousScriptCompilation,
                returnType,
                globalsType,
                isSubmission: true);
        }

        private static [lang]Compilation Create(
            string assemblyName,
            [lang]CompilationOptions options,
            IEnumerable<SyntaxTree> syntaxTrees,
            IEnumerable<MetadataReference> references,
            [lang]Compilation previousSubmission,
            Type returnType,
            Type hostObjectType,
            bool isSubmission)
        {
            Debug.Assert(options != null);
            Debug.Assert(!isSubmission || options.ReferencesSupersedeLowerVersions);

            var compilation = new [lang]Compilation(
                assemblyName,
                options,
                references,
                previousSubmission,
                returnType,
                hostObjectType,
                isSubmission,
                referenceManager: null,
                reuseReferenceManager: false,
                syntaxAndDeclarations: new SyntaxAndDeclarationManager(
                    ImmutableArray<SyntaxTree>.Empty,
                    options.ScriptClassName,
                    options.SourceReferenceResolver,
                    options.Language,
                    isSubmission,
                    state: null));

            if (syntaxTrees != null)
            {
                compilation = compilation.AddSyntaxTrees(syntaxTrees);
            }

            return compilation;
        }

        protected [lang]Compilation(string assemblyName, [lang]CompilationOptions options, IEnumerable<MetadataReference> references, [lang]Compilation previousSubmission, Type submissionReturnType, Type hostObjectType, bool isSubmission, ReferenceManager referenceManager, bool reuseReferenceManager, SyntaxAndDeclarationManager syntaxAndDeclarations, AsyncQueue<CompilationEvent> eventQueue = null)
            : base(assemblyName, options, references, previousSubmission, submissionReturnType, hostObjectType, isSubmission, referenceManager, reuseReferenceManager, syntaxAndDeclarations, eventQueue)
        {
        }

        /// <summary>
        /// Create a duplicate of this compilation with different symbol instances.
        /// </summary>
        protected override LanguageCompilation CreateNew(
            string assemblyName,
            LanguageCompilationOptions options,
            IEnumerable<MetadataReference> references,
            LanguageCompilation previousSubmission,
            Type submissionReturnType,
            Type hostObjectType,
            bool isSubmission,
            ReferenceManager referenceManager,
            bool reuseReferenceManager,
            SyntaxAndDeclarationManager syntaxAndDeclarations,
            AsyncQueue<CompilationEvent> eventQueue = null)
        {
            return new [lang]Compilation(
                assemblyName, 
                ([lang]CompilationOptions)options, 
                references, 
                ([lang]Compilation)previousSubmission, 
                submissionReturnType, 
                hostObjectType, 
                isSubmission, 
                referenceManager, 
                reuseReferenceManager, 
                syntaxAndDeclarations, 
                eventQueue);
        }

        protected override Compilation CommonClone()
        {
            return this.Clone();
        }

        /// <summary>
        /// Creates a new compilation with the specified name.
        /// </summary>
        public new [lang]Compilation WithAssemblyName(string assemblyName) => ([lang]Compilation)base.WithAssemblyName(assemblyName);

        /// <summary>
        /// Creates a new compilation with the specified references.
        /// </summary>
        /// <remarks>
        /// The new <see cref="[lang]Compilation"/> will query the given <see cref="MetadataReference"/> for the underlying
        /// metadata as soon as the are needed.
        ///
        /// The new compilation uses whatever metadata is currently being provided by the <see cref="MetadataReference"/>.
        /// E.g. if the current compilation references a metadata file that has changed since the creation of the compilation
        /// the new compilation is going to use the updated version, while the current compilation will be using the previous (it doesn't change).
        /// </remarks>
        public new [lang]Compilation WithReferences(IEnumerable<MetadataReference> references) => ([lang]Compilation)base.WithReferences(references);

        /// <summary>
        /// Creates a new compilation with the specified references.
        /// </summary>
        public new [lang]Compilation WithReferences(params MetadataReference["[]"] references) => ([lang]Compilation)base.WithReferences(references);

        /// <summary>
        /// Creates a new compilation with the specified compilation options.
        /// </summary>
        public [lang]Compilation WithOptions([lang]CompilationOptions options) => ([lang]Compilation)base.WithOptions(options);

        #endregion

        #region Syntax Trees (maintain an ordered list)

        /// <summary>
        /// Creates a new compilation with additional syntax trees.
        /// </summary>
        public new [lang]Compilation AddSyntaxTrees(params SyntaxTree["[]"] trees) => ([lang]Compilation)base.AddSyntaxTrees(trees);

        /// <summary>
        /// Creates a new compilation with additional syntax trees.
        /// </summary>
        public new [lang]Compilation AddSyntaxTrees(IEnumerable<SyntaxTree> trees) => ([lang]Compilation)base.AddSyntaxTrees(trees);

        /// <summary>
        /// Creates a new compilation without the specified syntax trees. Preserves metadata info for use with trees
        /// added later.
        /// </summary>
        public new [lang]Compilation RemoveSyntaxTrees(params SyntaxTree["[]"] trees) => ([lang]Compilation)base.RemoveSyntaxTrees(trees);

        /// <summary>
        /// Creates a new compilation without the specified syntax trees. Preserves metadata info for use with trees
        /// added later.
        /// </summary>
        public new [lang]Compilation RemoveSyntaxTrees(IEnumerable<SyntaxTree> trees) => ([lang]Compilation)base.RemoveSyntaxTrees(trees);

        /// <summary>
        /// Creates a new compilation without any syntax trees. Preserves metadata info
        /// from this compilation for use with trees added later.
        /// </summary>
        public new [lang]Compilation RemoveAllSyntaxTrees() => ([lang]Compilation)base.RemoveAllSyntaxTrees();

        /// <summary>
        /// Creates a new compilation without the old tree but with the new tree.
        /// </summary>
        public new [lang]Compilation ReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree newTree) => ([lang]Compilation)base.ReplaceSyntaxTree(oldTree, newTree);

        #endregion

        #region References

        /// <summary>
        /// Creates a new compilation with additional metadata references.
        /// </summary>
        public new [lang]Compilation AddReferences(params MetadataReference["[]"] references) => ([lang]Compilation)base.AddReferences(references);

        /// <summary>
        /// Creates a new compilation with additional metadata references.
        /// </summary>
        public new [lang]Compilation AddReferences(IEnumerable<MetadataReference> references) => ([lang]Compilation)base.AddReferences(references);

        /// <summary>
        /// Creates a new compilation without the specified metadata references.
        /// </summary>
        public new [lang]Compilation RemoveReferences(params MetadataReference["[]"] references) => ([lang]Compilation)base.RemoveReferences(references);

        /// <summary>
        /// Creates a new compilation without the specified metadata references.
        /// </summary>
        public new [lang]Compilation RemoveReferences(IEnumerable<MetadataReference> references) => ([lang]Compilation)base.RemoveReferences(references);

        /// <summary>
        /// Creates a new compilation without any metadata references
        /// </summary>
        public new [lang]Compilation RemoveAllReferences() => ([lang]Compilation)base.RemoveAllReferences();

        /// <summary>
        /// Creates a new compilation with an old metadata reference replaced with a new metadata reference.
        /// </summary>
        public new [lang]Compilation ReplaceReference(MetadataReference oldReference, MetadataReference newReference) => ([lang]Compilation)base.ReplaceReference(oldReference, newReference);

        #endregion
    }
}
end template

template GenerateCompilationFactory()
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Collections.Immutable;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Binding;
using MetaDslx.CodeAnalysis.Declarations;
using MetaDslx.CodeAnalysis.Symbols;
using MetaDslx.CodeAnalysis.Symbols.Source;
using MetaDslx.CodeAnalysis.Symbols.Metadata;
using [Properties.DefaultNamespace].Syntax;
using [Properties.DefaultNamespace].Binding;
using [Properties.DefaultNamespace].Symbols;
^
namespace [Properties.DefaultNamespace]
{
    public class [Properties.LanguageName]CompilationFactory : CompilationFactory
    {
        internal [Properties.LanguageName]CompilationFactory()
        {
        }
^
        public override BinderFactoryVisitor CreateBinderFactoryVisitor(BinderFactory binderFactory)
        {
            return new [Properties.LanguageName]BinderFactoryVisitor(binderFactory);
        }
^
        public override BoundNodeFactoryVisitor CreateBoundNodeFactoryVisitor(BoundTree boundTree)
        {
            return new [Properties.LanguageName]BoundNodeFactoryVisitor(boundTree);
        }
^
		public override IsBindableNodeVisitor CreateIsBindableNodeVisitor(BoundTree boundTree)
        {
            return new [Properties.LanguageName]IsBindableNodeVisitor(boundTree);
        }
^
        public override RootSingleDeclaration CreateDeclarationTree(LanguageSyntaxTree syntaxTree, string scriptClassName, bool isSubmission)
        {
            return [Properties.LanguageName]DeclarationTreeBuilderVisitor.ForTree(([Properties.LanguageName]SyntaxTree)syntaxTree, scriptClassName, isSubmission);
        }
^
		public override ImmutableDictionary<string, Symbol> CreateSpecialSymbols(SourceAssemblySymbol assembly)
        {
            var result = ImmutableDictionary.CreateBuilder<string, Symbol>();
            foreach (var specialType in [Properties.LanguageName]Constants.Types)
            {
                var symbol = new MetaNamedTypeSymbol(specialType, assembly);
                result.Add(specialType.MName, symbol);
            }
            return result.ToImmutable();
        }
^
        /*public override ScriptCompilationInfo CreateScriptCompilationInfo(CompilationBase previousSubmission, Type submissionReturnType, Type hostObjectType)
        {
            return new [Properties.LanguageName]ScriptCompilationInfo(([Properties.LanguageName]Compilation)previousSubmission, submissionReturnType, hostObjectType);
        }
^
        public override SymbolBuilder CreateSymbolBuilder(CompilationBase compilation)
        {
            return new [Properties.LanguageName]SymbolBuilder(([Properties.LanguageName]Compilation)compilation);
        }*/
    }
}
end template

template GenerateCompilationOptions()
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Text;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Binding;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.PooledObjects;
^
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace]
{
    public class [lang]CompilationOptions : LanguageCompilationOptions, IEquatable<LanguageCompilationOptions>
    {
        public [lang]CompilationOptions(
            Language language,
            OutputKind outputKind,
            bool reportSuppressedDiagnostics = false,
            string moduleName = null,
            string mainTypeName = null,
            string scriptClassName = null,
            IEnumerable<string> usings = null,
            OptimizationLevel optimizationLevel = OptimizationLevel.Debug,
            bool checkOverflow = false,
            bool allowUnsafe = false,
            string cryptoKeyContainer = null,
            string cryptoKeyFile = null,
            ImmutableArray<byte> cryptoPublicKey = default,
            bool? delaySign = null,
            Platform platform = Platform.AnyCpu,
            ReportDiagnostic generalDiagnosticOption = ReportDiagnostic.Default,
            int warningLevel = 4,
            IEnumerable<KeyValuePair<string, ReportDiagnostic>> specificDiagnosticOptions = null,
            bool concurrentBuild = true,
            bool deterministic = false,
            DateTime currentLocalTime = default,
            bool debugPlusMode = false,
            XmlReferenceResolver xmlReferenceResolver = null,
            SourceReferenceResolver sourceReferenceResolver = null,
            MetadataReferenceResolver metadataReferenceResolver = null,
            AssemblyIdentityComparer assemblyIdentityComparer = null,
            StrongNameProvider strongNameProvider = null,
            bool publicSign = false,
            MetadataImportOptions metadataImportOptions = MetadataImportOptions.Public,
            bool referencesSupersedeLowerVersions = false,
            BinderFlags topLevelBinderFlags = null)
            : base(language, outputKind, reportSuppressedDiagnostics, moduleName, mainTypeName, scriptClassName, usings,
                   optimizationLevel, checkOverflow, allowUnsafe, cryptoKeyContainer, cryptoKeyFile, cryptoPublicKey, delaySign, platform, 
                   generalDiagnosticOption, warningLevel, specificDiagnosticOptions,
                   concurrentBuild, deterministic, currentLocalTime, debugPlusMode, xmlReferenceResolver,
                   sourceReferenceResolver, metadataReferenceResolver, assemblyIdentityComparer,
                   strongNameProvider, publicSign, metadataImportOptions, referencesSupersedeLowerVersions, topLevelBinderFlags)
        {
        }

        protected override LanguageCompilationOptions Clone()
        {
            return new [lang]CompilationOptions(
                language: this.Language,
                outputKind: this.OutputKind,
                reportSuppressedDiagnostics: this.ReportSuppressedDiagnostics,
                moduleName: this.ModuleName,
                mainTypeName: this.MainTypeName,
                scriptClassName: this.ScriptClassName,
                usings: this.Usings,
                optimizationLevel: this.OptimizationLevel,
                checkOverflow: this.CheckOverflow,
                allowUnsafe: this.AllowUnsafe,
                cryptoKeyContainer: this.CryptoKeyContainer,
                cryptoKeyFile: this.CryptoKeyFile,
                cryptoPublicKey: this.CryptoPublicKey,
                delaySign: this.DelaySign,
                platform: this.Platform,
                generalDiagnosticOption: this.GeneralDiagnosticOption,
                warningLevel: this.WarningLevel,
                specificDiagnosticOptions: this.SpecificDiagnosticOptions,
                concurrentBuild: this.ConcurrentBuild,
                deterministic: this.Deterministic,
                currentLocalTime: this.CurrentLocalTime,
                debugPlusMode: this.DebugPlusMode,
                xmlReferenceResolver: this.XmlReferenceResolver,
                sourceReferenceResolver: this.SourceReferenceResolver,
                metadataReferenceResolver: this.MetadataReferenceResolver,
                assemblyIdentityComparer: this.AssemblyIdentityComparer,
                strongNameProvider: this.StrongNameProvider,
                publicSign: this.PublicSign,
                metadataImportOptions: this.MetadataImportOptions,
                referencesSupersedeLowerVersions: this.ReferencesSupersedeLowerVersions,
                topLevelBinderFlags: this.TopLevelBinderFlags);
        }

        public new [lang]CompilationOptions WithTopLevelBinderFlags(BinderFlags flags) => ([lang]CompilationOptions)base.WithTopLevelBinderFlags(flags);
        public new [lang]CompilationOptions WithOutputKind(OutputKind kind) => ([lang]CompilationOptions)base.WithOutputKind(kind);
        public new [lang]CompilationOptions WithModuleName(string moduleName) => ([lang]CompilationOptions)base.WithModuleName(moduleName);
        public new [lang]CompilationOptions WithScriptClassName(string name) => ([lang]CompilationOptions)base.WithScriptClassName(name);
        public new [lang]CompilationOptions WithMainTypeName(string name) => ([lang]CompilationOptions)base.WithMainTypeName(name);
        public new [lang]CompilationOptions WithCryptoKeyContainer(string name) => ([lang]CompilationOptions)base.WithCryptoKeyContainer(name);
        public new [lang]CompilationOptions WithCryptoKeyFile(string path) => ([lang]CompilationOptions)base.WithCryptoKeyFile(path);
        public new [lang]CompilationOptions WithCryptoPublicKey(ImmutableArray<byte> value) => ([lang]CompilationOptions)base.WithCryptoPublicKey(value);
        public new [lang]CompilationOptions WithDelaySign(bool? value) => ([lang]CompilationOptions)base.WithDelaySign(value);
        public new [lang]CompilationOptions WithUsings(ImmutableArray<string> usings) => ([lang]CompilationOptions)base.WithUsings(usings);
        public new [lang]CompilationOptions WithUsings(IEnumerable<string> usings) => ([lang]CompilationOptions)base.WithUsings(usings);
        public new [lang]CompilationOptions WithUsings(params string["[]"] usings) => ([lang]CompilationOptions)base.WithUsings(usings);
        public new [lang]CompilationOptions WithOptimizationLevel(OptimizationLevel value) => ([lang]CompilationOptions)base.WithOptimizationLevel(value);
        public new [lang]CompilationOptions WithOverflowChecks(bool enabled) => ([lang]CompilationOptions)base.WithOverflowChecks(enabled);
        public new [lang]CompilationOptions WithAllowUnsafe(bool enabled) => ([lang]CompilationOptions)base.WithAllowUnsafe(enabled);
        public new [lang]CompilationOptions WithPlatform(Platform platform) => ([lang]CompilationOptions)base.WithPlatform(platform);
        public new [lang]CompilationOptions WithPublicSign(bool publicSign) => ([lang]CompilationOptions)base.WithPublicSign(publicSign);
        public new [lang]CompilationOptions WithGeneralDiagnosticOption(ReportDiagnostic value) => ([lang]CompilationOptions)base.WithGeneralDiagnosticOption(value);
        public new [lang]CompilationOptions WithSpecificDiagnosticOptions(ImmutableDictionary<string, ReportDiagnostic> values) => ([lang]CompilationOptions)base.WithSpecificDiagnosticOptions(values);
        public new [lang]CompilationOptions WithSpecificDiagnosticOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>> values) => ([lang]CompilationOptions)base.WithSpecificDiagnosticOptions(values);
        public new [lang]CompilationOptions WithWarningLevel(int warningLevel) => ([lang]CompilationOptions)base.WithWarningLevel(warningLevel);
        public new [lang]CompilationOptions WithConcurrentBuild(bool concurrentBuild) => ([lang]CompilationOptions)base.WithConcurrentBuild(concurrentBuild);
        public new [lang]CompilationOptions WithDeterministic(bool deterministic) => ([lang]CompilationOptions)base.WithDeterministic(deterministic);
        public new [lang]CompilationOptions WithCurrentLocalTime(DateTime value) => ([lang]CompilationOptions)base.WithCurrentLocalTime(value);
        public new [lang]CompilationOptions WithDebugPlusMode(bool debugPlusMode) => ([lang]CompilationOptions)base.WithDebugPlusMode(debugPlusMode);
        public new [lang]CompilationOptions WithMetadataImportOptions(MetadataImportOptions value) => ([lang]CompilationOptions)base.WithMetadataImportOptions(value);
        public new [lang]CompilationOptions WithReferencesSupersedeLowerVersions(bool value) => ([lang]CompilationOptions)base.WithReferencesSupersedeLowerVersions(value);
        public new [lang]CompilationOptions WithXmlReferenceResolver(XmlReferenceResolver resolver) => ([lang]CompilationOptions)base.WithXmlReferenceResolver(resolver);
        public new [lang]CompilationOptions WithSourceReferenceResolver(SourceReferenceResolver resolver) => ([lang]CompilationOptions)base.WithSourceReferenceResolver(resolver);
        public new [lang]CompilationOptions WithMetadataReferenceResolver(MetadataReferenceResolver resolver) => ([lang]CompilationOptions)base.WithMetadataReferenceResolver(resolver);
        public new [lang]CompilationOptions WithAssemblyIdentityComparer(AssemblyIdentityComparer comparer) => ([lang]CompilationOptions)base.WithAssemblyIdentityComparer(comparer);
        public new [lang]CompilationOptions WithStrongNameProvider(StrongNameProvider provider) => ([lang]CompilationOptions)base.WithStrongNameProvider(provider);

        protected override void ValidateOptions(ArrayBuilder<Diagnostic> builder)
        {
            base.ValidateOptions(builder);
        }

        public override bool Equals(LanguageCompilationOptions other)
        {
            if (other is [lang]CompilationOptions typedOptions) return this.Equals(typedOptions);
            else return base.Equals(other);
        }

        public bool Equals([lang]CompilationOptions other)
        {
            return base.Equals(other);
        }

        public override bool Equals(object obj)
        {
            return this.Equals(obj as [lang]CompilationOptions);
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public override Diagnostic FilterDiagnostic(Diagnostic diagnostic)
        {
            return base.FilterDiagnostic(diagnostic);
        }

    }
}
end template

template GenerateScriptCompilationInfo()
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MetaDslx.Compiler;
^
namespace [Properties.DefaultNamespace]
{
    public class [Properties.LanguageName]ScriptCompilationInfo : ScriptCompilationInfo
    {
        public new [Properties.LanguageName]Compilation PreviousScriptCompilation { get; }
^
        internal [Properties.LanguageName]ScriptCompilationInfo([Properties.LanguageName]Compilation previousCompilationOpt, Type returnType, Type globalsType)
            : base(returnType, globalsType)
        {
            Debug.Assert(previousCompilationOpt == null || previousCompilationOpt.HostObjectType == globalsType);
^
            PreviousScriptCompilation = previousCompilationOpt;
        }
^
        protected override Compilation CommonPreviousScriptCompilation => PreviousScriptCompilation;
^
        public [Properties.LanguageName]ScriptCompilationInfo WithPreviousScriptCompilation([Properties.LanguageName]Compilation compilation) =>
            (compilation == PreviousScriptCompilation) ? this : new [Properties.LanguageName]ScriptCompilationInfo(compilation, ReturnType, GlobalsType);
^
        protected override ScriptCompilationInfo CommonWithPreviousScriptCompilation(Compilation compilation) =>
            WithPreviousScriptCompilation(([Properties.LanguageName]Compilation)compilation);
    }
}
end template


template GenerateErrorCode()
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MetaDslx.CodeAnalysis;
using Microsoft.CodeAnalysis;
^
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace]
{
    public class [lang]ErrorCode : ErrorCode
    {
        public new const string Category = "[Instances.ErrorCodeCategory]";
        public new const string MessagePrefix = "[Instances.MessagePrefix]";
^
        public static readonly [lang]ErrorCode ERR_GeneralError = new [lang]ErrorCode(1, DiagnosticSeverity.Error, "Error", "Error: {0}");
        public static readonly [lang]ErrorCode WRN_GeneralWarning = new [lang]ErrorCode(2, DiagnosticSeverity.Warning, "Warning", "Warning: {0}");
        public static readonly [lang]ErrorCode INF_GeneralInfo = new [lang]ErrorCode(3, DiagnosticSeverity.Info, "Info", "Info: {0}");
        public static readonly [lang]ErrorCode ERR_BadLanguageVersion = new [lang]ErrorCode(4, DiagnosticSeverity.Error, "Bad language version", "Bad [lang] language version: {0}");
        public static readonly [lang]ErrorCode ERR_FeatureNotAvailableInVersion1 = new [lang]ErrorCode(5, DiagnosticSeverity.Error, "Feature not available", "Feature not available in [lang] version 1: {0}");
^
        private [lang]ErrorCode(int code, DiagnosticSeverity defaultSeverity, string title, string messageFormat, bool isEnabledByDefault = true, string description = null, string helpLinkUri = null, params string["[]"] customTags) 
            : base(code, MessagePrefix, title, messageFormat, Category, defaultSeverity, isEnabledByDefault, description, helpLinkUri, customTags)
        {
        }
    }
}
end template

template GenerateSyntaxParser()
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Antlr4.Runtime;
using Antlr4.Runtime.Tree;
using MetaDslx.CodeAnalysis.Syntax;
using MetaDslx.CodeAnalysis.Syntax.InternalSyntax;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Syntax.InternalSyntax;
using Microsoft.CodeAnalysis.Text;
using MetaDslx.Languages.Antlr4Roslyn.Parser;

namespace [Properties.DefaultNamespace].Syntax.InternalSyntax
{
    public class [Properties.LanguageName]SyntaxParser : Antlr4SyntaxParser<[Properties.LanguageName]Lexer, [Properties.LanguageName]Parser>
    {
        public [Properties.LanguageName]SyntaxParser(
            SourceText text,
            [Properties.LanguageName]ParseOptions options,
            SyntaxNode oldTree, 
            IEnumerable<TextChangeRange> changes,
            CancellationToken cancellationToken = default(CancellationToken))
            : base(text, [Properties.LanguageName]Language.Instance, options, oldTree, changes, cancellationToken)
        {
        }

        public override DirectiveStack Directives
        {
            get
            {
                return DirectiveStack.Empty;
            }
        }

        protected override [Properties.LanguageName]Lexer CreateLexer(AntlrInputStream inputStream)
        {
            return new [Properties.LanguageName]Lexer(inputStream);
        }

        protected override [Properties.LanguageName]Parser CreateParser(CommonTokenStream tokenStream)
        {
            return new [Properties.LanguageName]Parser(tokenStream);
        }

        public override GreenNode Parse()
        {
            return this.Parse[Instances.MainRule().PlainName()]();
        }

        internal [Instances.MainRule().GreenName()] Parse[Instances.MainRule().PlainName()]()
        {
            Antlr4ToRoslynVisitor visitor = new Antlr4ToRoslynVisitor(this);
            var tree = this.Parser.[Instances.MainRule().PlainName().ToCamelCase()]();
            return ([Instances.MainRule().GreenName()])visitor.Visit(tree);
        }

        private class Antlr4ToRoslynVisitor : [Properties.LanguageName]ParserBaseVisitor<GreenNode>
        {
			// list pools - allocators for lists that are used to build sequences of nodes. The lists
			// can be reused (hence pooled) since the syntax factory methods don't keep references to
			// them

			private readonly SyntaxListPool _pool = new SyntaxListPool(); // Don't need to reset this.            private [Properties.LanguageName]Language language;
			
			private [Properties.LanguageName]InternalSyntaxFactory factory;
            private [Properties.LanguageName]SyntaxParser syntaxParser;
			private IList<IToken> tokens;
            private IToken lastTokenOrTrivia;

            public Antlr4ToRoslynVisitor([Properties.LanguageName]SyntaxParser syntaxParser)
            {
				this.factory = ([Properties.LanguageName]InternalSyntaxFactory)syntaxParser.Language.InternalSyntaxFactory;
                this.syntaxParser = syntaxParser;
				this.tokens = this.syntaxParser.CommonTokenStream.GetTokens();
                this.lastTokenOrTrivia = null;
            }
			
            private GreenNode VisitTerminal(ITerminalNode node, [Properties.LanguageName]SyntaxKind kind)
            {
                return this.syntaxParser.VisitTerminal(node, kind, ref this.lastTokenOrTrivia);
            }

            public override GreenNode VisitTerminal(ITerminalNode node)
            {
                return this.VisitTerminal(node, null);
            }
			[loop(rule:Instances.ParserRules)]
			[GenerateAntlr4ToRoslynVisitorRule(rule, null)]
			[end loop]
        }
    }

}
end template

template GenerateAntlr4ToRoslynVisitorRule(Antlr4ParserRule rule, Antlr4ParserRule superRule)
[var lang = Properties.LanguageName]
[if (rule.Alternatives.Count > 0)]
	[loop(alt:rule.Alternatives)]
[GenerateAntlr4ToRoslynVisitorRule(alt, rule)]
	[end loop]
[else]
^
public override GreenNode Visit[rule.PlainName()]([lang]Parser.[rule.PlainName()]Context context)
{
	if (context == null) return [rule.GreenName()].__Missing;
	[if (rule.IsSimpleAlt)]
		[loop(elem:rule.Elements)]
	[lang]Parser.[elem.PlainType(false)]Context [elem.FieldName()]Context = context.[elem.GetAccessorName()];
			[if (elem.IsSimplified && elem.IsList && elem.IsSeparated)]
	if ([elem.FieldName()]Context != null) 
	{
		return this.factory.[rule.PlainName()]((([elem.GreenType(TypeKind.Public, false)])this.Visit([elem.FieldName()]Context))?.[elem.Grammar.FindParserRule(elem.OriginalType).Elements[0].GreenName()]);
	}
			[else]
	if ([elem.FieldName()]Context != null) 
	{
		return this.factory.[rule.PlainName()](([elem.GreenType(TypeKind.Public, false)])this.Visit([elem.FieldName()]Context));
	}
			[end if]
		[end loop]
	return [rule.GreenName()].__Missing;
	[else]
	[loop(elem:rule.AllElements)]
		[if(elem.IsSimplified)]
	[lang]Parser.[elem.PlainType(false)]Context [elem.FieldName()]Context = context.[elem.GetAccessorName()];
	[elem.GreenType(TypeKind.Public, false)] [elem.FieldName()] = null;
	if ([elem.FieldName()]Context != null)
	{
		[elem.FieldName()] = ([elem.GreenType(TypeKind.Public, false)])this.Visit([elem.FieldName()]Context);
	}
	else
	{
		[elem.FieldName()] = [elem.GreenType(TypeKind.Public, false)].__Missing;
	}
		[else]
		[if(elem.IsBlock)]
			[if(elem.IsFixedTokenAltBlock)]
	InternalSyntaxToken [elem.FieldName()] = null;
				[loop(item:elem.BlockItems; separator delim = "else ")]
	if (context.[item.GetAccessorName()] != null)
	{
		[elem.FieldName()] = (InternalSyntaxToken)this.VisitTerminal(context.[item.GetAccessorName()]);
	}
	[delim]\
				[end loop]
				[if (!elem.IsOptional)]
					[if (hasloop(item:elem.BlockItems))]
	else
	{
		[elem.FieldName()] = this.factory.MissingToken(SyntaxKind.MissingToken);
	}
					[else]
	[elem.FieldName()] = this.factory.MissingToken(SyntaxKind.MissingToken);
					[end if]
				[end if]
			[else]
	// throw new NotImplementedException("Error in Antlr4Roslyn compiler. Unhandled element: [elem.GreenType(TypeKind.Field)] [elem.FieldName()]");
			[end if]
		[else]
			[if(elem.IsList)]
				[if(elem.IsSeparated)]
    [lang]Parser.[elem.PlainType()]Context["[]"] [elem.FieldName()]Context = context.[elem.GetAccessorName()];
    ITerminalNode["[]"] [elem.Separator.FieldName()]Context = context.[elem.Separator.GetAccessorName()];
    var [elem.FieldName()]Builder = _pool.AllocateSeparated<[elem.GreenInnerType()]>();
    for (int i = 0; i < [elem.FieldName()]Context.Length; i++)
    {
        [elem.FieldName()]Builder.Add(([elem.GreenInnerType()])this.Visit([elem.FieldName()]Context["[i]"]));
        if (i < [elem.Separator.FieldName()]Context.Length)
        {
            [elem.FieldName()]Builder.AddSeparator((InternalSyntaxToken)this.VisitTerminal([elem.Separator.FieldName()]Context["[i]"], [lang]SyntaxKind.[elem.Separator.SyntaxKind()]));
        }
    }
	var [elem.FieldName()] = [elem.FieldName()]Builder.ToList();
	_pool.Free([elem.FieldName()]Builder);
				[else]
					[if(elem.IsToken)]
    ITerminalNode["[]"] [elem.FieldName()]Context = context.[elem.GetAccessorName()];
    var [elem.FieldName()]Builder = _pool.Allocate<[elem.GreenInnerType()]>();
    for (int i = 0; i < [elem.FieldName()]Context.Length; i++)
    {
        [elem.FieldName()]Builder.Add(([elem.GreenInnerType()])this.VisitTerminal([elem.FieldName()]Context["[i]"], [lang]SyntaxKind.[elem.SyntaxKind()]));
    }
	var [elem.FieldName()] = [elem.FieldName()]Builder.ToList();
	_pool.Free([elem.FieldName()]Builder);
					[else]
    [lang]Parser.[elem.PlainType()]Context["[]"] [elem.FieldName()]Context = context.[elem.GetAccessorName()];
    var [elem.FieldName()]Builder = _pool.Allocate<[elem.GreenInnerType()]>();
    for (int i = 0; i < [elem.FieldName()]Context.Length; i++)
    {
        [elem.FieldName()]Builder.Add(([elem.GreenInnerType()])this.Visit([elem.FieldName()]Context["[i]"]));
    }
	var [elem.FieldName()] = [elem.FieldName()]Builder.ToList();
	_pool.Free([elem.FieldName()]Builder);
					[end if]
				[end if]
			[else]
				[if(elem.IsToken)]
					[if (elem.IsOptional)]
	InternalSyntaxToken [elem.FieldName()] = (InternalSyntaxToken)this.VisitTerminal(context.[elem.Antlr4Name()]);
					[else]
	InternalSyntaxToken [elem.FieldName()] = (InternalSyntaxToken)this.VisitTerminal(context.[elem.Antlr4Name()], [lang]SyntaxKind.[elem.SyntaxKind()]);
					[end if]
				[else]
	[lang]Parser.[elem.PlainType()]Context [elem.FieldName()]Context = context.[elem.GetAccessorName()];
	[elem.GreenType(TypeKind.Field)] [elem.FieldName()] = null;
	if ([elem.FieldName()]Context != null)
	{
		[elem.FieldName()] = ([elem.GreenType(TypeKind.Field)])this.Visit([elem.FieldName()]Context);
	}
	else
	{
		[elem.FieldName()] = [elem.GreenType(TypeKind.Field)].__Missing;
	}
				[end if]
			[end if]
		[end if]
		[end if]
	[end loop]
	return this.factory.[rule.PlainName()]([GetRoslynVisitorElemParamList(rule, false, false)]);
	[end if]
}
[end if]
end template


template GenerateSyntaxTree()
[var lang = Properties.LanguageName]
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using [Properties.DefaultNamespace].Syntax;
using [Properties.DefaultNamespace].Syntax.InternalSyntax;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Syntax;
using Microsoft.CodeAnalysis.Text;
using Microsoft.CodeAnalysis;

namespace [Properties.DefaultNamespace]
{
    /// <summary>
    /// The parsed representation of a C# source document.
    /// </summary>
    public abstract partial class [lang]SyntaxTree : LanguageSyntaxTree
    {
        internal static readonly [lang]SyntaxTree Dummy = new DummySyntaxTree();

        /// <summary>
        /// The options used by the parser to produce the syntax tree.
        /// </summary>
        public new abstract [lang]ParseOptions Options { get; }

        // REVIEW: I would prefer to not expose CloneAsRoot and make the functionality
        // internal to CaaS layer, to ensure that for a given SyntaxTree there can not
        // be multiple trees claiming to be its children.
        // 
        // However, as long as we provide GetRoot extensibility point on SyntaxTree
        // the guarantee above cannot be implemented and we have to provide some way for
        // creating root nodes.
        //
        // Therefore I place CloneAsRoot API on SyntaxTree and make it protected to
        // at least limit its visibility to SyntaxTree extenders.

        /// <summary>
        /// Produces a clone of a <see cref="[lang]SyntaxNode"/> which will have current syntax tree as its parent.
        /// 
        /// Caller must guarantee that if the same instance of <see cref="[lang]SyntaxNode"/> makes multiple calls
        /// to this function, only one result is observable.
        /// </summary>
        /// <typeparam name="T">Type of the syntax node.</typeparam>
        /// <param name="node">The original syntax node.</param>
        /// <returns>A clone of the original syntax node that has current <see cref="CSharpSyntaxTree"/> as its parent.</returns>
        protected T CloneNodeAsRoot<T>(T node) where T : [lang]SyntaxNode
        {
            return [lang]SyntaxNode.CloneNodeAsRoot(node, this);
        }

        /// <summary>
        /// Gets the root node of the syntax tree.
        /// </summary>
        public new abstract [lang]SyntaxNode GetRoot(CancellationToken cancellationToken = default(CancellationToken));

        /// <summary>
        /// Gets the root node of the syntax tree if it is already available.
        /// </summary>
        public abstract bool TryGetRoot(out [lang]SyntaxNode root);

        /// <summary>
        /// Gets the root node of the syntax tree asynchronously.
        /// </summary>
        /// <remarks>
        /// By default, the work associated with this method will be executed immediately on the current thread.
        /// Implementations that wish to schedule this work differently should override <see cref="GetRootAsync(CancellationToken)"/>.
        /// </remarks>
        public new virtual Task<[lang]SyntaxNode> GetRootAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            [lang]SyntaxNode node;
            return Task.FromResult(this.TryGetRoot(out node) ? node : this.GetRoot(cancellationToken));
        }

        /// <summary>
        /// Gets the root of the syntax tree statically typed as <see cref="[Instances.MainRule().RedName()]"/>.
        /// </summary>
        /// <remarks>
        /// Ensure that <see cref="SyntaxTree.HasCompilationUnitRoot"/> is true for this tree prior to invoking this method.
        /// </remarks>
        /// <exception cref="InvalidCastException">Throws this exception if <see cref="SyntaxTree.HasCompilationUnitRoot"/> is false.</exception>
        public [Instances.MainRule().RedName()] GetCompilationUnitRoot(CancellationToken cancellationToken = default(CancellationToken))
        {
            return ([Instances.MainRule().RedName()])this.GetRoot(cancellationToken);
        }

        #region Factories

        /// <summary>
        /// Creates a new syntax tree from a syntax node.
        /// </summary>
        public static [lang]SyntaxTree Create([lang]SyntaxNode root, [lang]ParseOptions options = null, string path = "", Encoding encoding = null)
        {
            if (root == null)
            {
                throw new ArgumentNullException(nameof(root));
            }

            var directives = root.Kind == [lang]SyntaxKind.[Instances.MainRule().PlainName()] ?
                ((ICompilationUnitRootSyntax)root).GetConditionalDirectivesStack() :
                DirectiveStack.Empty;

            return new ParsedSyntaxTree(
                textOpt: null,
                encodingOpt: encoding,
                checksumAlgorithm: SourceHashAlgorithm.Sha1,
                path: path,
                options: options ?? [lang]ParseOptions.Default,
                root: root,
                directives: directives);
        }

        /// <summary>
        /// Creates a new syntax tree from a syntax node with text that should correspond to the syntax node.
        /// </summary>
        /// <remarks>This is used by the ExpressionEvaluator.</remarks>
        internal static [lang]SyntaxTree CreateForDebugger([lang]SyntaxNode root, SourceText text, [lang]ParseOptions options)
        {
            Debug.Assert(root != null);

            return new DebuggerSyntaxTree(root, text, options);
        }

        /// <summary>
        /// <para>
        /// Internal helper for <see cref="[lang]SyntaxNode"/> class to create a new syntax tree rooted at the given root node.
        /// This method does not create a clone of the given root, but instead preserves it's reference identity.
        /// </para>
        /// <para>NOTE: This method is only intended to be used from <see cref="[lang]SyntaxNode.SyntaxTree"/> property.</para>
        /// <para>NOTE: Do not use this method elsewhere, instead use <see cref="Create([lang]SyntaxNode, CSharpParseOptions, string, Encoding)"/> method for creating a syntax tree.</para>
        /// </summary>
        internal static [lang]SyntaxTree CreateWithoutClone([lang]SyntaxNode root)
        {
            Debug.Assert(root != null);

            return new ParsedSyntaxTree(
                textOpt: null,
                encodingOpt: null,
                checksumAlgorithm: SourceHashAlgorithm.Sha1,
                path: "",
                options: [lang]ParseOptions.Default,
                root: root,
                directives: DirectiveStack.Empty,
                cloneRoot: false);
        }

        /// <summary>
        /// Produces a syntax tree by parsing the source text.
        /// </summary>
        public static [lang]SyntaxTree ParseText(
            string text,
            [lang]ParseOptions options = null,
            string path = "",
            Encoding encoding = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            return ParseText(SourceText.From(text, encoding), options, path, cancellationToken);
        }

        /// <summary>
        /// Produces a syntax tree by parsing the source text.
        /// </summary>
        public static [lang]SyntaxTree ParseText(
            SourceText text,
            [lang]ParseOptions options = null,
            string path = "",
            CancellationToken cancellationToken = default(CancellationToken))
        {
            if (text == null)
            {
                throw new ArgumentNullException(nameof(text));
            }

            options = options ?? [lang]ParseOptions.Default;

            using (var parser = new [lang]SyntaxParser(text, options, oldTree: null, changes: null, cancellationToken: cancellationToken))
            {
                var compilationUnit = ([Instances.MainRule().RedName()])parser.Parse[Instances.MainRule().PlainName()]().CreateRed();
                var tree = new ParsedSyntaxTree(text, text.Encoding, text.ChecksumAlgorithm, path, options, compilationUnit, parser.Directives);
                tree.VerifySource();
                return tree;
            }
        }

        #endregion

        #region Changes

        /// <summary>
        /// Creates a new syntax based off this tree using a new source text.
        /// </summary>
        /// <remarks>
        /// If the new source text is a minor change from the current source text an incremental parse will occur
        /// reusing most of the current syntax tree internal data.  Otherwise, a full parse will occur using the new
        /// source text.
        /// </remarks>
        public override SyntaxTree WithChangedText(SourceText newText)
        {
            // try to find the changes between the old text and the new text.
            SourceText oldText;
            if (this.TryGetText(out oldText))
            {
                var changes = newText.GetChangeRanges(oldText);

                if (changes.Count == 0 && newText == oldText)
                {
                    return this;
                }

                return this.WithChanges(newText, changes);
            }

            // if we do not easily know the old text, then specify entire text as changed so we do a full reparse.
            return this.WithChanges(newText, new["[]"] { new TextChangeRange(new TextSpan(0, this.Length), newText.Length) });
        }

        private SyntaxTree WithChanges(SourceText newText, IReadOnlyList<TextChangeRange> changes)
        {
            if (changes == null)
            {
                throw new ArgumentNullException(nameof(changes));
            }

            var oldTree = this;

            // if changes is entire text do a full reparse
            if (changes.Count == 1 && changes["[0]"].Span == new TextSpan(0, this.Length) && changes["[0]"].NewLength == newText.Length)
            {
                // parser will do a full parse if we give it no changes
                changes = null;
                oldTree = null;
            }

            using (var parser = new [lang]SyntaxParser(newText, this.Options, oldTree?.GetRoot(), changes))
            {
                var compilationUnit = ([Instances.MainRule().RedName()])parser.Parse[Instances.MainRule().PlainName()]().CreateRed();
                var tree = new ParsedSyntaxTree(newText, newText.Encoding, newText.ChecksumAlgorithm, this.FilePath, this.Options, compilationUnit, parser.Directives);
                tree.VerifySource(changes);
                return tree;
            }
        }

        #endregion

        #region SyntaxTree

        protected override ParseOptions OptionsCore => this.Options;

        protected override SyntaxNode GetRootCore(CancellationToken cancellationToken)
        {
            return this.GetRoot(cancellationToken);
        }

        protected override async Task<SyntaxNode> GetRootAsyncCore(CancellationToken cancellationToken)
        {
            return await this.GetRootAsync(cancellationToken).ConfigureAwait(false);
        }

        protected override bool TryGetRootCore(out SyntaxNode root)
        {
            [lang]SyntaxNode node;
            if (this.TryGetRoot(out node))
            {
                root = node;
                return true;
            }
            else
            {
                root = null;
                return false;
            }
        }

        #endregion

        internal sealed class DummySyntaxTree : [lang]SyntaxTree
        {
            private readonly [lang]SyntaxNode _node;

            public DummySyntaxTree()
            {
                _node = this.CloneNodeAsRoot(([Instances.MainRule().RedName()])[Instances.MainRule().GreenName()].__Missing.CreateRed());
            }

            public override string ToString()
            {
                return string.Empty;
            }

            public override SourceText GetText(CancellationToken cancellationToken)
            {
                return SourceText.From(string.Empty, Encoding.UTF8);
            }

            public override bool TryGetText(out SourceText text)
            {
                text = SourceText.From(string.Empty, Encoding.UTF8);
                return true;
            }

            public override Encoding Encoding
            {
                get { return Encoding.UTF8; }
            }

            public override int Length
            {
                get { return 0; }
            }

            public override [lang]ParseOptions Options
            {
                get { return [lang]ParseOptions.Default; }
            }

            public override string FilePath
            {
                get { return string.Empty; }
            }

            public override SyntaxReference GetReference(SyntaxNode node)
            {
                return new SimpleSyntaxReference(node);
            }

            public override [lang]SyntaxNode GetRoot(CancellationToken cancellationToken)
            {
                return _node;
            }

            public override bool TryGetRoot(out [lang]SyntaxNode root)
            {
                root = _node;
                return true;
            }

            public override bool HasCompilationUnitRoot
            {
                get { return true; }
            }

            public override FileLinePositionSpan GetLineSpan(TextSpan span, CancellationToken cancellationToken = default(CancellationToken))
            {
                return default(FileLinePositionSpan);
            }

            public override SyntaxTree WithRootAndOptions(SyntaxNode root, ParseOptions options)
            {
                return [lang]Language.Instance.SyntaxFactory.SyntaxTree((LanguageSyntaxNode)root, options: ([lang]ParseOptions)options, path: FilePath, encoding: null);
            }

            public override SyntaxTree WithFilePath(string path)
            {
                return [lang]Language.Instance.SyntaxFactory.SyntaxTree(_node, options: this.Options, path: path, encoding: null);
            }
        }

        private class ParsedSyntaxTree : [lang]SyntaxTree
        {
            private readonly [lang]ParseOptions _options;
            private readonly string _path;
            private readonly [lang]SyntaxNode _root;
            private readonly bool _hasCompilationUnitRoot;
            private readonly Encoding _encodingOpt;
            private readonly SourceHashAlgorithm _checksumAlgorithm;
            private SourceText _lazyText;

            internal ParsedSyntaxTree(SourceText textOpt, Encoding encodingOpt, SourceHashAlgorithm checksumAlgorithm, string path, [lang]ParseOptions options, [lang]SyntaxNode root, DirectiveStack directives, bool cloneRoot = true)
            {
                Debug.Assert(root != null);
                Debug.Assert(options != null);
                Debug.Assert(textOpt == null || textOpt.Encoding == encodingOpt && textOpt.ChecksumAlgorithm == checksumAlgorithm);

                _lazyText = textOpt;
                _encodingOpt = encodingOpt ?? textOpt?.Encoding;
                _checksumAlgorithm = checksumAlgorithm;
                _options = options;
                _path = path ?? string.Empty;
                _root = cloneRoot ? this.CloneNodeAsRoot(root) : root;
                _hasCompilationUnitRoot = root.Kind == [lang]SyntaxKind.[Instances.MainRule().PlainName()];
                this.SetDirectiveStack(directives);
            }

            public override string FilePath
            {
                get { return _path; }
            }

            public override SourceText GetText(CancellationToken cancellationToken)
            {
                if (_lazyText == null)
                {
                    Interlocked.CompareExchange(ref _lazyText, this.GetRoot(cancellationToken).GetText(_encodingOpt, _checksumAlgorithm), null);
                }

                return _lazyText;
            }

            public override bool TryGetText(out SourceText text)
            {
                text = _lazyText;
                return text != null;
            }

            public override Encoding Encoding
            {
                get { return _encodingOpt; }
            }

            public override int Length
            {
                get { return _root.FullSpan.Length; }
            }

            public override [lang]SyntaxNode GetRoot(CancellationToken cancellationToken)
            {
                return _root;
            }

            public override bool TryGetRoot(out [lang]SyntaxNode root)
            {
                root = _root;
                return true;
            }

            public override bool HasCompilationUnitRoot
            {
                get
                {
                    return _hasCompilationUnitRoot;
                }
            }

            public override [lang]ParseOptions Options
            {
                get
                {
                    return _options;
                }
            }

            public override SyntaxReference GetReference(SyntaxNode node)
            {
                return new SimpleSyntaxReference(node);
            }

            public override SyntaxTree WithRootAndOptions(SyntaxNode root, ParseOptions options)
            {
                if (ReferenceEquals(_root, root) && ReferenceEquals(_options, options))
                {
                    return this;
                }

                return new ParsedSyntaxTree(
                    null,
                    _encodingOpt,
                    _checksumAlgorithm,
                    _path,
                    ([lang]ParseOptions)options,
                    ([lang]SyntaxNode)root,
                    this.GetDirectives());
            }

            public override SyntaxTree WithFilePath(string path)
            {
                if (_path == path)
                {
                    return this;
                }

                return new ParsedSyntaxTree(
                    _lazyText,
                    _encodingOpt,
                    _checksumAlgorithm,
                    path,
                    _options,
                    _root,
                    this.GetDirectives());
            }
        }

        private class DebuggerSyntaxTree : ParsedSyntaxTree
        {
            public DebuggerSyntaxTree([lang]SyntaxNode root, SourceText text, [lang]ParseOptions options)
                : base(
                    text,
                    text.Encoding,
                    text.ChecksumAlgorithm,
                    path: "",
                    options: options,
                    root: root,
                    directives: DirectiveStack.Empty)
            {
            }

            public override bool SupportsLocations
            {
                get { return true; }
            }
        }
    }
}
end template

template GenerateInternalSyntax()
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
^
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace].Syntax.InternalSyntax
{
    using MetaDslx.CodeAnalysis;
    using MetaDslx.CodeAnalysis.Syntax;
    using MetaDslx.CodeAnalysis.Syntax.InternalSyntax;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.Syntax.InternalSyntax;
    using Roslyn.Utilities;
^	
	internal abstract class GreenSyntaxNode : InternalSyntaxNode
    {
        protected GreenSyntaxNode(SyntaxKind kind)
            : base(kind)
        {
        }
^
        protected GreenSyntaxNode(SyntaxKind kind, int fullWidth)
            : base(kind, fullWidth)
        {
        }
^
        protected GreenSyntaxNode(SyntaxKind kind, DiagnosticInfo["[]"] diagnostics)
            : base(kind, diagnostics)
        {
        }
^
        protected GreenSyntaxNode(SyntaxKind kind, DiagnosticInfo["[]"] diagnostics, int fullWidth)
            : base(kind, diagnostics, fullWidth)
        {
        }
^
        protected GreenSyntaxNode(SyntaxKind kind, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
            : base(kind, diagnostics, annotations)
        {
        }
^
        protected GreenSyntaxNode(SyntaxKind kind, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations, int fullWidth)
            : base(kind, diagnostics, annotations, fullWidth)
        {
        }
^
        protected GreenSyntaxNode(ObjectReader reader)
            : base(reader)
        {
        }
^
        public override TResult Accept<TResult>(InternalSyntaxVisitor<TResult> visitor)
        {
            if (visitor is [lang]SyntaxVisitor<TResult> typedVisitor) return this.Accept(typedVisitor);
            else return visitor.DefaultVisit(this);
        }
^
        public override void Accept(InternalSyntaxVisitor visitor) 
        {
            if (visitor is [lang]SyntaxVisitor typedVisitor) this.Accept(typedVisitor);
            else visitor.DefaultVisit(this);
        }
^
        public abstract TResult Accept<TResult>([lang]SyntaxVisitor<TResult> visitor);
        public abstract void Accept([lang]SyntaxVisitor visitor);
^
        public new [lang]Language Language => [lang]Language.Instance;
        protected override Language LanguageCore => this.Language;
        public new [lang]SyntaxKind Kind => ([lang]SyntaxKind)this.RawKind;
        protected override SyntaxKind KindCore => this.Kind;
	}
^
    internal class GreenSyntaxTrivia : InternalSyntaxTrivia
    {
        internal GreenSyntaxTrivia([lang]SyntaxKind kind, string text, DiagnosticInfo["[]"] diagnostics = null, SyntaxAnnotation["[]"] annotations = null)
            : base(kind, text, diagnostics, annotations)
        {
        }
^
        internal GreenSyntaxTrivia(ObjectReader reader)
            : base(reader)
        {
        }
^
        static GreenSyntaxTrivia()
        {
            ObjectBinder.RegisterTypeReader(typeof(GreenSyntaxTrivia), r => new GreenSyntaxTrivia(r));
        }
^
        public new [lang]Language Language => [lang]Language.Instance;
        protected override Language LanguageCore => this.Language;
        public new [lang]SyntaxKind Kind => EnumObject.FromIntUnsafe<[lang]SyntaxKind>(this.RawKind);
        protected override SyntaxKind KindCore => this.Kind;
^
        protected override bool ShouldReuseInSerialization => this.Kind == Language.SyntaxFacts.DefaultWhitespaceKind &&
                                                             FullWidth < Language.SyntaxFacts.MaxCachedTokenSize;
^
        protected override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteString(this.Text);
        }
^
        internal static GreenSyntaxTrivia Create([lang]SyntaxKind kind, string text)
        {
            return new GreenSyntaxTrivia(kind, text);
        }
^
        public override InternalSyntaxNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
        {
            return new GreenSyntaxTrivia(this.Kind, this.Text, diagnostics, GetAnnotations());
        }
^
        public override InternalSyntaxNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
        {
            return new GreenSyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations);
        }
^
        public static implicit operator SyntaxTrivia(GreenSyntaxTrivia trivia)
        {
            return new SyntaxTrivia(default, trivia, position: 0, index: 0);
        }
    }
^
	[GenerateGreenToken()]
	[loop(rule:Instances.ParserRules)]
	[GenerateInternalSyntaxRule(rule, null)]
	[end loop]
^
	[GenerateInternalSyntaxVisitor()]
	[GenerateInternalSyntaxFactory()]
}
end template


function string GetCompilationUnitInternal(Antlr4ParserRule rule)
	/*if (rule.HasEof())
		return ", ICompilationUnitInternalSyntax";
	else*/
		return "";
	//end if
end function

function string GetCompilationUnit(Antlr4ParserRule rule)
	if (rule.HasEof())
		return ", ICompilationUnitSyntax";
	else
		return "";
	end if
end function

function string GetInternalElemTypedParamList(Antlr4ParserRule rule, TypeKind kind, bool leadingComma = false, bool trailingComma = false)
	string result = "";
	if (rule.AllElements.Count == 0)
		return result;
	end if
	if (leadingComma)
		result = ", ";
	end if
	loop(elem:rule.AllElements; separator delim = ", ")
		result += elem.GreenType(kind) + " " + elem.FieldName() + delim;
	end loop
	if (trailingComma)
		result += ", ";
	end if
	return result;
end function

function string GetRoslynVisitorElemParamList(Antlr4ParserRule rule, bool leadingComma = false, bool trailingComma = false)
	string result = "";
	if (rule.AllElements.Count == 0)
		return result;
	end if
	if (leadingComma)
		result = ", ";
	end if
	loop(elem:rule.AllElements; separator delim = ", ")
		result += elem.FieldName();
		if (elem.IsList && elem.IsSeparated && elem.IsSimplified) 
			result += "?."+elem.Grammar.FindParserRule(elem.OriginalType).Elements[0].GreenName();
		end if
		result += delim;
	end loop
	if (trailingComma)
		result += ", ";
	end if
	return result;
end function

function string GetElemTypedParamList(Antlr4ParserRule rule, bool leadingComma = false, bool trailingComma = false, bool optional = false)
	string result = "";
	if (rule.AllElements.Count == 0)
		return result;
	end if
	if (leadingComma)
		result = ", ";
	end if
	loop(elem:rule.AllElements where !optional || !(elem.IsOptional || (elem.IsToken && elem.IsFixedToken && !elem.IsList)); separator delim = ", ")
		result += elem.RedType() + " " + elem.FieldName() + delim;
	end loop
	if (trailingComma)
		result += ", ";
	end if
	return result;
end function

function string GetInternalElemParamList(Antlr4ParserRule rule, bool listAsNode = false, bool leadingComma = false, bool trailingComma = false, string prefix = "this.", Antlr4ParserRuleElement skip = null)
	string result = "";
	if (rule.AllElements.Count == 0)
		return result;
	end if
	if (leadingComma)
		result = ", ";
	end if
	loop(elem:rule.AllElements; separator delim = ", ")
		string fieldName = elem.FieldName();
		if (elem.IsList && listAsNode)
			fieldName = fieldName+".Node";
		end if
		if (elem == skip)
			result += fieldName+delim;
		else
			result += prefix+fieldName+delim;
		end if
	end loop
	if (trailingComma)
		result += ", ";
	end if
	return result;
end function

function string GetElemDefaultParamList(Antlr4ParserRule rule, bool leadingComma = false, bool trailingComma = false)
	string result = "";
	if (rule.AllElements.Count == 0)
		return result;
	end if
	if (leadingComma)
		result = ", ";
	end if
	loop(elem:rule.AllElements; separator delim = ", ")
		result += "default"+delim;
	end loop
	if (trailingComma)
		result += ", ";
	end if
	return result;
end function

function string GetElemParamList(Antlr4ParserRule rule, bool leadingComma = false, bool trailingComma = false, string prefix = "this.", Antlr4ParserRuleElement skip = null)
	string result = "";
	if (rule.AllElements.Count == 0)
		return result;
	end if
	if (leadingComma)
		result = ", ";
	end if
	loop(elem:rule.AllElements; separator delim = ", ")
		if (elem == skip)
			result += elem.RedName()+delim;
		else
			result += prefix+elem.RedName()+delim;
		end if
	end loop
	if (trailingComma)
		result += ", ";
	end if
	return result;
end function

function string GetGreenConstructorSimpleAltParamList(Antlr4ParserRule rule, bool leadingComma = false, bool trailingComma = false, Antlr4ParserRuleElement include = null)
	string result = "";
	if (rule.AllElements.Count == 0)
		return result;
	end if
	if (leadingComma)
		result = ", ";
	end if
	loop(elem:rule.AllElements; separator delim = ", ")
		if (elem == include)
			result += elem.FieldName();
			if (elem.IsList)
				result += ".Node";
			end if
		else
			result += "null";
		end if
		result += delim;
	end loop
	if (trailingComma)
		result += ", ";
	end if
	return result;
end function

function string GetRedToGreenParamElem(Antlr4ParserRuleElement elem, string delim = "")
	string result = "";
	if (elem.IsOptional)
		if (!elem.IsList && !elem.IsToken)
			result += elem.FieldName() + " == null ? null : ";
		end if
	end if
	if (elem.IsList)
		if (elem.IsToken)
			result += "Microsoft.CodeAnalysis.Syntax.InternalSyntax.GreenNodeExtensions.ToGreenList<"+elem.GreenInnerType()+">("+elem.FieldName()+".Node)"+delim;
		else
			if (elem.IsSeparated)
				result += "Microsoft.CodeAnalysis.Syntax.InternalSyntax.GreenNodeExtensions.ToGreenSeparatedList<"+elem.GreenInnerType()+">("+elem.FieldName()+".Node)"+delim;
			else
				result += "Microsoft.CodeAnalysis.Syntax.InternalSyntax.GreenNodeExtensions.ToGreenList<"+elem.GreenInnerType()+">("+elem.FieldName()+".Node)"+delim;
			end if
		end if
	else
		if (elem.IsToken || (elem.IsBlock && elem.IsFixedTokenAltBlock))
			result += "(InternalSyntaxToken)"+elem.FieldName()+".Node"+delim;
		else
			result += "(Syntax.InternalSyntax."+elem.GreenType(TypeKind.Public)+")"+elem.FieldName()+".Green"+delim;
		end if
	end if
	return result;
end function

function string GetRedToGreenParamList(Antlr4ParserRule rule, bool leadingComma = false, bool trailingComma = false, bool optional = false)
	string result = "";
	if (rule.AllElements.Count == 0)
		return result;
	end if
	if (leadingComma)
		result = ", ";
	end if
	loop(elem:rule.AllElements; separator delim = ", ")
		if (optional && (elem.IsOptional || (elem.IsToken && elem.IsFixedToken && !elem.IsList)))
			if (elem.IsToken && elem.IsFixedToken && !elem.IsOptional)
				result += "this.Token("+Properties.LanguageName+"SyntaxKind."+elem.SyntaxKind()+")"+delim;
			else 
				result += "default"+delim;
			end if
		else
			if (optional)
				result += elem.FieldName()+delim;
			else
				result += GetRedToGreenParamElem(elem, delim);
			end if
		end if
	end loop
	if (trailingComma)
		result += ", ";
	end if
	return result;
end function

function string GetInternalElemUpdateList(Antlr4ParserRule rule)
	string result = "";
	loop(elem:rule.AllElements; separator delim = " ||\n\t\t\t")
		if (elem.IsList)
			result += "this."+elem.GreenName()+" != "+elem.FieldName()/*+".Node"*/+delim;
		else
			result += "this."+elem.GreenName()+" != "+elem.FieldName()+delim;
		end if
	end loop
	return result;
end function

function string GetElemUpdateList(Antlr4ParserRule rule)
	string result = "";
	loop(elem:rule.AllElements; separator delim = " ||\n\t\t\t")
		if (elem.IsList && !elem.IsToken)
			result += "this."+elem.RedName()+" != "+elem.FieldName()+delim;
		else
			result += "this."+elem.RedName()+" != "+elem.FieldName()+delim;
		end if
	end loop
	return result;
end function

template GenerateInternalSyntaxRule(Antlr4ParserRule rule, Antlr4ParserRule superRule)
[if (rule.Alternatives.Count > 0)]
^
internal abstract class [rule.GreenName()] : GreenSyntaxNode
{
	[if (rule.FirstNonAbstractAlternative != null)]
    internal static readonly [rule.GreenName()] __Missing = [rule.FirstNonAbstractAlternative.GreenName()].__Missing;
	[end if]
^
    public [rule.GreenName()]([Properties.LanguageName]SyntaxKind kind, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
        : base(kind, diagnostics, annotations)
    {
		this.SlotCount = [rule.AllElements.Count];
    }
}
	[loop(alt:rule.Alternatives)]
[GenerateInternalSyntaxRule(alt, rule)]
	[end loop]
[else]
^
	[if (superRule != null)]
internal class [rule.GreenName()] : [superRule.GreenName()][GetCompilationUnitInternal(rule)]
	[else]
internal class [rule.GreenName()] : GreenSyntaxNode[GetCompilationUnitInternal(rule)]
	[end if]
{
	[if (rule.ParentRule != null && rule.ParentRule.Alternatives.Count > 0)]
    internal static new readonly [rule.GreenName()] __Missing = new [rule.GreenName()]();
	[else]
    internal static readonly [rule.GreenName()] __Missing = new [rule.GreenName()]();
	[end if]
	
	[loop(elem:rule.AllElements)]
    private [elem.GreenType(TypeKind.Field)] [elem.FieldName()];
	[end loop]
^
    public [rule.GreenName()]([Properties.LanguageName]SyntaxKind kind[GetInternalElemTypedParamList(rule, TypeKind.Field, true)])
        : base(kind, null, null)
    {
		this.SlotCount = [rule.AllElements.Count];
		[loop(elem:rule.AllElements)]
		if ([elem.FieldName()] != null)
		{
			this.AdjustFlagsAndWidth([elem.FieldName()]);
			this.[elem.FieldName()] = [elem.FieldName()];
		}
		[end loop]
    }
^
    public [rule.GreenName()]([Properties.LanguageName]SyntaxKind kind[GetInternalElemTypedParamList(rule, TypeKind.Field, true)], DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
        : base(kind, diagnostics, annotations)
    {
		this.SlotCount = [rule.AllElements.Count];
		[loop(elem:rule.AllElements)]
		if ([elem.FieldName()] != null)
		{
			this.AdjustFlagsAndWidth([elem.FieldName()]);
			this.[elem.FieldName()] = [elem.FieldName()];
		}
		[end loop]
    }
^
	private [rule.GreenName()]()
		: base(([Properties.LanguageName]SyntaxKind)[Properties.LanguageName]SyntaxKind.[rule.PlainName()], null, null)
	{
		this.flags &= ~NodeFlags.IsNotMissing;
	}
^
	[loop(elem:rule.AllElements)]
		[if (elem.IsList)]
    public [elem.GreenType(TypeKind.Public)] [elem.GreenName()] { get { return new [elem.GreenType(TypeKind.Public)](this.[elem.FieldName()]); } }
		[else]
    public [elem.GreenType(TypeKind.Public)] [elem.GreenName()] { get { return this.[elem.FieldName()]; } }
		[end if]
	[end loop]
^
    protected override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
        return new global::[Properties.DefaultNamespace].Syntax.[rule.RedName()](this, ([Properties.LanguageName]SyntaxNode)parent, position);
    }
^
    protected override GreenNode GetSlot(int index)
    {
        switch (index)
        {
			[loop(i:CompilerGeneratorUtils.Range(rule.AllElements.Count))]
            case [i]: return this.[rule.AllElements[i].FieldName()];
			[end loop]
            default: return null;
        }
    }
^
    public override TResult Accept<TResult>([Properties.LanguageName]SyntaxVisitor<TResult> visitor) => visitor.Visit[rule.GreenName()](this);
^
    public override void Accept([Properties.LanguageName]SyntaxVisitor visitor) => visitor.Visit[rule.GreenName()](this);
^
    public override InternalSyntaxNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
    {
        return new [rule.GreenName()](this.Kind, [GetInternalElemParamList(rule, false, false, true)]diagnostics, this.GetAnnotations());
    }
^
    public override InternalSyntaxNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
    {
        return new [rule.GreenName()](this.Kind, [GetInternalElemParamList(rule, false, false, true)]this.GetDiagnostics(), annotations);
    }
	[if (rule.IsSimpleAlt)]
		[loop(elem:rule.Elements)]
^
    public [rule.GreenName()] Update([elem.GreenType(TypeKind.Public)] [elem.FieldName()])
    {
        if (this.[elem.FieldName()] != [elem.FieldName()])
        {
            InternalSyntaxNode newNode = [Properties.LanguageName]Language.Instance.InternalSyntaxFactory.[rule.PlainName()]([elem.FieldName()]);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
			return ([rule.GreenName()])newNode;
        }
        return this;
    }
		[end loop]
	[else]
^
    public [rule.GreenName()] Update([GetInternalElemTypedParamList(rule, TypeKind.Public)])
    {
        if ([GetInternalElemUpdateList(rule)])
        {
            InternalSyntaxNode newNode = [Properties.LanguageName]Language.Instance.InternalSyntaxFactory.[rule.PlainName()]([GetInternalElemParamList(rule, false, false, false, "")]);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
			return ([rule.GreenName()])newNode;
        }
        return this;
    }
	[end if]
}
[end if]
end template

template GenerateInternalSyntaxVisitor()
internal class [Properties.LanguageName]SyntaxVisitor : InternalSyntaxVisitor
{
[loop(rule:Instances.ParserRules)]
	[if (rule.Alternatives.Count > 0)]
		[loop(alt:rule.Alternatives)]
	public virtual void Visit[alt.GreenName()]([alt.GreenName()] node) => this.DefaultVisit(node);
		[end loop]
	[else]
	public virtual void Visit[rule.GreenName()]([rule.GreenName()] node) => this.DefaultVisit(node);
	[end if]
[end loop]
}
^
internal class [Properties.LanguageName]SyntaxVisitor<TResult> : InternalSyntaxVisitor<TResult>
{
[loop(rule:Instances.ParserRules)]
	[if (rule.Alternatives.Count > 0)]
		[loop(alt:rule.Alternatives)]
	public virtual TResult Visit[alt.GreenName()]([alt.GreenName()] node) => this.DefaultVisit(node);
		[end loop]
	[else]
	public virtual TResult Visit[rule.GreenName()]([rule.GreenName()] node) => this.DefaultVisit(node);
	[end if]
[end loop]
}
end template

template GenerateInternalSyntaxFactory()
[var lang = Properties.LanguageName]
internal class [lang]InternalSyntaxFactory : InternalSyntaxFactory
{
	public [lang]InternalSyntaxFactory([lang]SyntaxFacts syntaxFacts) 
	    : base(syntaxFacts)
	{
	}
^
    public override Language Language => [lang]Language.Instance;
^
	private [lang]SyntaxKind ToMetaSyntaxKind(SyntaxKind kind)
    {
        return kind.CastUnsafe<[lang]SyntaxKind>();
    }
^
    public override InternalSyntaxTrivia Trivia(SyntaxKind kind, string text, bool elastic = false)
    {
        var trivia = GreenSyntaxTrivia.Create(ToMetaSyntaxKind(kind), text);
        if (!elastic)
        {
            return trivia;
        }
        return trivia.WithAnnotationsGreen(new["[]"] { SyntaxAnnotation.ElasticAnnotation });
    }
^
    public override InternalSyntaxTrivia ConflictMarker(string text)
    {
        return GreenSyntaxTrivia.Create(ToMetaSyntaxKind(SyntaxKind.ConflictMarkerTrivia), text);
    }
^
    public override InternalSyntaxTrivia DisabledText(string text)
    {
        return GreenSyntaxTrivia.Create(ToMetaSyntaxKind(SyntaxKind.DisabledTextTrivia), text);
    }
^
    public override InternalSyntaxToken Token(SyntaxKind kind)
    {
        return GreenSyntaxToken.Create(ToMetaSyntaxKind(kind));
    }
^
    public override InternalSyntaxToken Token(GreenNode leading, SyntaxKind kind, GreenNode trailing)
    {
        return GreenSyntaxToken.Create(ToMetaSyntaxKind(kind), leading, trailing);
    }
^
    public override InternalSyntaxToken Token(GreenNode leading, SyntaxKind kind, string text, GreenNode trailing)
    {
		[lang]SyntaxKind typedKind = ToMetaSyntaxKind(kind);
        Debug.Assert([lang]Language.Instance.SyntaxFacts.IsToken(typedKind));
        string defaultText = [lang]Language.Instance.SyntaxFacts.GetText(typedKind);
        return typedKind >= GreenSyntaxToken.FirstTokenWithWellKnownText && typedKind <= GreenSyntaxToken.LastTokenWithWellKnownText && text == defaultText
            ? Token(leading, kind, trailing)
            : GreenSyntaxToken.Identifier(typedKind, leading, text, trailing);
    }
^
    public override InternalSyntaxToken Token(GreenNode leading, SyntaxKind kind, string text, string valueText, GreenNode trailing)
    {
		[lang]SyntaxKind typedKind = ToMetaSyntaxKind(kind);
        Debug.Assert([lang]Language.Instance.SyntaxFacts.IsToken(typedKind));
        string defaultText = [lang]Language.Instance.SyntaxFacts.GetText(typedKind);
        return typedKind >= GreenSyntaxToken.FirstTokenWithWellKnownText && typedKind <= GreenSyntaxToken.LastTokenWithWellKnownText && text == defaultText && valueText == defaultText
            ? Token(leading, kind, trailing)
            : GreenSyntaxToken.WithValue(typedKind, leading, text, valueText, trailing);
    }
^
    public override InternalSyntaxToken Token(GreenNode leading, SyntaxKind kind, string text, object value, GreenNode trailing)
    {
		[lang]SyntaxKind typedKind = ToMetaSyntaxKind(kind);
        Debug.Assert([lang]Language.Instance.SyntaxFacts.IsToken(typedKind));
        string defaultText = [lang]Language.Instance.SyntaxFacts.GetText(typedKind);
        return typedKind >= GreenSyntaxToken.FirstTokenWithWellKnownText && typedKind <= GreenSyntaxToken.LastTokenWithWellKnownText && text == defaultText && defaultText.Equals(value)
            ? Token(leading, kind, trailing)
            : GreenSyntaxToken.WithValue(typedKind, leading, text, value, trailing);
    }
^
    public override InternalSyntaxToken MissingToken(SyntaxKind kind)
    {
        return GreenSyntaxToken.CreateMissing(ToMetaSyntaxKind(kind), null, null);
    }
^
    public override InternalSyntaxToken MissingToken(GreenNode leading, SyntaxKind kind, GreenNode trailing)
    {
        return GreenSyntaxToken.CreateMissing(ToMetaSyntaxKind(kind), leading, trailing);
    }
^
    public override InternalSyntaxToken BadToken(GreenNode leading, string text, GreenNode trailing)
    {
        return GreenSyntaxToken.WithValue(ToMetaSyntaxKind(SyntaxKind.BadToken), leading, text, text, trailing);
    }
^
    public override IEnumerable<InternalSyntaxToken> GetWellKnownTokens()
    {
        return GreenSyntaxToken.GetWellKnownTokens();
    }
^
[loop(rule:Instances.LexerRules where rule.FixedToken == null)]
^
    internal InternalSyntaxToken [rule.PlainName()](string text)
    {
        return Token(null, [lang]SyntaxKind.[rule.PlainName()], text, null);
    }
^
    internal InternalSyntaxToken [rule.PlainName()](string text, object value)
    {
        return Token(null, [lang]SyntaxKind.[rule.PlainName()], text, value, null);
    }
[end loop]
[loop(rule:Instances.ParserRules)]
	[if (rule.Alternatives.Count > 0)]
		[loop(alt:rule.Alternatives)]
[GenerateInternalSyntaxFactoryCreate(alt)]
		[end loop]
	[else]
[GenerateInternalSyntaxFactoryCreate(rule)]
	[end if]
[end loop]
^
    internal static IEnumerable<Type> GetNodeTypes()
    {
        return new Type["[]"] {
[loop(rule:Instances.ParserRules)]
	[if (rule.Alternatives.Count > 0)]
		[loop(alt:rule.Alternatives)]
			typeof([alt.GreenName()]),
		[end loop]
	[else]
			typeof([rule.GreenName()]),
	[end if]
[end loop]
		};
	}
}
end template

template GenerateInternalSyntaxFactoryCreate(Antlr4ParserRule rule)
[if (rule.IsSimpleAlt)]
	[loop(elem:rule.Elements)]
^
	public [rule.GreenName()] [rule.PlainName()]([elem.GreenType(TypeKind.Public)] [elem.FieldName()])
    {
#if DEBUG
		[if (!elem.IsOptional)]
			[if (!elem.IsList)]
	    if ([elem.FieldName()] == null) throw new ArgumentNullException(nameof([elem.FieldName()]));
			[end if]
			[if (elem.IsToken && !elem.IsList)]
		if ([elem.FieldName()].Kind != [Properties.LanguageName]SyntaxKind.[elem.SyntaxKind()]) throw new ArgumentException(nameof([elem.FieldName()]));
			[end if]
		[else]
			[if (elem.IsToken && !elem.IsList)]
		if ([elem.FieldName()] != null && [elem.FieldName()].Kind != [Properties.LanguageName]SyntaxKind.[elem.SyntaxKind()]) throw new ArgumentException(nameof([elem.FieldName()]));
			[end if]
		[end if]
#endif
		[if (rule.Elements.Count <= 3)]
		int hash;
		[if (elem.IsList)]
		var cached = SyntaxNodeCache.TryGetNode((int)([Properties.LanguageName]SyntaxKind)[Properties.LanguageName]SyntaxKind.[rule.PlainName()], [elem.FieldName()].Node, out hash);
		[else]
		var cached = SyntaxNodeCache.TryGetNode((int)([Properties.LanguageName]SyntaxKind)[Properties.LanguageName]SyntaxKind.[rule.PlainName()], [elem.FieldName()], out hash);
		[end if]
		if (cached != null) return ([rule.GreenName()])cached;
		
		var result = new [rule.GreenName()]([Properties.LanguageName]SyntaxKind.[rule.PlainName()][GetGreenConstructorSimpleAltParamList(rule, true, false, elem)]);
		if (hash >= 0)
		{
			SyntaxNodeCache.AddNode(result, hash);
		}
		return result;
		[else]
		return new [rule.GreenName()]([Properties.LanguageName]SyntaxKind.[rule.PlainName()][GetGreenConstructorSimpleAltParamList(rule, true, false, elem)]);
		[end if]
    }
	[end loop]
[else]
^
	public [rule.GreenName()] [rule.PlainName()]([GetInternalElemTypedParamList(rule, TypeKind.Public, false, false)])
    {
#if DEBUG
		[loop(elem:rule.AllElements)]
			[if (!elem.IsOptional)]
				[if (!elem.IsList)]
		if ([elem.FieldName()] == null) throw new ArgumentNullException(nameof([elem.FieldName()]));
				[end if]
				[if (elem.IsToken && !elem.IsList)]
		if ([elem.FieldName()].Kind != [Properties.LanguageName]SyntaxKind.[elem.SyntaxKind()]) throw new ArgumentException(nameof([elem.FieldName()]));
				[end if]
			[else]
				[if (elem.IsToken && !elem.IsList)]
		if ([elem.FieldName()] != null && [elem.FieldName()].Kind != [Properties.LanguageName]SyntaxKind.[elem.SyntaxKind()]) throw new ArgumentException(nameof([elem.FieldName()]));
				[end if]
			[end if]
		[end loop]
#endif
		[if (rule.AllElements.Count <= 3)]
		int hash;
		var cached = SyntaxNodeCache.TryGetNode((int)([Properties.LanguageName]SyntaxKind)[Properties.LanguageName]SyntaxKind.[rule.PlainName()][GetInternalElemParamList(rule, true, true, false, "")], out hash);
		if (cached != null) return ([rule.GreenName()])cached;
		
		var result = new [rule.GreenName()]([Properties.LanguageName]SyntaxKind.[rule.PlainName()][GetInternalElemParamList(rule, true, true, false, "")]);
		if (hash >= 0)
		{
			SyntaxNodeCache.AddNode(result, hash);
		}
		
		return result;
		[else]
        return new [rule.GreenName()]([Properties.LanguageName]SyntaxKind.[rule.PlainName()][GetInternalElemParamList(rule, true, true, false, "")]);
		[end if]
    }
[end if]
end template

template GenerateSyntaxKind(bool forParser, string className, string baseClassName)
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MetaDslx.CodeAnalysis.Syntax;
using Roslyn.Utilities;
^
namespace [Properties.DefaultNamespace].Syntax
{
	public class [className] : [baseClassName]
	{
		[if (!forParser)]
			[if(hasloop(rule:Instances.LexerRules where rule.Kind > 0))]
        public static readonly [className] __FirstToken;
        public static readonly int __FirstTokenValue;
        public static readonly [className] __LastToken;
        public static readonly int __LastTokenValue;
        public static readonly [className] __FirstFixedToken;
        public static readonly int __FirstFixedTokenValue;
        public static readonly [className] __LastFixedToken;
        public static readonly int __LastFixedTokenValue;
^
		// Tokens:
			[loop(rule:Instances.LexerRules where rule.Kind > 0)]
		public const string [rule.PlainName()] = nameof([rule.PlainName()]); // [rule.Kind]
			[end loop]
			[end if]
		[else]
			[if(hasloop(rule:Instances.ParserRules))]
        public static new readonly [className] __FirstToken;
        public static new readonly [className] __LastToken;
        public static new readonly [className] __FirstFixedToken;
        public static new readonly [className] __LastFixedToken;
        public static readonly [className] __FirstRule;
        public static readonly int __FirstRuleValue;
        public static readonly [className] __LastRule;
        public static readonly int __LastRuleValue;
^
		// Rules:
			[loop(rule:Instances.ParserRules)]
			[if (rule.Alternatives.Count > 0)]
				[loop(alt:rule.Alternatives)]
		public const string [alt.PlainName()] = nameof([alt.PlainName()]);
				[end loop]
			[else]
		public const string [rule.PlainName()] = nameof([rule.PlainName()]);
			[end if]
			[end loop]
			[end if]
		[end if]
^
		protected [className](string name)
            : base(name)
        {
        }
^
        protected [className](EnumObject retargetedValue)
            : base(retargetedValue)
        {
        }
^
        static [className]()
        {
            EnumObject.AutoInit<[className]>();
			[if(!forParser && hasloop(rule:Instances.LexerRules where rule.Kind > 0))]
            __FirstToken = [Instances.FirstTokenSyntaxKind.PlainName()];
			__FirstTokenValue = (int)__FirstToken;
            __LastToken = [Instances.LastTokenSyntaxKind.PlainName()];
			__LastTokenValue = (int)__LastToken;
            __FirstFixedToken = [Instances.FirstFixedTokenSyntaxKind.PlainName()];
			__FirstFixedTokenValue = (int)__FirstFixedToken;
            __LastFixedToken = [Instances.LastFixedTokenSyntaxKind.PlainName()];
			__LastFixedTokenValue = (int)__LastFixedToken;
			[end if]
			[if(forParser && hasloop(rule:Instances.ParserRules))]
            __FirstToken = [Instances.FirstTokenSyntaxKind.PlainName()];
            __LastToken = [Instances.LastTokenSyntaxKind.PlainName()];
            __FirstFixedToken = [Instances.FirstFixedTokenSyntaxKind.PlainName()];
            __LastFixedToken = [Instances.LastFixedTokenSyntaxKind.PlainName()];
            __FirstRule = [Instances.FirstParserRuleSyntaxKind.PlainName()];
			__FirstRuleValue = (int)__FirstRule;
            __LastRule = [Instances.LastParserRuleSyntaxKind.PlainName()];
			__LastRuleValue = (int)__LastRule;
			[end if]
        }
^
        public static implicit operator [className](string name)
        {
            return FromString<[className]>(name);
        }
^
        public static explicit operator [className](int value)
        {
            return FromIntUnsafe<[className]>(value);
        }
^
	}
}
end template

template GenerateSyntax()
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Syntax;
using MetaDslx.CodeAnalysis.Syntax.InternalSyntax;
^
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace].Syntax
{
    public abstract class [lang]SyntaxNode : LanguageSyntaxNode
    {
        protected [lang]SyntaxNode(InternalSyntaxNode green, [lang]SyntaxTree syntaxTree, int position)
            : base(green, syntaxTree, position)
        {
        }
^
        protected [lang]SyntaxNode(InternalSyntaxNode green, [lang]SyntaxNode parent, int position)
            : base(green, parent, position)
        {
        }
^
        public new [lang]Language Language => [lang]Language.Instance;
        protected override Language LanguageCore => this.Language;
        public new [lang]SyntaxKind Kind => ([lang]SyntaxKind)this.RawKind;
        protected override SyntaxKind KindCore => this.Kind;
^
        protected override SyntaxTree CreateSyntaxTreeForRoot()
        {
            return [lang]SyntaxTree.CreateWithoutClone(this);
        }
^
        public override TResult Accept<TArg, TResult>(SyntaxVisitor<TArg, TResult> visitor, TArg argument)
        {
            if (visitor is I[lang]SyntaxVisitor<TArg, TResult> typedVisitor) return this.Accept(typedVisitor, argument);
            else return visitor.DefaultVisit(this, argument);
        }
^
        public abstract TResult Accept<TArg, TResult>(I[lang]SyntaxVisitor<TArg, TResult> visitor, TArg argument);
^
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            if (visitor is I[lang]SyntaxVisitor<TResult> typedVisitor) return this.Accept(typedVisitor);
            else return visitor.DefaultVisit(this);
        }
^
        public abstract TResult Accept<TResult>(I[lang]SyntaxVisitor<TResult> visitor);
^
        public override void Accept(SyntaxVisitor visitor)
        {
            if (visitor is I[lang]SyntaxVisitor typedVisitor) this.Accept(typedVisitor);
            else visitor.DefaultVisit(this);
        }

        public abstract void Accept(I[lang]SyntaxVisitor visitor);
    }
^
	[loop(rule:Instances.ParserRules)]
	[GenerateSyntaxRule(rule, null)]
	[end loop]
}
^
namespace [Properties.DefaultNamespace]
{
    using System.Threading;
    using Microsoft.CodeAnalysis.Text;
	using [Properties.DefaultNamespace].Syntax;
    using [Properties.DefaultNamespace].Syntax.InternalSyntax;
^
	[GenerateSyntaxVisitor()]
^
	//GenerateDetailedSyntaxVisitor()
^
	[GenerateSyntaxTypedArgVisitor()]
^
	[GenerateSyntaxTypedVisitor()]
^
	[GenerateSyntaxRewriter()]
^
	[GenerateSyntaxFactory()]
}
end template

template GenerateSyntaxRule(Antlr4ParserRule rule, Antlr4ParserRule superRule)
[var lang = Properties.LanguageName]
[if (rule.Alternatives.Count > 0)]
^
public abstract class [rule.RedName()] : [lang]SyntaxNode
{
    protected [rule.RedName()](InternalSyntaxNode green, [lang]SyntaxTree syntaxTree, int position)
        : base(green, syntaxTree, position)
    {
    }
^
    protected [rule.RedName()](InternalSyntaxNode green, [lang]SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }
}
	[loop(alt:rule.Alternatives)]
[GenerateSyntaxRule(alt, rule)]
	[end loop]
[else]
^
	[if (superRule != null)]
public sealed class [rule.RedName()] : [superRule.RedName()][GetCompilationUnit(rule)]
	[else]
public sealed class [rule.RedName()] : [Properties.LanguageName]SyntaxNode[GetCompilationUnit(rule)]
	[end if]
{
	[loop(elem:rule.AllElements)]
		[if (elem.IsParserRule)]
    private [elem.RedFieldType()] [elem.FieldName()];
		[end if]
	[end loop]
^
    public [rule.RedName()](InternalSyntaxNode green, [lang]SyntaxTree syntaxTree, int position)
        : base(green, syntaxTree, position)
    {
    }
^
    public [rule.RedName()](InternalSyntaxNode green, [lang]SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }
^
	[loop(elem:rule.AllElements)]
		[if (elem.IsList)]
    public [elem.RedType()] [elem.RedName()] 
	{ 
		get
		{
			[if (elem.IsSeparated)]
			var red = this.GetRed(ref this.[elem.FieldName()], [rule.IndexOf(elem)]);
			if (red != null)
			{
				return new [elem.RedType()](red, this.GetChildIndex([rule.IndexOf(elem)]));
			}
			return default;
			[else if (elem.IsToken)]
			var slot = this.Green.GetSlot([rule.IndexOf(elem)]);
			if (slot != null)
			{
				return new [elem.RedType()](this, slot, this.GetChildPosition([rule.IndexOf(elem)]), this.GetChildIndex([rule.IndexOf(elem)]));
			}
			return default;
			[else]
			var red = this.GetRed(ref this.[elem.FieldName()], [rule.IndexOf(elem)]);
			if (red != null) return new [elem.RedType()](red);
			return default;
			[end if]
		} 
	}
		[else]
			[if (elem.IsToken || elem.IsFixedTokenAltBlock)]
    public [elem.RedType()] [elem.RedName()] 
	{ 
		get 
		{ 
			var green = (global::[Properties.DefaultNamespace].Syntax.InternalSyntax.[rule.GreenName()])this.Green;
			var greenToken = green.[elem.GreenName()];
			return new SyntaxToken(this, greenToken, this.GetChildPosition([rule.IndexOf(elem)]), this.GetChildIndex([rule.IndexOf(elem)]));
		}
	}
			[else]
    public [elem.RedType()] [elem.RedName()] 
	{ 
		get { return this.GetRed(ref this.[elem.FieldName()], [rule.IndexOf(elem)]); } 
	}
			[end if]
		[end if]
	[end loop]
^
    public override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
			[loop(elem:rule.AllElements)]
				[if (elem.IsParserRule)]
			case [rule.IndexOf(elem)]: return this.GetRed(ref this.[elem.FieldName()], [rule.IndexOf(elem)]);
				[end if]
			[end loop]
			default: return null;
        }
    }
^
    public override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
			[loop(elem:rule.AllElements)]
				[if (elem.IsParserRule)]
			case [rule.IndexOf(elem)]: return this.[elem.FieldName()];
				[end if]
			[end loop]
			default: return null;
        }
    }
	[loop(elem:rule.AllElements)]
^
    public [rule.RedName()] With[elem.RedName()]([elem.RedType()] [elem.FieldName()])
	{
		[if (rule.IsSimpleAlt)]
		return this.Update([elem.FieldName()]);
		[else]
		return this.Update([GetElemParamList(rule, false, false, "this.", elem)]);
		[end if]
	}
		[if (elem.IsList && !elem.IsToken)]
^
    public [rule.RedName()] Add[elem.RedName()](params [elem.RedInnerType()]["[]"] [elem.FieldName()])
	{
		return this.With[elem.RedName()](this.[elem.RedName()].AddRange([elem.FieldName()]));
	}
		[end if]
	[end loop]
	[if (rule.IsSimpleAlt)]
		[loop(elem:rule.Elements)]
^
    public [rule.RedName()] Update([elem.RedType()] [elem.FieldName()])
    {
        if (this.[elem.RedName()] != [elem.FieldName()])
        {
            var newNode = [Properties.LanguageName]Language.Instance.SyntaxFactory.[rule.PlainName()]([elem.FieldName()]);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
			return ([rule.RedName()])newNode;
        }
        return this;
    }
		[end loop]
	[else]
^
    public [rule.RedName()] Update([GetElemTypedParamList(rule)])
    {
        if ([GetElemUpdateList(rule)])
        {
            var newNode = [lang]Language.Instance.SyntaxFactory.[rule.PlainName()]([GetInternalElemParamList(rule, false, false, false, "")]);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
			return ([rule.RedName()])newNode;
        }
        return this;
    }
	[end if]
^
    public override TResult Accept<TArg, TResult>(I[lang]SyntaxVisitor<TArg, TResult> visitor, TArg argument)
    {
        return visitor.Visit[rule.PlainName()](this, argument);
    }
^
    public override TResult Accept<TResult>(I[lang]SyntaxVisitor<TResult> visitor)
    {
        return visitor.Visit[rule.PlainName()](this);
    }
^
    public override void Accept(I[lang]SyntaxVisitor visitor)
    {
        visitor.Visit[rule.PlainName()](this);
    }
}
[end if]
end template

template GenerateTokenSyntaxFacts()
using System;
using System.Collections.Generic;
using System.Threading;
using Microsoft.CodeAnalysis;
using MetaDslx.CodeAnalysis.Syntax;
using Roslyn.Utilities;
^
[string className = Properties.LanguageName+"TokensSyntaxFacts"]
[string syntaxKind = Properties.LanguageName+"TokensSyntaxKind"]
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace].Syntax
{
	public enum [lang]TokenKind : int
	{
		None = 0,
		[loop (kind:Instances.LexerTokenKinds.Keys.OrderBy(k => k); separator sep=",")]
		[kind][sep]
		[end loop]
	}
^
	public enum [lang]LexerMode : int
	{
		None = 0,
		[loop (mode:Instances.LexerModes; separator sep=",")]
		[mode.PlainName()] = [mode.Kind][sep]
		[end loop]
	}
^
	public class [className] : SyntaxFacts
	{
        public [className]() 
            : base(typeof([syntaxKind]))
        {
        }
^
        protected [className](Type syntaxKindType) 
            : base(syntaxKindType)
        {
        }
^
        public override SyntaxKind DefaultWhitespaceKind => ([syntaxKind])[syntaxKind].[Instances.DefaultWhitespaceKind.PlainName()];
        public override SyntaxKind DefaultEndOfLineKind => ([syntaxKind])[syntaxKind].[Instances.DefaultEndOfLineKind.PlainName()];
        public override SyntaxKind DefaultSeparatorKind => ([syntaxKind])[syntaxKind].[Instances.DefaultSeparatorKind.PlainName()];
        public override SyntaxKind DefaultIdentifierKind => ([syntaxKind])[syntaxKind].[Instances.DefaultIdentifierKind.PlainName()];
^
		public override bool IsToken(SyntaxKind kind)
		{
			switch (kind.Switch())
			{
				case [syntaxKind].Eof:
				[loop(literal:Instances.LexerRules where literal.Kind > 0)]
				case [syntaxKind].[literal.PlainName()]:
				[end loop]
					return true;
				default:
					return false;
			}
		}
^
		public override bool IsFixedToken(SyntaxKind kind)
		{
			switch (kind.Switch())
			{
				[loop(literal:Instances.FixedTokens where literal.Kind > 0)]
				case [syntaxKind].[literal.PlainName()]:
				[end loop]
					return true;
				default:
					return false;
			}
		}
^
		public override SyntaxKind GetFixedTokenKind(string text)
		{
			switch (text)
			{
				[loop(literal:Instances.FixedTokens where literal.Kind > 0)]
				case [literal.FixedToken.FixedTokenToCSharpString()]:
					return [syntaxKind].[literal.PlainName()];
				[end loop]
				default:
					return [syntaxKind].None;
			}
		}
^
		public override string GetText(SyntaxKind kind)
		{
			switch (kind.Switch())
			{
				[loop(literal:Instances.FixedTokens where literal.Kind > 0)]
				case [syntaxKind].[literal.PlainName()]:
					return [literal.FixedToken.FixedTokenToCSharpString()];
				[end loop]
				default:
					return string.Empty;
			}
		}
^
		public [lang]TokenKind GetTokenKind(int rawKind)
		{
			return this.GetTokenKind(EnumObject.FromIntUnsafe<[syntaxKind]>(rawKind));
		}
^
		public [lang]TokenKind GetTokenKind(SyntaxKind kind)
		{
			switch(kind.Switch())
			{
			[loop (rule:Instances.LexerRules where rule.Kind > 0 && rule.Annotations.HasAnnotation("Token"))]
				[MetaCompilerAnnotation annot = rule.Annotations.GetAnnotation("Token")]
				[if (annot.GetValue("kind") != null)]
					[if (annot.HasProperty("first") && annot.HasProperty("last"))]
						[loop (child:Instances.LexerRulesBetween(annot.GetValue("first"), annot.GetValue("last")) where child.Kind > 0)]
				case [syntaxKind].[child.PlainName()]:
						[end loop]
					return [lang]TokenKind.[annot.GetValue("kind")];
					[else]
				case [syntaxKind].[rule.PlainName()]:
					return [lang]TokenKind.[annot.GetValue("kind")];
					[end if]
				[end if]
			[end loop]
				default:
					return [lang]TokenKind.None;
			}
		}
^
		public [lang]TokenKind GetModeTokenKind(int rawKind)
		{
			return this.GetModeTokenKind(([lang]LexerMode)rawKind);
		}
^
		public [lang]TokenKind GetModeTokenKind([lang]LexerMode kind)
		{
			switch(kind)
			{
			[loop (mode:Instances.LexerModes where mode.Annotations.HasAnnotation("Token"))]
				[MetaCompilerAnnotation annot = mode.Annotations.GetAnnotation("Token")]
				case [lang]LexerMode.[mode.PlainName()]:
					return [lang]TokenKind.[annot.GetValue("kind")];
			[end loop]
				default:
					return [lang]TokenKind.None;
			}
		}
^
		public override bool IsTriviaWithEndOfLine(SyntaxKind kind)
		{
			switch(kind.Switch())
			{
			[loop (rule:Instances.LexerRules where rule.Kind > 0 && rule.Annotations.HasAnnotation("Token"))]
				[MetaCompilerAnnotation annot = rule.Annotations.GetAnnotation("Token")]
				[if (annot.HasProperty("endOfLine") && annot.GetValue("endOfLine") == "true")]
					[if (annot.HasProperty("first") && annot.HasProperty("last"))]
						[loop (child:Instances.LexerRulesBetween(annot.GetValue("first"), annot.GetValue("last")) where child.Kind > 0)]
				case [syntaxKind].[child.PlainName()]:
						[end loop]
					return true;
					[else]
				case [syntaxKind].[rule.PlainName()]:
					return true;
					[end if]
				[end if]
			[end loop]
				default:
					return false;
			}
		}
^
	[loop (kind:Instances.LexerTokenKinds where kind.Key != "Token" && kind.Key != "FixedToken")]
		public[GenerateSyntaxFactsTokenKindOverride(kind.Key)] bool Is[kind.Key](SyntaxKind kind)
		{
			switch(kind.Switch())
			{
			[loop (rule:kind.Value where rule.Kind > 0)]
				[MetaCompilerAnnotation annot = rule.Annotations.GetAnnotation("Token")]
				[if (annot.HasProperty("first") && annot.HasProperty("last"))]
					[loop (child:Instances.LexerRulesBetween(annot.GetValue("first"), annot.GetValue("last")) where child.Kind > 0)]
				case [syntaxKind].[child.PlainName()]:
					[end loop]
					return true;
				[else]
				case [syntaxKind].[rule.PlainName()]:
					return true;
				[end if]
			[end loop]
				default:
					return false;
			}
		}
		[if (kind.Key == "ReservedKeyword" || kind.Key == "ContextualKeyword")]
^
        public override IEnumerable<SyntaxKind> Get[kind.Key]Kinds()
        {
			[if (hasloop(rule:kind.Value where rule.Kind > 0))]
			[loop (rule:kind.Value where rule.Kind > 0)]
				[MetaCompilerAnnotation annot = rule.Annotations.GetAnnotation("Token")]
				[if (annot.HasProperty("first") && annot.HasProperty("last"))]
					[loop (child:Instances.LexerRulesBetween(annot.GetValue("first"), annot.GetValue("last")) where child.Kind > 0)]
				yield return [syntaxKind].[child.PlainName()];
					[end loop]
				[end if]
			[end loop]
			[else]
			yield break;
			[end if]
        }
^
        public override SyntaxKind Get[kind.Key]Kind(string text)
        {
			switch(text)
			{
			[loop (rule:kind.Value where rule.Kind > 0)]
				[MetaCompilerAnnotation annot = rule.Annotations.GetAnnotation("Token")]
				[if (annot.HasProperty("first") && annot.HasProperty("last"))]
					[loop (child:Instances.LexerRulesBetween(annot.GetValue("first"), annot.GetValue("last")) where child.Kind > 0 && !string.IsNullOrWhiteSpace(child.FixedToken))]
				case [child.FixedToken.FixedTokenToCSharpString()]:
					return [syntaxKind].[child.PlainName()];
					[end loop]
				[else]
					[if (rule.Kind > 0 && !string.IsNullOrWhiteSpace(rule.FixedToken))]
				case [rule.FixedToken.FixedTokenToCSharpString()]:
					return [syntaxKind].[rule.PlainName()];
					[end if]
				[end if]
			[end loop]
				default:
					return SyntaxKind.None;
			}
        }
		[end if]
	[end loop]
	}
}
end template

template GenerateNodeSyntaxFacts()
using System;
using System.Collections.Generic;
using System.Threading;
using Microsoft.CodeAnalysis;
using MetaDslx.CodeAnalysis.Syntax;
using Roslyn.Utilities;
^
[string className = Properties.LanguageName+"SyntaxFacts"]
[string syntaxKind = Properties.LanguageName+"SyntaxKind"]
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace].Syntax
{
	public class [className] : [lang]TokensSyntaxFacts
	{
        public [className]() 
            : base(typeof([syntaxKind]))
        {
        }
^
		[if (Instances.MainRule() != null)]
        public override SyntaxKind CompilationUnitKind => ([syntaxKind])[syntaxKind].[Instances.MainRule().PlainName()];
		[end if]
	}
}
end template

template GenerateSyntaxFactsTokenKindOverride(string tokenKind)
[if (Instances.VirtualTokenKinds.Contains(tokenKind))]
 override
[end if]
end template

template GenerateSyntaxVisitor()
public interface I[Properties.LanguageName]SyntaxVisitor
{
   	[loop(rule:Instances.ParserRules)]
		[if (rule.Alternatives.Count > 0)]
			[loop(alt:rule.Alternatives)]
	[GenerateSyntaxVisitorVisit(alt, true)]
			[end loop]
		[else]
	[GenerateSyntaxVisitorVisit(rule, true)]
		[end if]
	[end loop]
}
^
public class [Properties.LanguageName]SyntaxVisitor : SyntaxVisitor, I[Properties.LanguageName]SyntaxVisitor
{
   	[loop(rule:Instances.ParserRules)]
		[if (rule.Alternatives.Count > 0)]
			[loop(alt:rule.Alternatives)]
	[GenerateSyntaxVisitorVisit(alt, false)]
			[end loop]
		[else]
	[GenerateSyntaxVisitorVisit(rule, false)]
		[end if]
	[end loop]
}
end template

template GenerateSyntaxVisitorVisit(Antlr4ParserRule rule, bool intf)
^
[if (intf)]
void Visit[rule.PlainName()]([rule.RedName()] node);
[else]
public virtual void Visit[rule.PlainName()]([rule.RedName()] node)
{
    this.DefaultVisit(node);
}
[end if]
end template

template GenerateSyntaxTypedVisitor()
public interface I[Properties.LanguageName]SyntaxVisitor<TResult> 
{
   	[loop(rule:Instances.ParserRules)]
		[if (rule.Alternatives.Count > 0)]
			[loop(alt:rule.Alternatives)]
	[GenerateSyntaxTypedVisitorVisit(alt, true)]
			[end loop]
		[else]
	[GenerateSyntaxTypedVisitorVisit(rule, true)]
		[end if]
	[end loop]
}
^
public class [Properties.LanguageName]SyntaxVisitor<TResult> : SyntaxVisitor<TResult>, I[Properties.LanguageName]SyntaxVisitor<TResult>
{
   	[loop(rule:Instances.ParserRules)]
		[if (rule.Alternatives.Count > 0)]
			[loop(alt:rule.Alternatives)]
	[GenerateSyntaxTypedVisitorVisit(alt, false)]
			[end loop]
		[else]
	[GenerateSyntaxTypedVisitorVisit(rule, false)]
		[end if]
	[end loop]
}
end template

template GenerateSyntaxTypedVisitorVisit(Antlr4ParserRule rule, bool intf)
^
[if (intf)]
TResult Visit[rule.PlainName()]([rule.RedName()] node);
[else]
public virtual TResult Visit[rule.PlainName()]([rule.RedName()] node)
{
    return this.DefaultVisit(node);
}
[end if]
end template

template GenerateSyntaxTypedArgVisitor()
public interface I[Properties.LanguageName]SyntaxVisitor<TArg, TResult> 
{
   	[loop(rule:Instances.ParserRules)]
		[if (rule.Alternatives.Count > 0)]
			[loop(alt:rule.Alternatives)]
	[GenerateSyntaxTypedArgVisitorVisit(alt, true)]
			[end loop]
		[else]
	[GenerateSyntaxTypedArgVisitorVisit(rule, true)]
		[end if]
	[end loop]
}
^
public class [Properties.LanguageName]SyntaxVisitor<TArg, TResult> : SyntaxVisitor<TArg, TResult>, I[Properties.LanguageName]SyntaxVisitor<TArg, TResult>
{
   	[loop(rule:Instances.ParserRules)]
		[if (rule.Alternatives.Count > 0)]
			[loop(alt:rule.Alternatives)]
	[GenerateSyntaxTypedArgVisitorVisit(alt, false)]
			[end loop]
		[else]
	[GenerateSyntaxTypedArgVisitorVisit(rule, false)]
		[end if]
	[end loop]
}
end template

template GenerateSyntaxTypedArgVisitorVisit(Antlr4ParserRule rule, bool intf)
^
[if (intf)]
TResult Visit[rule.PlainName()]([rule.RedName()] node, TArg argument);
[else]
public virtual TResult Visit[rule.PlainName()]([rule.RedName()] node, TArg argument)
{
    return this.DefaultVisit(node, argument);
}
[end if]
end template

template GenerateDetailedSyntaxVisitor()
public class [Properties.LanguageName]DetailedSyntaxVisitor : DetailedSyntaxVisitor, I[Properties.LanguageName]SyntaxVisitor
{
    public [Properties.LanguageName]DetailedSyntaxVisitor(bool visitIntoStructuredToken = false, bool visitIntoStructuredTrivia = false)
		: base(visitIntoStructuredToken, visitIntoStructuredTrivia)
    {
    }
   	[loop(rule:Instances.ParserRules)]
		[if (rule.Alternatives.Count > 0)]
			[loop(alt:rule.Alternatives)]
	[GenerateDetailedSyntaxVisitorVisit(alt)]
			[end loop]
		[else]
	[GenerateDetailedSyntaxVisitorVisit(rule)]
		[end if]
	[end loop]
}
end template

template GenerateDetailedSyntaxVisitorVisit(Antlr4ParserRule rule)
^
public virtual void Visit[rule.PlainName()]([rule.RedName()] node)
{
	[if (rule.IsSimpleAlt)]
		[loop(elem:rule.Elements)]
			[if (elem.IsList)]
	this.VisitList(node.[elem.RedName()]);
			[else]
				[if (elem.IsToken || elem.IsFixedTokenAltBlock)]
	this.Visit(node.[elem.RedName()]);
				[else]
	this.Visit(node.[elem.RedName()]);
				[end if]
			[end if]
		[end loop] 
	[else]
		[loop(elem:rule.AllElements)]
			[if (elem.IsList)]
	this.VisitList(node.[elem.RedName()]);
			[else]
				[if (elem.IsToken || elem.IsFixedTokenAltBlock)]
	this.VisitToken(node.[elem.RedName()]);
				[else]
	this.Visit(node.[elem.RedName()]);
				[end if]
			[end if]
		[end loop]    
	[end if]
}
end template

template GenerateSyntaxRewriter()
public class [Properties.LanguageName]SyntaxRewriter : SyntaxRewriter, I[Properties.LanguageName]SyntaxVisitor<SyntaxNode>
{
    public [Properties.LanguageName]SyntaxRewriter(bool visitIntoStructuredTrivia = false)
		: base([Properties.LanguageName]Language.Instance, visitIntoStructuredTrivia)
    {
    }
   	[loop(rule:Instances.ParserRules)]
		[if (rule.Alternatives.Count > 0)]
			[loop(alt:rule.Alternatives)]
	[GenerateSyntaxRewriterVisit(alt)]
			[end loop]
		[else]
	[GenerateSyntaxRewriterVisit(rule)]
		[end if]
	[end loop]
}
end template

template GenerateSyntaxRewriterVisit(Antlr4ParserRule rule)
^
public virtual SyntaxNode Visit[rule.PlainName()]([rule.RedName()] node)
{
	[if (rule.IsSimpleAlt)]
		[loop(elem:rule.Elements)]
	var old[elem.RedName()] = node.[elem.RedName()];
	if (old[elem.RedName()] != null)
	{
			[if (elem.IsList)]
		var new[elem.RedName()] = this.VisitList(old[elem.RedName()]);
			[else]
				[if (elem.IsToken || elem.IsFixedTokenAltBlock)]
		var new[elem.RedName()] = (InternalSyntaxToken)this.Visit(old[elem.RedName()]);
				[else]
	    var new[elem.RedName()] = ([elem.RedType()])this.Visit(old[elem.RedName()]);
				[end if]
			[end if]
		return node.Update(new[elem.RedName()]);
	}
		[end loop] 
	return node;   
	[else]
		[loop(elem:rule.AllElements)]
			[if (elem.IsList)]
    var [elem.FieldName()] = this.VisitList(node.[elem.RedName()]);
			[else]
				[if (elem.IsToken || elem.IsFixedTokenAltBlock)]
    var [elem.FieldName()] = this.VisitToken(node.[elem.RedName()]);
				[else]
    var [elem.FieldName()] = ([elem.RedType()])this.Visit(node.[elem.RedName()]);
				[end if]
			[end if]
		[end loop]    
	return node.Update([GetInternalElemParamList(rule, false, false, false, "")]);
	[end if]
}
end template

template GenerateSyntaxFactory()
[var lang = Properties.LanguageName]
public class [Properties.LanguageName]SyntaxFactory : SyntaxFactory
{
	internal [lang]SyntaxFactory([lang]InternalSyntaxFactory internalSyntaxFactory) 
		: base(internalSyntaxFactory)
	{
	}
	
	public new [lang]Language Language
	{
		get { return [lang]Language.Instance; }
	}
	
	protected override Language LanguageCore
	{
		get { return this.Language; }
	}
	
	/// <summary>
	/// Create a new syntax tree from a syntax node.
	/// </summary>
	public [lang]SyntaxTree SyntaxTree(SyntaxNode root, [lang]ParseOptions options = null, string path = "", Encoding encoding = null)
	{
		return [lang]SyntaxTree.Create(([lang]SyntaxNode)root, ([lang]ParseOptions)options, path, encoding);
	}
	
	/// <summary>
	/// Produces a syntax tree by parsing the source text.
	/// </summary>
	public [lang]SyntaxTree ParseSyntaxTree(
		string text,
		[lang]ParseOptions options = null,
		string path = "",
		Encoding encoding = null,
		CancellationToken cancellationToken = default(CancellationToken))
	{
		return ([lang]SyntaxTree)this.ParseSyntaxTreeCore(SourceText.From(text, encoding), options, path, cancellationToken);
	}
	
	/// <summary>
	/// Produces a syntax tree by parsing the source text.
	/// </summary>
	public [lang]SyntaxTree ParseSyntaxTree(
		SourceText text,
		[lang]ParseOptions options = null,
		string path = "",
		CancellationToken cancellationToken = default(CancellationToken))
	{
		return ([lang]SyntaxTree)this.ParseSyntaxTreeCore(text, options, path, cancellationToken);
	}
	
	protected override LanguageSyntaxTree ParseSyntaxTreeCore(
		SourceText text,
		ParseOptions options = null,
		string path = "",
		CancellationToken cancellationToken = default(CancellationToken))
	{
		return [lang]SyntaxTree.ParseText(text, ([lang]ParseOptions)options, path, cancellationToken);
	}
^
    public [Instances.MainRule().RedName()] Parse[Instances.MainRule().PlainName()](string text)
    {
        // note that we do not need a "consumeFullText" parameter, because parsing a compilation unit always must
        // consume input until the end-of-file
        using (var parser = MakeParser(text))
        {
            var node = parser.Parse();
            if (node == null) return null;
            // if (consumeFullText) node = parser.ConsumeUnexpectedTokens(node);
            return ([Instances.MainRule().RedName()])node.CreateRed();
        }
    }
^
	public override SyntaxParser MakeParser(SourceText text, ParseOptions options, SyntaxNode oldTree, IReadOnlyList<TextChangeRange> changes)
	{
	    return new [lang]SyntaxParser(text, ([lang]ParseOptions)options, oldTree, changes);
	}
^
	public override SyntaxParser MakeParser(string text)
	{
	    return new [lang]SyntaxParser(SourceText.From(text, Encoding.UTF8), [lang]ParseOptions.Default, null, null);
	}
^
    public override SyntaxNode CreateStructure(SyntaxTrivia trivia)
    {
        throw new NotImplementedException();
    }
^
[loop(rule:Instances.LexerRules)]
	[if (rule.FixedToken == null)]
^
    public SyntaxToken [rule.PlainName()](string text)
    {
        return new SyntaxToken([Properties.LanguageName]Language.Instance.InternalSyntaxFactory.[rule.PlainName()](text));
    }
^
    public SyntaxToken [rule.PlainName()](string text, object value)
    {
        return new SyntaxToken([Properties.LanguageName]Language.Instance.InternalSyntaxFactory.[rule.PlainName()](text, value));
    }
	[end if]
[end loop]
[loop(rule:Instances.ParserRules)]
	[if (rule.Alternatives.Count > 0)]
		[loop(alt:rule.Alternatives)]
	[GenerateSyntaxFactoryCreate(alt)]
		[end loop]
	[else]
	[GenerateSyntaxFactoryCreate(rule)]
	[end if]
[end loop]
^
    internal static IEnumerable<Type> GetNodeTypes()
    {
        return new Type["[]"] {
[loop(rule:Instances.ParserRules)]
	[if (rule.Alternatives.Count > 0)]
		[loop(alt:rule.Alternatives)]
			typeof([alt.RedName()]),
		[end loop]
	[else]
			typeof([rule.RedName()]),
	[end if]
[end loop]
		};
	}
}
end template

template GenerateSyntaxFactoryCreate(Antlr4ParserRule rule)
[if (rule.IsSimpleAlt)]
	[loop(elem:rule.Elements)]
^
public [rule.RedName()] [rule.PlainName()]([elem.RedType()] [elem.FieldName()])
{
		[if (!elem.IsOptional)]
    if ([elem.FieldName()] == null) throw new ArgumentNullException(nameof([elem.FieldName()]));
			[if (elem.IsToken && !elem.IsList)]
    if ([elem.FieldName()].GetKind() != [Properties.LanguageName]SyntaxKind.[elem.SyntaxKind()]) throw new ArgumentException(nameof([elem.FieldName()]));
			[end if]
		[else]
			[if (elem.IsToken && !elem.IsList)]
    if ([elem.FieldName()] != null && [elem.FieldName()].GetKind() != [Properties.LanguageName]SyntaxKind.[elem.SyntaxKind()]) throw new ArgumentException(nameof([elem.FieldName()]));
			[end if]
		[end if]
    return ([rule.RedName()])[Properties.LanguageName]Language.Instance.InternalSyntaxFactory.[rule.PlainName()]([GetRedToGreenParamElem(elem)]).CreateRed();
}
	[end loop]
[else]
^
public [rule.RedName()] [rule.PlainName()]([GetElemTypedParamList(rule)])
{
	[loop(elem:rule.AllElements)]
		[if (!elem.IsOptional)]
    if ([elem.FieldName()] == null) throw new ArgumentNullException(nameof([elem.FieldName()]));
			[if (elem.IsToken && !elem.IsList)]
    if ([elem.FieldName()].GetKind() != [Properties.LanguageName]SyntaxKind.[elem.SyntaxKind()]) throw new ArgumentException(nameof([elem.FieldName()]));
			[end if]
		[else]
			[if (elem.IsToken && !elem.IsList)]
    if ([elem.FieldName()] != null && [elem.FieldName()].GetKind() != [Properties.LanguageName]SyntaxKind.[elem.SyntaxKind()]) throw new ArgumentException(nameof([elem.FieldName()]));
			[end if]
		[end if]
	[end loop]
    return ([rule.RedName()])[Properties.LanguageName]Language.Instance.InternalSyntaxFactory.[rule.PlainName()]([GetRedToGreenParamList(rule)]).CreateRed();
}
[if (rule.HasOptionalElements())]
^
public [rule.RedName()] [rule.PlainName()]([GetElemTypedParamList(rule, false, false, true)])
{
	return this.[rule.PlainName()]([GetRedToGreenParamList(rule, false, false, true)]);
}
[end if]
[end if]
end template


template GenerateGreenToken()
[var lang = Properties.LanguageName]
internal partial class GreenSyntaxToken : InternalSyntaxToken
{
    //====================
    // Optimization: Normally, we wouldn't accept this much duplicate code, but these constructors
    // are called A LOT and we want to keep them as short and simple as possible and increase the
    // likelihood that they will be inlined.

    internal GreenSyntaxToken([lang]SyntaxKind kind)
        : base(kind)
    {
    }

    internal GreenSyntaxToken([lang]SyntaxKind kind, DiagnosticInfo["[]"] diagnostics)
        : base(kind, diagnostics)
    {
    }

    internal GreenSyntaxToken([lang]SyntaxKind kind, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
        : base(kind, diagnostics, annotations)
    {
    }

    internal GreenSyntaxToken([lang]SyntaxKind kind, int fullWidth)
        : base(kind, fullWidth)
    {
    }

    internal GreenSyntaxToken([lang]SyntaxKind kind, int fullWidth, DiagnosticInfo["[]"] diagnostics)
        : base(kind, fullWidth, diagnostics)
    {
    }

    internal GreenSyntaxToken([lang]SyntaxKind kind, int fullWidth, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
        : base(kind, fullWidth, diagnostics, annotations)
    {
    }

    internal GreenSyntaxToken(ObjectReader reader)
        : base(reader)
    {
        var text = this.Text;
        if (text != null)
        {
            FullWidth = text.Length;
        }

        this.flags |= NodeFlags.IsNotMissing;  //note: cleared by subclasses representing missing tokens
    }

    public new [lang]Language Language => [lang]Language.Instance;
    protected override Language LanguageCore => this.Language;
    public new [lang]SyntaxKind Kind => EnumObject.FromIntUnsafe<[lang]SyntaxKind>(this.RawKind);
    protected override SyntaxKind KindCore => this.Kind;

    protected override bool ShouldReuseInSerialization => base.ShouldReuseInSerialization &&
                                                            FullWidth < Language.SyntaxFacts.MaxCachedTokenSize;

    //====================

    internal static GreenSyntaxToken Create([lang]SyntaxKind kind)
    {
        if (kind > LastTokenWithWellKnownText)
        {
            if (![lang]Language.Instance.SyntaxFacts.IsToken(kind))
            {
                throw new ArgumentException(string.Format("Invalid [lang]SyntaxKind: {0}. This method can only be used to create tokens.", kind), nameof(kind));
            }

            return CreateMissing(kind, null, null);
        }

        return s_tokensWithNoTrivia["[(int)kind]"].Value;
    }

    internal static GreenSyntaxToken Create([lang]SyntaxKind kind, GreenNode leading, GreenNode trailing)
    {
        if (kind > LastTokenWithWellKnownText)
        {
            if (![lang]Language.Instance.SyntaxFacts.IsToken(kind))
            {
                throw new ArgumentException(string.Format("Invalid [lang]SyntaxKind: {0}. This method can only be used to create tokens.", kind), nameof(kind));
            }

            return CreateMissing(kind, leading, trailing);
        }

        if (leading == null)
        {
            if (trailing == null)
            {
                return s_tokensWithNoTrivia["[(int)kind]"].Value;
            }
            else if (trailing == [lang]Language.Instance.InternalSyntaxFactory.Space)
            {
                return s_tokensWithSingleTrailingSpace["[(int)kind]"].Value;
            }
            else if (trailing == [lang]Language.Instance.InternalSyntaxFactory.CarriageReturnLineFeed)
            {
                return s_tokensWithSingleTrailingCRLF["[(int)kind]"].Value;
            }
        }

        if (leading == [lang]Language.Instance.InternalSyntaxFactory.ElasticZeroSpace && trailing == [lang]Language.Instance.InternalSyntaxFactory.ElasticZeroSpace)
        {
            return s_tokensWithElasticTrivia["[(int)kind]"].Value;
        }

        return new SyntaxTokenWithTrivia(kind, leading, trailing);
    }

    internal static GreenSyntaxToken CreateMissing([lang]SyntaxKind kind, GreenNode leading, GreenNode trailing)
    {
        return new MissingTokenWithTrivia(kind, leading, trailing);
    }

    internal static readonly [lang]SyntaxKind FirstTokenWithWellKnownText;
    internal static readonly [lang]SyntaxKind LastTokenWithWellKnownText;

    // TODO: eliminate the blank space before the first interesting element?
    private static readonly ArrayElement<GreenSyntaxToken>["[]"] s_tokensWithNoTrivia;
    private static readonly ArrayElement<GreenSyntaxToken>["[]"] s_tokensWithElasticTrivia;
    private static readonly ArrayElement<GreenSyntaxToken>["[]"] s_tokensWithSingleTrailingSpace;
    private static readonly ArrayElement<GreenSyntaxToken>["[]"] s_tokensWithSingleTrailingCRLF;

    static GreenSyntaxToken()
    {
        ObjectBinder.RegisterTypeReader(typeof(GreenSyntaxToken), r => new GreenSyntaxToken(r));

        FirstTokenWithWellKnownText = [lang]SyntaxKind.__FirstFixedToken;
        LastTokenWithWellKnownText = [lang]SyntaxKind.__LastFixedToken;

        s_tokensWithNoTrivia = new ArrayElement<GreenSyntaxToken>["[(int)LastTokenWithWellKnownText + 1]"];
        s_tokensWithElasticTrivia = new ArrayElement<GreenSyntaxToken>["[(int)LastTokenWithWellKnownText + 1]"];
        s_tokensWithSingleTrailingSpace = new ArrayElement<GreenSyntaxToken>["[(int)LastTokenWithWellKnownText + 1]"];
        s_tokensWithSingleTrailingCRLF = new ArrayElement<GreenSyntaxToken>["[(int)LastTokenWithWellKnownText + 1]"];
		InternalSyntaxFactory factory = [lang]Language.Instance.InternalSyntaxFactory;
        for (EnumObject kind = FirstTokenWithWellKnownText; kind <= LastTokenWithWellKnownText; kind++)
        {
            s_tokensWithNoTrivia["[(int)kind]"].Value = new GreenSyntaxToken(([lang]SyntaxKind)kind);
            s_tokensWithElasticTrivia["[(int)kind]"].Value = new SyntaxTokenWithTrivia(([lang]SyntaxKind)kind, factory.ElasticZeroSpace, factory.ElasticZeroSpace);
            s_tokensWithSingleTrailingSpace["[(int)kind]"].Value = new SyntaxTokenWithTrivia(([lang]SyntaxKind)kind, null, factory.Space);
            s_tokensWithSingleTrailingCRLF["[(int)kind]"].Value = new SyntaxTokenWithTrivia(([lang]SyntaxKind)kind, null, factory.CarriageReturnLineFeed);
        }
    }

    internal static IEnumerable<GreenSyntaxToken> GetWellKnownTokens()
    {
        foreach (var element in s_tokensWithNoTrivia)
        {
            if (element.Value != null)
            {
                yield return element.Value;
            }
        }

        foreach (var element in s_tokensWithElasticTrivia)
        {
            if (element.Value != null)
            {
                yield return element.Value;
            }
        }

        foreach (var element in s_tokensWithSingleTrailingSpace)
        {
            if (element.Value != null)
            {
                yield return element.Value;
            }
        }

        foreach (var element in s_tokensWithSingleTrailingCRLF)
        {
            if (element.Value != null)
            {
                yield return element.Value;
            }
        }
    }

    internal static GreenSyntaxToken Identifier([lang]SyntaxKind kind, string text)
    {
        return new SyntaxIdentifier(kind, text);
    }

    internal static GreenSyntaxToken Identifier([lang]SyntaxKind kind, GreenNode leading, string text, GreenNode trailing)
    {
        if (leading == null)
        {
            if (trailing == null)
            {
                return Identifier(kind, text);
            }
            else
            {
                return new SyntaxIdentifierWithTrailingTrivia(kind, text, trailing);
            }
        }

        return new SyntaxIdentifierWithTrivia(kind, kind, text, text, leading, trailing);
    }

    internal static GreenSyntaxToken Identifier([lang]SyntaxKind kind, [lang]SyntaxKind contextualKind, GreenNode leading, string text, string valueText, GreenNode trailing)
    {
        if (contextualKind == kind && valueText == text)
        {
            return Identifier(kind, leading, text, trailing);
        }

        return new SyntaxIdentifierWithTrivia(kind, contextualKind, text, valueText, leading, trailing);
    }

    internal static GreenSyntaxToken WithValue<T>([lang]SyntaxKind kind, string text, T value)
    {
        return new SyntaxTokenWithValue<T>(kind, text, value);
    }

    internal static GreenSyntaxToken WithValue<T>([lang]SyntaxKind kind, GreenNode leading, string text, T value, GreenNode trailing)
    {
        return new SyntaxTokenWithValueAndTrivia<T>(kind, text, value, leading, trailing);
    }

    public virtual [lang]SyntaxKind ContextualKind => this.Kind;

    public override int RawContextualKind => (int)this.ContextualKind;

    public override InternalSyntaxToken TokenWithLeadingTrivia(GreenNode trivia)
    {
        return new SyntaxTokenWithTrivia(this.Kind, trivia, null, this.GetDiagnostics(), this.GetAnnotations());
    }

    public override InternalSyntaxToken TokenWithTrailingTrivia(GreenNode trivia)
    {
        return new SyntaxTokenWithTrivia(this.Kind, null, trivia, this.GetDiagnostics(), this.GetAnnotations());
    }

    public override InternalSyntaxNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
    {
        System.Diagnostics.Debug.Assert(this.GetType() == typeof(GreenSyntaxToken));
        return new GreenSyntaxToken(this.Kind, this.FullWidth, diagnostics, this.GetAnnotations());
    }

    public override InternalSyntaxNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
    {
        System.Diagnostics.Debug.Assert(this.GetType() == typeof(GreenSyntaxToken));
        return new GreenSyntaxToken(this.Kind, this.FullWidth, this.GetDiagnostics(), annotations);
    }

    public override TResult Accept<TResult>(InternalSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitToken(this);
    }

    public override void Accept(InternalSyntaxVisitor visitor)
    {
        visitor.VisitToken(this);
    }

    protected override void WriteTokenTo(System.IO.TextWriter writer, bool leading, bool trailing)
    {
        if (leading)
        {
            var trivia = this.GetLeadingTrivia();
            if (trivia != null)
            {
                trivia.WriteTo(writer);
            }
        }

        writer.Write(this.Text);

        if (trailing)
        {
            var trivia = this.GetTrailingTrivia();
            if (trivia != null)
            {
                trivia.WriteTo(writer);
            }
        }
    }
^
    internal class MissingTokenWithTrivia : SyntaxTokenWithTrivia
    {
        internal MissingTokenWithTrivia([lang]SyntaxKind kind, GreenNode leading, GreenNode trailing)
            : base(kind, leading, trailing)
        {
            this.flags &= ~NodeFlags.IsNotMissing;
        }

        internal MissingTokenWithTrivia([lang]SyntaxKind kind, GreenNode leading, GreenNode trailing, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
            : base(kind, leading, trailing, diagnostics, annotations)
        {
            this.flags &= ~NodeFlags.IsNotMissing;
        }

        internal MissingTokenWithTrivia(ObjectReader reader)
            : base(reader)
        {
            this.flags &= ~NodeFlags.IsNotMissing;
        }

        static MissingTokenWithTrivia()
        {
            ObjectBinder.RegisterTypeReader(typeof(MissingTokenWithTrivia), r => new MissingTokenWithTrivia(r));
        }

        public override string Text
        {
            get { return string.Empty; }
        }

        public override object Value
        {
            get
            {
                if (Language.SyntaxFacts.IsIdentifier(this.Kind)) return string.Empty;
                else return null;
            }
        }

        public override InternalSyntaxToken TokenWithLeadingTrivia(GreenNode trivia)
        {
            return new MissingTokenWithTrivia(this.Kind, trivia, this.TrailingField, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxToken TokenWithTrailingTrivia(GreenNode trivia)
        {
            return new MissingTokenWithTrivia(this.Kind, this.LeadingField, trivia, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
        {
            return new MissingTokenWithTrivia(this.Kind, this.LeadingField, this.TrailingField, diagnostics, this.GetAnnotations());
        }

        public override InternalSyntaxNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
        {
            return new MissingTokenWithTrivia(this.Kind, this.LeadingField, this.TrailingField, this.GetDiagnostics(), annotations);
        }
    }
^
    internal class SyntaxIdentifier : GreenSyntaxToken
    {
        static SyntaxIdentifier()
        {
            ObjectBinder.RegisterTypeReader(typeof(SyntaxIdentifier), r => new SyntaxIdentifier(r));
        }

        protected readonly string TextField;

        internal SyntaxIdentifier([lang]SyntaxKind kind, string text)
            : base(kind, text.Length)
        {
            this.TextField = text;
        }

        internal SyntaxIdentifier([lang]SyntaxKind kind, string text, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
            : base(kind, text.Length, diagnostics, annotations)
        {
            this.TextField = text;
        }

        internal SyntaxIdentifier(ObjectReader reader)
            : base(reader)
        {
            this.TextField = reader.ReadString();
            this.FullWidth = this.TextField.Length;
        }

        protected override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteString(this.TextField);
        }

        public override string Text
        {
            get { return this.TextField; }
        }

        public override object Value
        {
            get { return this.TextField; }
        }

        public override string ValueText
        {
            get { return this.TextField; }
        }

        public override InternalSyntaxToken TokenWithLeadingTrivia(GreenNode trivia)
        {
            return new SyntaxIdentifierWithTrivia(this.Kind, this.ContextualKind, this.TextField, this.TextField, trivia, null, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxToken TokenWithTrailingTrivia(GreenNode trivia)
        {
            return new SyntaxIdentifierWithTrivia(this.Kind, this.ContextualKind, this.TextField, this.TextField, null, trivia, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
        {
            return new SyntaxIdentifier(this.Kind, this.Text, diagnostics, this.GetAnnotations());
        }

        public override InternalSyntaxNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
        {
            return new SyntaxIdentifier(this.Kind, this.Text, this.GetDiagnostics(), annotations);
        }
    }
^
    internal class SyntaxIdentifierExtended : SyntaxIdentifier
    {
        protected readonly [lang]SyntaxKind contextualKind;
        protected readonly string valueText;

        internal SyntaxIdentifierExtended([lang]SyntaxKind kind, [lang]SyntaxKind contextualKind, string text, string valueText)
            : base(kind, text)
        {
            this.contextualKind = contextualKind;
            this.valueText = valueText;
        }

        internal SyntaxIdentifierExtended([lang]SyntaxKind kind, [lang]SyntaxKind contextualKind, string text, string valueText, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
            : base(kind, text, diagnostics, annotations)
        {
            this.contextualKind = contextualKind;
            this.valueText = valueText;
        }

        internal SyntaxIdentifierExtended(ObjectReader reader)
            : base(reader)
        {
            this.contextualKind = EnumObject.FromIntUnsafe<[lang]SyntaxKind>(reader.ReadInt32());
            this.valueText = reader.ReadString();
        }

        static SyntaxIdentifierExtended()
        {
            ObjectBinder.RegisterTypeReader(typeof(SyntaxIdentifierExtended), r => new SyntaxIdentifierExtended(r));
        }

        protected override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteInt32((int)this.contextualKind);
            writer.WriteString(this.valueText);
        }

        public override [lang]SyntaxKind ContextualKind
        {
            get { return this.contextualKind; }
        }

        public override string ValueText
        {
            get { return this.valueText; }
        }

        public override object Value
        {
            get { return this.valueText; }
        }

        public override InternalSyntaxToken TokenWithLeadingTrivia(GreenNode trivia)
        {
            return new SyntaxIdentifierWithTrivia(this.Kind, this.contextualKind, this.TextField, this.valueText, trivia, null, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxToken TokenWithTrailingTrivia(GreenNode trivia)
        {
            return new SyntaxIdentifierWithTrivia(this.Kind, this.contextualKind, this.TextField, this.valueText, null, trivia, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
        {
            return new SyntaxIdentifierExtended(this.Kind, this.contextualKind, this.TextField, this.valueText, diagnostics, this.GetAnnotations());
        }

        public override InternalSyntaxNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
        {
            return new SyntaxIdentifierExtended(this.Kind, this.contextualKind, this.TextField, this.valueText, this.GetDiagnostics(), annotations);
        }
    }
^
	internal class SyntaxIdentifierWithTrailingTrivia : SyntaxIdentifier
    {
        private readonly GreenNode _trailing;

        internal SyntaxIdentifierWithTrailingTrivia([lang]SyntaxKind kind, string text, GreenNode trailing)
            : base(kind, text)
        {
            if (trailing != null)
            {
                this.AdjustFlagsAndWidth(trailing);
                _trailing = trailing;
            }
        }

        internal SyntaxIdentifierWithTrailingTrivia([lang]SyntaxKind kind, string text, GreenNode trailing, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
            : base(kind, text, diagnostics, annotations)
        {
            if (trailing != null)
            {
                this.AdjustFlagsAndWidth(trailing);
                _trailing = trailing;
            }
        }

        internal SyntaxIdentifierWithTrailingTrivia(ObjectReader reader)
            : base(reader)
        {
            var trailing = (GreenNode)reader.ReadValue();
            if (trailing != null)
            {
                this.AdjustFlagsAndWidth(trailing);
                _trailing = trailing;
            }
        }

        static SyntaxIdentifierWithTrailingTrivia()
        {
            ObjectBinder.RegisterTypeReader(typeof(SyntaxIdentifierWithTrailingTrivia), r => new SyntaxIdentifierWithTrailingTrivia(r));
        }

        protected override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(_trailing);
        }

        public override GreenNode GetTrailingTrivia()
        {
            return _trailing;
        }

        public override InternalSyntaxToken TokenWithLeadingTrivia(GreenNode trivia)
        {
            return new SyntaxIdentifierWithTrivia(this.Kind, this.ContextualKind, this.TextField, this.TextField, trivia, _trailing, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxToken TokenWithTrailingTrivia(GreenNode trivia)
        {
            return new SyntaxIdentifierWithTrailingTrivia(this.Kind, this.TextField, trivia, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
        {
            return new SyntaxIdentifierWithTrailingTrivia(this.Kind, this.TextField, _trailing, diagnostics, this.GetAnnotations());
        }

        public override InternalSyntaxNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
        {
            return new SyntaxIdentifierWithTrailingTrivia(this.Kind, this.TextField, _trailing, this.GetDiagnostics(), annotations);
        }
    }
^
    internal class SyntaxIdentifierWithTrivia : SyntaxIdentifierExtended
    {
        private readonly GreenNode _leading;
        private readonly GreenNode _trailing;

        internal SyntaxIdentifierWithTrivia(
            [lang]SyntaxKind kind,
            [lang]SyntaxKind contextualKind,
            string text,
            string valueText,
            GreenNode leading,
            GreenNode trailing)
            : base(kind, contextualKind, text, valueText)
        {
            if (leading != null)
            {
                this.AdjustFlagsAndWidth(leading);
                _leading = leading;
            }
            if (trailing != null)
            {
                this.AdjustFlagsAndWidth(trailing);
                _trailing = trailing;
            }
        }

        internal SyntaxIdentifierWithTrivia(
            [lang]SyntaxKind kind,
            [lang]SyntaxKind contextualKind,
            string text,
            string valueText,
            GreenNode leading,
            GreenNode trailing,
            DiagnosticInfo["[]"] diagnostics,
            SyntaxAnnotation["[]"] annotations)
            : base(kind, contextualKind, text, valueText, diagnostics, annotations)
        {
            if (leading != null)
            {
                this.AdjustFlagsAndWidth(leading);
                _leading = leading;
            }
            if (trailing != null)
            {
                this.AdjustFlagsAndWidth(trailing);
                _trailing = trailing;
            }
        }

        internal SyntaxIdentifierWithTrivia(ObjectReader reader)
            : base(reader)
        {
            var leading = (GreenNode)reader.ReadValue();
            if (leading != null)
            {
                this.AdjustFlagsAndWidth(leading);
                _leading = leading;
            }
            var trailing = (GreenNode)reader.ReadValue();
            if (trailing != null)
            {
                _trailing = trailing;
                this.AdjustFlagsAndWidth(trailing);
            }
        }

        static SyntaxIdentifierWithTrivia()
        {
            ObjectBinder.RegisterTypeReader(typeof(SyntaxIdentifierWithTrivia), r => new SyntaxIdentifierWithTrivia(r));
        }

        protected override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(_leading);
            writer.WriteValue(_trailing);
        }

        public override GreenNode GetLeadingTrivia()
        {
            return _leading;
        }

        public override GreenNode GetTrailingTrivia()
        {
            return _trailing;
        }

        public override InternalSyntaxToken TokenWithLeadingTrivia(GreenNode trivia)
        {
            return new SyntaxIdentifierWithTrivia(this.Kind, this.contextualKind, this.TextField, this.valueText, trivia, _trailing, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxToken TokenWithTrailingTrivia(GreenNode trivia)
        {
            return new SyntaxIdentifierWithTrivia(this.Kind, this.contextualKind, this.TextField, this.valueText, _leading, trivia, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
        {
            return new SyntaxIdentifierWithTrivia(this.Kind, this.contextualKind, this.TextField, this.valueText, _leading, _trailing, diagnostics, this.GetAnnotations());
        }

        public override InternalSyntaxNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
        {
            return new SyntaxIdentifierWithTrivia(this.Kind, this.contextualKind, this.TextField, this.valueText, _leading, _trailing, this.GetDiagnostics(), annotations);
        }
    }
^
    internal class SyntaxTokenWithValue<T> : GreenSyntaxToken
    {
        protected readonly string TextField;
        protected readonly T ValueField;

        internal SyntaxTokenWithValue([lang]SyntaxKind kind, string text, T value)
            : base(kind, text.Length)
        {
            this.TextField = text;
            this.ValueField = value;
        }

        internal SyntaxTokenWithValue([lang]SyntaxKind kind, string text, T value, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
            : base(kind, text.Length, diagnostics, annotations)
        {
            this.TextField = text;
            this.ValueField = value;
        }

        internal SyntaxTokenWithValue(ObjectReader reader)
            : base(reader)
        {
            this.TextField = reader.ReadString();
            this.FullWidth = this.TextField.Length;
            this.ValueField = (T)reader.ReadValue();
        }

        static SyntaxTokenWithValue()
        {
            ObjectBinder.RegisterTypeReader(typeof(SyntaxTokenWithValue<T>), r => new SyntaxTokenWithValue<T>(r));
        }

        protected override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteString(this.TextField);
            writer.WriteValue(this.ValueField);
        }

        public override string Text
        {
            get
            {
                return this.TextField;
            }
        }

        public override object Value
        {
            get
            {
                return this.ValueField;
            }
        }

        public override string ValueText
        {
            get
            {
                return Convert.ToString(this.ValueField, CultureInfo.InvariantCulture);
            }
        }

        public override InternalSyntaxToken TokenWithLeadingTrivia(GreenNode trivia)
        {
            return new SyntaxTokenWithValueAndTrivia<T>(this.Kind, this.TextField, this.ValueField, trivia, null, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxToken TokenWithTrailingTrivia(GreenNode trivia)
        {
            return new SyntaxTokenWithValueAndTrivia<T>(this.Kind, this.TextField, this.ValueField, null, trivia, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
        {
            return new SyntaxTokenWithValue<T>(this.Kind, this.TextField, this.ValueField, diagnostics, this.GetAnnotations());
        }

        public override InternalSyntaxNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
        {
            return new SyntaxTokenWithValue<T>(this.Kind, this.TextField, this.ValueField, this.GetDiagnostics(), annotations);
        }
    }
^
    internal class SyntaxTokenWithValueAndTrivia<T> : SyntaxTokenWithValue<T>
    {
        static SyntaxTokenWithValueAndTrivia()
        {
            ObjectBinder.RegisterTypeReader(typeof(SyntaxTokenWithValueAndTrivia<T>), r => new SyntaxTokenWithValueAndTrivia<T>(r));
        }

        private readonly GreenNode _leading;
        private readonly GreenNode _trailing;

        internal SyntaxTokenWithValueAndTrivia([lang]SyntaxKind kind, string text, T value, GreenNode leading, GreenNode trailing)
            : base(kind, text, value)
        {
            if (leading != null)
            {
                this.AdjustFlagsAndWidth(leading);
                _leading = leading;
            }
            if (trailing != null)
            {
                this.AdjustFlagsAndWidth(trailing);
                _trailing = trailing;
            }
        }

        internal SyntaxTokenWithValueAndTrivia(
            [lang]SyntaxKind kind,
            string text,
            T value,
            GreenNode leading,
            GreenNode trailing,
            DiagnosticInfo["[]"] diagnostics,
            SyntaxAnnotation["[]"] annotations)
            : base(kind, text, value, diagnostics, annotations)
        {
            if (leading != null)
            {
                this.AdjustFlagsAndWidth(leading);
                _leading = leading;
            }
            if (trailing != null)
            {
                this.AdjustFlagsAndWidth(trailing);
                _trailing = trailing;
            }
        }

        internal SyntaxTokenWithValueAndTrivia(ObjectReader reader)
            : base(reader)
        {
            var leading = (GreenNode)reader.ReadValue();
            if (leading != null)
            {
                this.AdjustFlagsAndWidth(leading);
                _leading = leading;
            }
            var trailing = (GreenNode)reader.ReadValue();
            if (trailing != null)
            {
                this.AdjustFlagsAndWidth(trailing);
                _trailing = trailing;
            }
        }

        protected override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(_leading);
            writer.WriteValue(_trailing);
        }

        public override GreenNode GetLeadingTrivia()
        {
            return _leading;
        }

        public override GreenNode GetTrailingTrivia()
        {
            return _trailing;
        }

        public override InternalSyntaxToken TokenWithLeadingTrivia(GreenNode trivia)
        {
            return new SyntaxTokenWithValueAndTrivia<T>(this.Kind, this.TextField, this.ValueField, trivia, _trailing, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxToken TokenWithTrailingTrivia(GreenNode trivia)
        {
            return new SyntaxTokenWithValueAndTrivia<T>(this.Kind, this.TextField, this.ValueField, _leading, trivia, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
        {
            return new SyntaxTokenWithValueAndTrivia<T>(this.Kind, this.TextField, this.ValueField, _leading, _trailing, diagnostics, this.GetAnnotations());
        }

        public override InternalSyntaxNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
        {
            return new SyntaxTokenWithValueAndTrivia<T>(this.Kind, this.TextField, this.ValueField, _leading, _trailing, this.GetDiagnostics(), annotations);
        }
    }
^
    internal class SyntaxTokenWithTrivia : GreenSyntaxToken
    {
        static SyntaxTokenWithTrivia()
        {
            ObjectBinder.RegisterTypeReader(typeof(SyntaxTokenWithTrivia), r => new SyntaxTokenWithTrivia(r));
        }

        protected readonly GreenNode LeadingField;
        protected readonly GreenNode TrailingField;

        internal SyntaxTokenWithTrivia([lang]SyntaxKind kind, GreenNode leading, GreenNode trailing)
            : base(kind)
        {
            if (leading != null)
            {
                this.AdjustFlagsAndWidth(leading);
                this.LeadingField = leading;
            }
            if (trailing != null)
            {
                this.AdjustFlagsAndWidth(trailing);
                this.TrailingField = trailing;
            }
        }

        internal SyntaxTokenWithTrivia([lang]SyntaxKind kind, GreenNode leading, GreenNode trailing, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
            : base(kind, diagnostics, annotations)
        {
            if (leading != null)
            {
                this.AdjustFlagsAndWidth(leading);
                this.LeadingField = leading;
            }
            if (trailing != null)
            {
                this.AdjustFlagsAndWidth(trailing);
                this.TrailingField = trailing;
            }
        }

        internal SyntaxTokenWithTrivia(ObjectReader reader)
            : base(reader)
        {
            var leading = (GreenNode)reader.ReadValue();
            if (leading != null)
            {
                this.AdjustFlagsAndWidth(leading);
                this.LeadingField = leading;
            }
            var trailing = (GreenNode)reader.ReadValue();
            if (trailing != null)
            {
                this.AdjustFlagsAndWidth(trailing);
                this.TrailingField = trailing;
            }
        }

        protected override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.LeadingField);
            writer.WriteValue(this.TrailingField);
        }

        public override GreenNode GetLeadingTrivia()
        {
            return this.LeadingField;
        }

        public override GreenNode GetTrailingTrivia()
        {
            return this.TrailingField;
        }

        public override InternalSyntaxToken TokenWithLeadingTrivia(GreenNode trivia)
        {
            return new SyntaxTokenWithTrivia(this.Kind, trivia, this.TrailingField, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxToken TokenWithTrailingTrivia(GreenNode trivia)
        {
            return new SyntaxTokenWithTrivia(this.Kind, this.LeadingField, trivia, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
        {
            return new SyntaxTokenWithTrivia(this.Kind, this.LeadingField, this.TrailingField, diagnostics, this.GetAnnotations());
        }

        public override InternalSyntaxNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
        {
            return new SyntaxTokenWithTrivia(this.Kind, this.LeadingField, this.TrailingField, this.GetDiagnostics(), annotations);
        }
    }
}
end template


template GenerateDeclarationTreeBuilder()
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Declarations;
using [Properties.DefaultNamespace].Syntax;
^
namespace [Properties.DefaultNamespace].Binding
{
	public class [Properties.LanguageName]DeclarationTreeBuilderVisitor : DeclarationTreeBuilderVisitor, I[Properties.LanguageName]SyntaxVisitor
	{
        protected [Properties.LanguageName]DeclarationTreeBuilderVisitor([Properties.LanguageName]SyntaxTree syntaxTree, string scriptClassName, bool isSubmission)
            : base(syntaxTree, scriptClassName, isSubmission)
        {
        }
^
        public static RootSingleDeclaration ForTree(
            [Properties.LanguageName]SyntaxTree syntaxTree,
            string scriptClassName,
            bool isSubmission)
        {
            var builder = new [Properties.LanguageName]DeclarationTreeBuilderVisitor(syntaxTree, scriptClassName, isSubmission);
            return builder.CreateRoot(syntaxTree.GetRoot(), [Instances.MainRule().Annotations.GetSymbolType(MetaCompilerAnnotationInfo.Root)]);
        }
   		[loop(rule:Instances.ParserRules)]
			[if (rule.Alternatives.Count > 0)]
				[loop(alt:rule.Alternatives)]
		[GenerateDeclarationTreeBuilderVisit(alt)]
				[end loop]
			[else]
		[GenerateDeclarationTreeBuilderVisit(rule)]
			[end if]
		[end loop]
	}
}
end template


template GenerateDeclarationTreeBuilderVisit(Antlr4ParserRule rule)
^
public virtual void Visit[rule.PlainName()]([rule.RedName()] node)
{
	[GetDeclarationTreeBuilderVisitBody(rule)]
}
end template

template GenerateDeclarationTreeBuilderVisitBody(Antlr4ParserRule rule)
[if (rule.ContainsAnnotations && !rule.Annotations.IsDeclarationBoundary())]
[if (rule.IsSimpleAlt)]
	[loop(elem:rule.Elements where elem.ContainsAnnotations && !elem.Annotations.IsDeclarationBoundary())]
[GenerateDeclarationTreeBuilderVisitElement(rule, elem)]
	[end loop] 
[else]
	[loop(elem:rule.AllElements where elem.ContainsAnnotations && !elem.Annotations.IsDeclarationBoundary())]
[GenerateDeclarationTreeBuilderVisitElement(rule, elem)]
	[end loop]    
[end if]
[end if]
end template

template GenerateDeclarationTreeBuilderVisitElementBody(Antlr4ParserRuleElement elem)
	[if (elem.IsList)]
if (node.[elem.RedName()] != null)
{
	foreach (var child in node.[elem.RedName()])
	{
		this.Visit(child);
	}
}
	[else]
		[if (elem.IsToken || elem.IsFixedTokenAltBlock)]
		[else]
this.Visit(node.[elem.RedName()]);
		[end if]
	[end if]
end template

template GenerateDeclarationTreeBuilderDeclaration(MetaCompilerAnnotations annots, string name, string body)
this.BeginDeclaration([annots.GetSymbolType()], [name]);
try
{
	[if (annots.HasProperty("nestingProperty"))]
	this.RegisterNestingProperty([annots.GetNestingProperty()]);
	[end if]
	[if (annots.HasProperty("merge"))]
	this.RegisterCanMerge([annots.GetCanMerge()]);
	[end if]
	[body]
}
finally
{
	this.EndDeclaration();
}
end template

template GenerateDeclarationTreeBuilderQualifier(MetaCompilerAnnotations annots, string name, string body)
this.BeginQualifier();
try
{
	[body]
}
finally
{
	this.EndQualifier();
}
end template

template GenerateDeclarationTreeBuilderName(MetaCompilerAnnotations annots, string name, string body)
this.BeginName();
try
{
	[body]
}
finally
{
	this.EndName();
}
end template

template GenerateDeclarationTreeBuilderProperty(MetaCompilerAnnotations annots, string name, string body)
this.BeginProperty("[annots.GetPropertyWithNoValue().GetValue("name")]");
try
{
	[body]
}
finally
{
	this.EndProperty();
}
end template

template GenerateDeclarationTreeBuilderIdentifier(MetaCompilerAnnotations annots, string name, string body)
if ([name] != null) this.RegisterIdentifier([name]);
[body]
end template

function string GetDeclarationTreeBuilderVisitBody(Antlr4ParserRule rule)
	string body = GenerateDeclarationTreeBuilderVisitBody(rule);
	if (rule.Annotations.IsIdentifier())
		body = GenerateDeclarationTreeBuilderIdentifier(rule.Annotations, "node", body);
	end if
	if (rule.Annotations.IsQualifier())
		body = GenerateDeclarationTreeBuilderQualifier(rule.Annotations, "node", body);
	end if
	if (rule.Annotations.IsName())
		body = GenerateDeclarationTreeBuilderName(rule.Annotations, "node", body);
	end if
	if (rule.Annotations.IsDeclaration())
		body = GenerateDeclarationTreeBuilderDeclaration(rule.Annotations, "node", body);
	end if
	if (rule.Annotations.IsPropertyWithNoValue())
		body = GenerateDeclarationTreeBuilderProperty(rule.Annotations, "node", body);
	end if
	return body;
end function

function string GetDeclarationTreeBuilderVisitElement(Antlr4ParserRule rule, Antlr4ParserRuleElement elem)
	string body = GenerateDeclarationTreeBuilderVisitElementBody(elem);
	if (elem.Annotations.IsIdentifier())
		body = GenerateDeclarationTreeBuilderIdentifier(elem.Annotations, "node."+elem.RedName(), body);
	end if
	if (elem.Annotations.IsQualifier())
		body = GenerateDeclarationTreeBuilderQualifier(elem.Annotations, "node."+elem.RedName(), body);
	end if
	if (elem.Annotations.IsName())
		body = GenerateDeclarationTreeBuilderName(elem.Annotations, "node."+elem.RedName(), body);
	end if
	if (elem.Annotations.IsPropertyWithNoValue())
		body = GenerateDeclarationTreeBuilderProperty(elem.Annotations, "node."+elem.RedName(), body);
	end if
	return body;
end function

template GenerateDeclarationTreeBuilderVisitElement(Antlr4ParserRule rule, Antlr4ParserRuleElement elem)
	[if (elem.IsToken || elem.IsFixedTokenAltBlock)]
switch (node.[elem.RedName()].GetKind().Switch())
{
	[loop (alt:elem.BlockItems)]
	case [Properties.LanguageName]SyntaxKind.[alt.RedName()]:
		[GetDeclarationTreeBuilderVisitElement(rule, alt)]
		break;
	[end loop]
	default:
		break;
}
	[else]
[GetDeclarationTreeBuilderVisitElement(rule, elem)]
	[end if]
end template

template GenerateBinderFactoryVisitor()
using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Binding;
using MetaDslx.CodeAnalysis.Syntax;
using [Properties.DefaultNamespace].Syntax;
using [Properties.DefaultNamespace].Symbols;
^
namespace [Properties.DefaultNamespace].Binding
{
    public class [Properties.LanguageName]BinderFactoryVisitor : BinderFactoryVisitor, I[Properties.LanguageName]SyntaxVisitor<Binder>
    {
		[loop (use:Instances.ParserRuleElemUses)]
		public static object Use[use] = new object();
		[end loop]
^
        public [Properties.LanguageName]BinderFactoryVisitor(BinderFactory symbolBuilder)
			: base(symbolBuilder)
        {
^
        }
		[loop(annot:Instances.CustomAnnotations)]
^
        protected virtual Binder Create[annot.Name]Binder(Binder parentBinder, LanguageSyntaxNode syntax)
        {
            return this.Create[annot.Name]BinderCore(parentBinder, syntax);
        }
^
        protected virtual Binder Create[annot.Name]BinderCore(Binder parentBinder, LanguageSyntaxNode syntax)
        {
            return new [annot.Name]Binder(parentBinder, syntax);
        }
		[end loop]
^
        /// <summary>
        /// Returns binder that binds usings and aliases 
        /// </summary>
        /// <param name="unit">
        /// Specify <see cref="LanguageSyntaxNode"/> imports in the corresponding syntax node, or
        /// <see cref="CompilationUnitSyntax"/> for top-level imports.
        /// </param>
        /// <param name="inUsing">True if the binder will be used to bind a using directive.</param>
        public override Binder GetImportsBinder(LanguageSyntaxNode unit, bool inUsing)
        {
            if (unit.Kind == [Properties.LanguageName]SyntaxKind.[Instances.MainRule().PlainName()])
            {
                return this.GetCompilationUnitBinder(unit, inUsing: inUsing, inScript: InScript);
            }
            else
            {
                // TODO:MetaDslx - non-compilation-unit imports
                return null;
            }
        }
^		
		[loop(rule:Instances.ParserRules)]
			[if (rule.Alternatives.Count > 0)]
				[loop(alt:rule.Alternatives)]
		[GenerateBinderFactoryVisit(alt)]
				[end loop]
			[else]
		[GenerateBinderFactoryVisit(rule)]
			[end if]
		[end loop]
    }
}
end template


template GenerateBinderFactoryVisit(Antlr4ParserRule rule)
^
public Binder Visit[rule.PlainName()]([rule.RedName()] parent)
{
    [if (rule == Instances.MainRule())]
	return this.GetCompilationUnitBinder(parent, inUsing: IsInUsing(parent), inScript: InScript);
	[else]
    if (!parent.FullSpan.Contains(this.Position))
    {
        return VisitCore(parent.Parent);
    }
	object use = null;
	[GenerateBinderFactoryVisitElemUses(rule)]
	Binder resultBinder = null;
	if (!this.BinderFactory.TryGetBinder(parent, use, out resultBinder))
	{
		resultBinder = VisitCore(parent.Parent);
		[loop (annot:rule.Annotations.BinderAnnotations)]
		resultBinder = this.Create[annot.Name]Binder(resultBinder, parent[annot.GetAnnotationParams()]);
		[end loop]
		this.BinderFactory.TryAddBinder(parent, null, ref resultBinder);
		[GenerateBinderFactoryVisitBody(rule)]
	}
	return resultBinder;
	[end if]
}
end template


template GenerateBinderFactoryVisitBody(Antlr4ParserRule rule)
[if (rule.ContainsBinderAnnotations && hasloop(elem:rule.Elements where elem.HasBinderAnnotations))]
[if (rule.IsSimpleAlt)]
	[loop(elem:rule.Elements where elem.ContainsBinderAnnotations)]
[GenerateBinderFactoryVisitElement(rule, elem)]
	[end loop] 
[else]
	[loop(elem:rule.AllElements where elem.ContainsBinderAnnotations)]
[GenerateBinderFactoryVisitElement(rule, elem)]
	[end loop]    
[end if]
[end if]
end template

template GenerateBinderFactoryVisitElementBody(Antlr4ParserRule rule, Antlr4ParserRuleElement elem)
	[if (elem.HasBinderAnnotations)]
if (use == Use[elem.RedName()])
{
    [loop (annot:elem.Annotations.BinderAnnotations)]
		[if (elem.IsList)]
	resultBinder = this.Create[annot.Name]Binder(resultBinder, parent.[elem.RedName()].Node[annot.GetAnnotationParams()]);
		[else]
	resultBinder = this.Create[annot.Name]Binder(resultBinder, parent.[elem.RedName()][annot.GetAnnotationParams()]);
		[end if]
	[end loop]
	this.BinderFactory.TryAddBinder(parent, use, ref resultBinder);
}
	[end if]
end template

template GenerateBinderFactoryVisitTokenAltBody(Antlr4ParserRule rule, Antlr4ParserRuleElement elem)
	[if (elem.HasBinderAnnotations)]
if (use == Use[elem.RedName()])
{
	switch (parent.[elem.RedName()].GetKind().Switch())
	{
			[loop (alt:elem.BlockItems)]
		case [Properties.LanguageName]SyntaxKind.[alt.RedName()]:
				[loop (annot:alt.Annotations.BinderAnnotations)]
			resultBinder = this.Create[annot.Name]Binder(resultBinder, parent.[elem.RedName()][annot.GetAnnotationParams()]);
				[end loop]
			break;
			[end loop]
		default:
			break;
	}
	this.BinderFactory.TryAddBinder(parent, use, ref resultBinder);
}
	[end if]
end template

template GenerateBinderFactoryVisitElemUses(Antlr4ParserRule rule)
[if (rule.ContainsBinderAnnotations && hasloop(elem:rule.Elements where elem.HasBinderAnnotations))]
[if (rule.IsSimpleAlt)]
	[loop(elem:rule.Elements where elem.HasBinderAnnotations)]
		[if (elem.IsList)]
if (LookupPosition.IsInNode(this.Position, parent.[elem.RedName()].Node)) use = Use[elem.RedName()];
		[else]
if (LookupPosition.IsInNode(this.Position, parent.[elem.RedName()])) use = Use[elem.RedName()];
		[end if]
	[end loop] 
[else]
	[loop(elem:rule.AllElements where elem.HasBinderAnnotations)]
		[if (elem.IsList)]
if (LookupPosition.IsInNode(this.Position, parent.[elem.RedName()].Node)) use = Use[elem.RedName()];
		[else]
if (LookupPosition.IsInNode(this.Position, parent.[elem.RedName()])) use = Use[elem.RedName()];
		[end if]
	[end loop]    
[end if]
[end if]
end template

template GenerateBinderFactoryVisitElement(Antlr4ParserRule rule, Antlr4ParserRuleElement elem)
	[if (elem.IsFixedTokenAltBlock)]
[GenerateBinderFactoryVisitTokenAltBody(rule, elem)]
	[else]
[GenerateBinderFactoryVisitElementBody(rule, elem)]
	[end if]
end template

template GenerateBoundKind()
using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MetaDslx.CodeAnalysis.Binding;
using Roslyn.Utilities;
^
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace].Binding
{
    public class [lang]BoundKind : BoundKind
    {
		[loop(annot:Instances.CustomAnnotations)]
        public const string [annot.Name] = nameof([annot.Name]);
		[end loop]
^
        protected [lang]BoundKind(string name)
            : base(name)
        {
        }
^
        protected [lang]BoundKind(EnumObject retargetedValue)
            : base(retargetedValue)
        {
        }
^
        static [lang]BoundKind()
        {
            EnumObject.AutoInit<[lang]BoundKind>();
        }
^
        public static implicit operator [lang]BoundKind(string name)
        {
            return FromString<[lang]BoundKind>(name);
        }
^
        public static explicit operator [lang]BoundKind(int value)
        {
            return FromIntUnsafe<[lang]BoundKind>(value);
        }
    }
}
end template

template GenerateBoundNodeFactoryVisitor()
using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.PooledObjects;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Binding;
using MetaDslx.CodeAnalysis.Syntax;
using Roslyn.Utilities;
using [Properties.DefaultNamespace].Syntax;
using [Properties.DefaultNamespace].Symbols;
^
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace].Binding
{
	// Make sure to keep this in sync with [lang]IsBindableNodeVisitor
    public class [lang]BoundNodeFactoryVisitor : BoundNodeFactoryVisitor, I[lang]SyntaxVisitor<ArrayBuilder<BoundNode>, BoundNode>
    {
        public [lang]BoundNodeFactoryVisitor(BoundTree boundTree)
			: base(boundTree)
        {
^
        }
		[loop(annot:Instances.CustomAnnotations)]
^
        protected virtual BoundNode CreateBound[annot.Name](BoundTree boundTree, ImmutableArray<BoundNode> childBoundNodes, LanguageSyntaxNode syntax, bool hasErrors)
        {
            return this.CreateBound[annot.Name]Core(boundTree, childBoundNodes, syntax, hasErrors);
        }
^
        protected virtual BoundNode CreateBound[annot.Name]Core(BoundTree boundTree, ImmutableArray<BoundNode> childBoundNodes, LanguageSyntaxNode syntax, bool hasErrors)
        {
            return new Bound[annot.Name]([lang]BoundKind.[annot.Name], boundTree, childBoundNodes, syntax, hasErrors);
        }
		[end loop]
^		
		[loop(rule:Instances.ParserRules)]
			[if (rule.Alternatives.Count > 0)]
				[loop(alt:rule.Alternatives)]
		[GenerateBoundNodeFactoryVisit(alt)]
				[end loop]
			[else]
		[GenerateBoundNodeFactoryVisit(rule)]
			[end if]
		[end loop]
    }
}
end template


template GenerateBoundNodeFactoryVisit(Antlr4ParserRule rule)
^
public BoundNode Visit[rule.PlainName()]([rule.RedName()] node, ArrayBuilder<BoundNode> childBoundNodesForParent)
{
	[if (rule.ContainsBoundNodeAnnotations)]
	if (this.BoundTree.TryGetBoundNode(node, out BoundNode cachedBoundNode))
	{
		childBoundNodesForParent.Add(cachedBoundNode);
		return cachedBoundNode;
	}
		[if (rule.HasBoundNodeAnnotations)]
	var childBoundNodes = ArrayBuilder<BoundNode>.GetInstance();
	[GenerateBoundNodeFactoryVisitChildren(rule)]
	BoundNode resultNode;
			[string children = "childBoundNodes.ToImmutableAndFree()"]
			[loop (annot:rule.Annotations.BoundNodeAnnotations.Reverse())]
	resultNode = this.CreateBound[annot.Name](this.BoundTree, [children][annot.GetAnnotationParams()], node, false);
			[children = "ImmutableArray.Create(resultNode)"]
			[end loop]
	childBoundNodesForParent.Add(resultNode);
	return resultNode;
		[else]
	[GenerateBoundNodeFactoryVisitChildren(rule)]
	return null;
		[end if]
	[else]
	[GenerateBoundNodeFactoryVisitChildren(rule)]
	return null;
	[end if]
}
end template

template GenerateBoundNodeFactoryVisitChildren(Antlr4ParserRule rule)
[string childBoundNodesName = rule.HasBoundNodeAnnotations ? "childBoundNodes" : "childBoundNodesForParent"]
[if (rule.IsSimpleAlt)]
	[loop(elem:rule.Elements)]
[GenerateBoundNodeFactoryVisitChildrenElementWithNullCheck(elem, childBoundNodesName)]
	[end loop] 
[else]
	[loop(elem:rule.AllElements)]
[GenerateBoundNodeFactoryVisitChildrenElementWithNullCheck(elem, childBoundNodesName)]
	[end loop]    
[end if]
end template

template GenerateBoundNodeFactoryVisitChildrenElementWithNullCheck(Antlr4ParserRuleElement elem, string childBoundNodesName)
[if (elem.ContainsBoundNodeAnnotations && !elem.IsToken  && !elem.IsFixedTokenAltBlock)]
if (node.[elem.RedName()] != null)
{
	[GenerateBoundNodeFactoryVisitChildrenElementWithBoundChildren(elem, childBoundNodesName)]
}
[else]
[GenerateBoundNodeFactoryVisitChildrenElementWithBoundChildren(elem, childBoundNodesName)]
[end if]
end template

template GenerateBoundNodeFactoryVisitChildrenElementWithBoundChildren(Antlr4ParserRuleElement elem, string childBoundNodesName)
[if (elem.HasBoundNodeAnnotations && !elem.IsToken)]
var childBoundNodesOf[elem.RedName()] = ArrayBuilder<BoundNode>.GetInstance();
[GenerateBoundNodeFactoryVisitChildrenElement(elem, "childBoundNodesOf"+elem.RedName())]
BoundNode bound[elem.RedName()];
	[string children = "childBoundNodesOf"+elem.RedName()+".ToImmutableAndFree()"]
	[loop (annot:elem.Annotations.BoundNodeAnnotations.Reverse())]
bound[elem.RedName()] = this.CreateBound[annot.Name](this.BoundTree, [children][annot.GetAnnotationParams()], node.[elem.RedName()], false);
	[children = "ImmutableArray.Create(bound"+elem.RedName()+")"]
	[end loop]
[childBoundNodesName].Add(bound[elem.RedName()]);
[else]
[GenerateBoundNodeFactoryVisitChildrenElement(elem, childBoundNodesName)]
[end if]
end template

template GenerateBoundNodeFactoryVisitChildrenElement(Antlr4ParserRuleElement elem, string childBoundNodesName)
	[if (elem.IsList)]
foreach (var item in node.[elem.RedName()])
{
	this.Visit(item, [childBoundNodesName]);
}
	[else if (elem.IsFixedTokenAltBlock)]
[GenerateBoundNodeFactoryVisitTokenAltBody(elem, childBoundNodesName)]
	[else if (elem.IsToken)]
[GenerateBoundNodeFactoryVisitTokenBody(elem, childBoundNodesName)]
	[else]
this.Visit(node.[elem.RedName()], [childBoundNodesName]);
	[end if]
end template

template GenerateBoundNodeFactoryVisitTokenAltBody(Antlr4ParserRuleElement elem, string childBoundNodesName)
[if (elem.ContainsBoundNodeAnnotations)]
switch (node.[elem.RedName()].GetKind().Switch())
{
		[loop (alt:elem.BlockItems where alt.HasBoundNodeAnnotations)]
	case [Properties.LanguageName]SyntaxKind.[alt.RedName()]:
		BoundNode bound[alt.RedName()];
			[string children = "ImmutableArray<BoundNode>.Empty"]
			[loop (annot:alt.Annotations.BoundNodeAnnotations.Reverse())]
		bound[alt.RedName()] = this.CreateBound[annot.Name](this.BoundTree, [children][annot.GetAnnotationParams()], node, false);
			[children = "ImmutableArray.Create(bound"+alt.RedName()+")"]
			[end loop]
		[childBoundNodesName].Add(bound[alt.RedName()]);
		break;
		[end loop]
	default:
		break;
}
[end if]
end template

template GenerateBoundNodeFactoryVisitTokenBody(Antlr4ParserRuleElement elem, string childBoundNodesName)
[if (elem.HasBoundNodeAnnotations)]
if (node.[elem.RedName()].GetKind() == [Properties.LanguageName]SyntaxKind.[elem.Type])
{
	BoundNode bound[elem.RedName()];
	[string children = "ImmutableArray<BoundNode>.Empty"]
	[loop (annot:elem.Annotations.BoundNodeAnnotations.Reverse())]
	bound[elem.RedName()] = this.CreateBound[annot.Name](this.BoundTree, [children][annot.GetAnnotationParams()], node, false);
	[children = "ImmutableArray.Create(bound"+elem.RedName()+")"]
	[end loop]
	[childBoundNodesName].Add(bound[elem.RedName()]);
}
[end if]
end template


template GenerateIsBindableNodeVisitor()
using System;
using System.Diagnostics;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Binding;
using MetaDslx.CodeAnalysis.Syntax;
using Roslyn.Utilities;
using [Properties.DefaultNamespace].Syntax;
using [Properties.DefaultNamespace].Symbols;
^
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace].Binding
{
	// Make sure to keep this in sync with [lang]BoundNodeFactoryVisitor
    public class [lang]IsBindableNodeVisitor : IsBindableNodeVisitor, I[lang]SyntaxVisitor<bool>
    {
        public [lang]IsBindableNodeVisitor(BoundTree boundTree)
			: base(boundTree)
        {
^
        }
^		
		[loop(rule:Instances.ParserRules)]
			[if (rule.Alternatives.Count > 0)]
				[loop(alt:rule.Alternatives)]
		[GenerateIsBindableNodeVisit(alt)]
				[end loop]
			[else]
		[GenerateIsBindableNodeVisit(rule)]
			[end if]
		[end loop]
    }
}
end template


template GenerateIsBindableNodeVisit(Antlr4ParserRule rule)
^
public bool Visit[rule.PlainName()]([rule.RedName()] node)
{
	[if (rule.HasBoundNodeAnnotations)]
	return true;
	[else if (rule.IsSimpleAlt)]
		[if (hasloop(elem:rule.Elements where elem.HasBoundNodeAnnotations))]
	return true;
		[else]
	return false;
		[end loop] 
	[else]
		[if (hasloop(elem:rule.AllElements where elem.HasBoundNodeAnnotations))]
	return true;
		[else]
	return false;
		[end loop] 
	[end if]
}
end template


template GenerateSymbolBuilder()
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Threading;
using MetaDslx.Core;
using MetaDslx.Compiler;
using MetaDslx.Compiler.Binding;
using [Properties.DefaultNamespace].Symbols;
^
namespace [Properties.DefaultNamespace].Binding
{
    public class [Properties.LanguageName]SymbolBuilder : SymbolBuilder
    {
        public [Properties.LanguageName]SymbolBuilder(CompilationBase compilation) : base(compilation)
        {
        }
^
        private [Properties.LanguageName]Factory _factory;
^
        private [Properties.LanguageName]Factory Factory
        {
            get
            {
                if (_factory == null)
                {
                    Interlocked.CompareExchange(ref _factory, new [Properties.LanguageName]Factory(this.ModelBuilder), null);
                }
                return _factory;
            }
        }
^
        protected override MutableSymbol CreateSymbolCore(Type symbolType)
        {
            return this.Factory.Create(symbolType);
        }
    }
}
end template

template GenerateSymbolFacts()
using MetaDslx.CodeAnalysis.Symbols;
using [Properties.DefaultNamespace].Syntax.InternalSyntax;
using System;
using System.Collections.Generic;
using System.Text;
^
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace].Symbols
{
    public class [lang]SymbolFacts : SymbolFacts
    {
    }
}
end template


