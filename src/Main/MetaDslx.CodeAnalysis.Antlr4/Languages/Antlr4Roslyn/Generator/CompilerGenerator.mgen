namespace MetaDslx.Languages.Antlr4Roslyn.Generator;
generator CompilerGenerator for Antlr4Grammar;

using MetaDslx.Languages.Meta;
using MetaDslx.Languages.Antlr4Roslyn.Compilation;
using Roslyn.Utilities;

properties Properties
	string DefaultNamespace;
	string LanguageName;
end properties

template GenerateLanguage()
using System;
using System.Diagnostics;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Symbols;
using MetaDslx.CodeAnalysis.Syntax;
using MetaDslx.CodeAnalysis.Syntax.InternalSyntax;
using [Properties.DefaultNamespace];
using [Properties.DefaultNamespace].Symbols;
using [Properties.DefaultNamespace].Syntax;
using [Properties.DefaultNamespace].Syntax.InternalSyntax;
using Roslyn.Utilities;
[Instances.ParserHeader]
^
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace]
{
    public sealed class [lang]Language : Language
    {
        public static readonly [lang]Language Instance = new [lang]Language();
^
		private [lang]Language()
		{
            EnumObject.Init(typeof([lang]LanguageVersion));
            EnumObject.Init(typeof([lang]TokensSyntaxKind));
            EnumObject.Init(typeof([lang]SyntaxKind));
		}
^
        public override string Name => "[lang]";
^
        public new [lang]SyntaxFacts SyntaxFacts => ([lang]SyntaxFacts)base.SyntaxFacts;
        public new [lang]SymbolFacts SymbolFacts => ([lang]SymbolFacts)base.SymbolFacts;
        internal new [lang]InternalSyntaxFactory InternalSyntaxFactory => ([lang]InternalSyntaxFactory)base.InternalSyntaxFactory;
        public new [lang]SyntaxFactory SyntaxFactory => ([lang]SyntaxFactory)base.SyntaxFactory;
        public new [lang]CompilationFactory CompilationFactory => ([lang]CompilationFactory)base.CompilationFactory;

        protected override LanguageServices CreateLanguageServices()
        {
            return new [lang]LanguageServices();
        }
    }
}
end template

template GenerateLanguageServicesBase()
using System;
using System.Diagnostics;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Symbols;
using MetaDslx.CodeAnalysis.Syntax;
using MetaDslx.CodeAnalysis.Syntax.InternalSyntax;
using [Properties.DefaultNamespace];
using [Properties.DefaultNamespace].Symbols;
using [Properties.DefaultNamespace].Syntax;
using [Properties.DefaultNamespace].Syntax.InternalSyntax;
using Microsoft.Extensions.DependencyInjection;
^
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace]
{
    public class [lang]LanguageServicesBase : LanguageServices
    {
        public override SyntaxFacts CreateSyntaxFacts()
        {
            return new [lang]SyntaxFacts();
        }

        public override SymbolFacts CreateSymbolFacts()
        {
            return new [lang]SymbolFacts();
        }

        public override InternalSyntaxFactory CreateInternalSyntaxFactory(SyntaxFacts syntaxFacts)
        {
            return new [lang]InternalSyntaxFactory(([lang]SyntaxFacts)syntaxFacts);
        }

        public override SyntaxFactory CreateSyntaxFactory(InternalSyntaxFactory internalSyntaxFactory)
        {
            return new [lang]SyntaxFactory(([lang]InternalSyntaxFactory)internalSyntaxFactory);
        }

        public override CompilationFactory CreateCompilationFactory()
        {
            return new [lang]CompilationFactory();
        }

        public override void RegisterServices(ServiceCollection services)
        {
        }
    }
}
end template

template GenerateLanguageServices()
using System;
using System.Diagnostics;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Symbols;
using MetaDslx.CodeAnalysis.Syntax;
using MetaDslx.CodeAnalysis.Syntax.InternalSyntax;
using [Properties.DefaultNamespace];
using [Properties.DefaultNamespace].Symbols;
using [Properties.DefaultNamespace].Syntax;
using [Properties.DefaultNamespace].Syntax.InternalSyntax;
[Instances.ParserHeader]
^
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace]
{
    public class [lang]LanguageServices : [lang]LanguageServicesBase
    {
    }
}
end template

template GenerateParseOptions()
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Syntax;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.PooledObjects;
using Roslyn.Utilities;
[Instances.ParserHeader]
^
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace].Syntax
{
    /// <summary>
    /// This class stores several source parsing related options and offers access to their values.
    /// </summary>
    public sealed class [lang]ParseOptions : LanguageParseOptions, IEquatable<[lang]ParseOptions>
    {
        /// <summary>
        /// The default parse options.
        /// </summary>
        public static [lang]ParseOptions Default { get; } = new [lang]ParseOptions();

        public [lang]ParseOptions(
            [lang]LanguageVersion languageVersion = null,
            DocumentationMode documentationMode = DocumentationMode.Parse,
            SourceCodeKind kind = SourceCodeKind.Regular,
            bool incremental = false,
            IEnumerable<string> preprocessorSymbols = null)
            : this(languageVersion ?? [lang]LanguageVersion.[lang]1,
                  documentationMode,
                  kind,
                  incremental,
                  preprocessorSymbols.ToImmutableArrayOrEmpty(),
                  ImmutableDictionary<string, string>.Empty)
        {
        }

        internal [lang]ParseOptions(
            [lang]LanguageVersion languageVersion,
            DocumentationMode documentationMode,
            SourceCodeKind kind,
            bool incremental,
            ImmutableArray<string> preprocessorSymbols,
            IReadOnlyDictionary<string, string> features)
            : base(languageVersion, documentationMode, kind, incremental, preprocessorSymbols, features)
        {
        }

        private [lang]ParseOptions([lang]ParseOptions other) : this(
            languageVersion: ([lang]LanguageVersion)other.LanguageVersion,
            documentationMode: other.DocumentationMode,
            kind: other.Kind,
            incremental: other.Incremental,
            preprocessorSymbols: other.PreprocessorSymbols,
            features: other.Features)
        {
        }

        public override Language Language => [lang]Language.Instance;

        public new [lang]ParseOptions WithKind(SourceCodeKind kind)
        {
            if (kind == this.SpecifiedKind)
            {
                return this;
            }

            var effectiveKind = MapSpecifiedToEffectiveKind(kind);
            return new [lang]ParseOptions(this) { SpecifiedKind = kind, Kind = effectiveKind };
        }

        public new [lang]ParseOptions WithIncremental(bool incremental)
        {
            if (incremental == this.Incremental)
            {
                return this;
            }

            return new [lang]ParseOptions(this) { Incremental = incremental };
        }

        public [lang]ParseOptions WithLanguageVersion([lang]LanguageVersion version)
        {
            if (version == this.SpecifiedLanguageVersion)
            {
                return this;
            }

            var effectiveLanguageVersion = ([lang]LanguageVersion)version.MapSpecifiedToEffectiveVersion();
            return new [lang]ParseOptions(this) { SpecifiedLanguageVersion = version, LanguageVersion = effectiveLanguageVersion };
        }

        public [lang]ParseOptions WithPreprocessorSymbols(IEnumerable<string> preprocessorSymbols)
        {
            return WithPreprocessorSymbols(preprocessorSymbols.AsImmutableOrNull());
        }

        public [lang]ParseOptions WithPreprocessorSymbols(params string["[]"] preprocessorSymbols)
        {
            return WithPreprocessorSymbols(ImmutableArray.Create(preprocessorSymbols));
        }

        public [lang]ParseOptions WithPreprocessorSymbols(ImmutableArray<string> symbols)
        {
            if (symbols.IsDefault)
            {
                symbols = ImmutableArray<string>.Empty;
            }

            if (symbols.Equals(this.PreprocessorSymbols))
            {
                return this;
            }

            return new [lang]ParseOptions(this) { PreprocessorSymbols = symbols };
        }

        public new [lang]ParseOptions WithDocumentationMode(DocumentationMode documentationMode)
        {
            if (documentationMode == this.DocumentationMode)
            {
                return this;
            }

            return new [lang]ParseOptions(this) { DocumentationMode = documentationMode };
        }

        public override ParseOptions CommonWithKind(SourceCodeKind kind)
        {
            return WithKind(kind);
        }

        protected override ParseOptions CommonWithDocumentationMode(DocumentationMode documentationMode)
        {
            return WithDocumentationMode(documentationMode);
        }

        protected override ParseOptions CommonWithFeatures(IEnumerable<KeyValuePair<string, string>> features)
        {
            return WithFeatures(features);
        }

        protected override LanguageParseOptions CommonWithIncremental(bool incremental)
        {
            return WithIncremental(incremental);
        }

        /// <summary>
        /// Enable some experimental language features for testing.
        /// </summary>
        public new [lang]ParseOptions WithFeatures(IEnumerable<KeyValuePair<string, string>> features)
        {
            ImmutableDictionary<string, string> dictionary =
                features?.ToImmutableDictionary(StringComparer.OrdinalIgnoreCase)
                ?? ImmutableDictionary<string, string>.Empty;

            return new [lang]ParseOptions(this) { Features = dictionary };
        }

        public override bool Equals(object obj)
        {
            return this.Equals(obj as [lang]ParseOptions);
        }

        public bool Equals([lang]ParseOptions other)
        {
            if (object.ReferenceEquals(this, other))
            {
                return true;
            }

            if (!base.EqualsHelper(other))
            {
                return false;
            }

            return this.LanguageVersion == other.LanguageVersion;
        }

        public override int GetHashCode()
        {
            return
                Hash.Combine(base.GetHashCodeHelper(),
                Hash.Combine((int)this.LanguageVersion, 0));
        }
    }
}
end template

template GenerateFeature()
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
^
namespace [Properties.DefaultNamespace]
{
    public enum [Properties.LanguageName]Feature
    {
        None
    }
^
    public static partial class [Properties.LanguageName]FeatureExtensions
    {
        internal static string RequiredFeature(this [Properties.LanguageName]Feature feature)
        {
            switch (feature)
            {
                default:
                    return null;
            }
        }
^
        internal static LanguageVersion RequiredVersion(this [Properties.LanguageName]Feature feature)
        {
            switch (feature)
            {
                case [Properties.LanguageName]Feature.None:
                    return LanguageVersion.[Properties.LanguageName]1;

                default:
                    throw new ArgumentOutOfRangeException(nameof(feature), "Unexpected value: "+feature);
            }
        }
    }
^
}
end template

template GenerateLanguageVersion()
using System;
using Microsoft.CodeAnalysis;
using MetaDslx.CodeAnalysis;
using Roslyn.Utilities;
^
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace]
{
    /// <summary>
    /// Specifies the language version.
    /// </summary>
    public class [lang]LanguageVersion : LanguageVersion
    {
        /// <summary>
        /// [lang] language version 1
        /// </summary>
        public const string [lang]1 = nameof([lang]1);

        protected [lang]LanguageVersion(string name)
            : base(name)
        {
        }

        protected [lang]LanguageVersion(EnumObject retargetedValue)
            : base(retargetedValue)
        {
        }

        static [lang]LanguageVersion()
        {
            EnumObject.AutoInit<[lang]LanguageVersion>();
        }

        public static implicit operator [lang]LanguageVersion(string name)
        {
            return FromString<[lang]LanguageVersion>(name);
        }

        public static explicit operator [lang]LanguageVersion(int value)
        {
            return FromIntUnsafe<[lang]LanguageVersion>(value);
        }

        public override bool IsValid()
        {
            if (this == [lang]1) return true;
            return false;
        }

        /// <summary>
        /// Map a language version (such as Default, Latest, or CSharpN) to a specific version (CSharpM).
        /// </summary>
        public override LanguageVersion MapSpecifiedToEffectiveVersion()
        {
            if (this == Latest || this == Default || this == LatestMajor || this == Preview)
            {
                return [lang]1;
            }
            return this;
        }

        public override ErrorCode GetErrorCode()
        {
            switch (this.Switch())
            {
                case [lang]1:
                    return [lang]ErrorCode.ERR_FeatureNotAvailableInVersion1;
                default:
                    throw ExceptionUtilities.UnexpectedValue(this);
            }
        }
    }

    public static class LanguageVersionFacts
    {
        /// <summary>
        /// Displays the version number in the format expected on the command-line (/langver flag).
        /// For instance, "6", "7", "7.1", "latest".
        /// </summary>
        public static string ToDisplayString(this LanguageVersion version)
        {
            if (version == [lang]LanguageVersion.[lang]1) return "1";
            if (version == [lang]LanguageVersion.Default) return "default";
            if (version == [lang]LanguageVersion.Latest) return "latest";
            if (version == [lang]LanguageVersion.LatestMajor) return "latestmajor";
            if (version == [lang]LanguageVersion.Preview) return "preview";
            throw ExceptionUtilities.UnexpectedValue(version);
        }

        /// <summary>
        /// Try parse a <see cref="LanguageVersion"/> from a string input, returning default if input was null.
        /// </summary>
        public static bool TryParse(string version, out LanguageVersion result)
        {
            if (version == null)
            {
                result = LanguageVersion.Default;
                return true;
            }

            switch (CaseInsensitiveComparison.ToLower(version))
            {
                case "default":
                    result = LanguageVersion.Default;
                    return true;

                case "latest":
                    result = LanguageVersion.Latest;
                    return true;

                case "latestmajor":
                    result = LanguageVersion.LatestMajor;
                    return true;

                case "preview":
                    result = LanguageVersion.Preview;
                    return true;

                case "1":
                case "1.0":
                    result = [lang]LanguageVersion.[lang]1;
                    return true;
                default:
                    result = LanguageVersion.Default;
                    return false;
            }
        }
        
        public static LanguageVersion CurrentVersion => [lang]LanguageVersion.[lang]1;

    }
}
end template

template GenerateCompilation()
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Declarations;
^
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace]
{
    public class [lang]Compilation : LanguageCompilation
    {
        #region Constructors and Factories
        
        private static readonly [lang]CompilationOptions s_defaultOptions = new [lang]CompilationOptions(OutputKind.ConsoleApplication);
        private static readonly [lang]CompilationOptions s_defaultSubmissionOptions = new [lang]CompilationOptions(OutputKind.DynamicallyLinkedLibrary).WithReferencesSupersedeLowerVersions(true);

        /// <summary>
        /// Creates a new compilation from scratch. Methods such as AddSyntaxTrees or AddReferences
        /// on the returned object will allow to continue building up the Compilation incrementally.
        /// </summary>
        /// <param name="assemblyName">Simple assembly name.</param>
        /// <param name="syntaxTrees">The syntax trees with the source code for the new compilation.</param>
        /// <param name="references">The references for the new compilation.</param>
        /// <param name="options">The compiler options to use.</param>
        /// <returns>A new compilation.</returns>
        public static [lang]Compilation Create(
            string? assemblyName,
            IEnumerable<SyntaxTree>? syntaxTrees = null,
            IEnumerable<MetadataReference>? references = null,
            [lang]CompilationOptions? options = null)
        {
            return Create(
                assemblyName,
                options ?? s_defaultOptions,
                syntaxTrees,
                references,
                previousSubmission: null,
                returnType: null,
                hostObjectType: null,
                isSubmission: false);
        }

        /// <summary>
        /// Creates a new compilation that can be used in scripting.
        /// </summary>
        public static [lang]Compilation CreateScriptCompilation(
            string assemblyName,
            SyntaxTree? syntaxTree = null,
            IEnumerable<MetadataReference>? references = null,
            [lang]CompilationOptions? options = null,
            [lang]Compilation? previousScriptCompilation = null,
            Type? returnType = null,
            Type? globalsType = null)
        {
            CheckSubmissionOptions(options);
            ValidateScriptCompilationParameters(previousScriptCompilation, returnType, ref globalsType);

            return Create(
                assemblyName,
                options?.WithReferencesSupersedeLowerVersions(true) ?? s_defaultSubmissionOptions,
                (syntaxTree != null) ? new["[]"] { syntaxTree } : null,
                references,
                previousScriptCompilation,
                returnType,
                globalsType,
                isSubmission: true);
        }

        private static [lang]Compilation Create(
            string? assemblyName,
            [lang]CompilationOptions options,
            IEnumerable<SyntaxTree>? syntaxTrees,
            IEnumerable<MetadataReference>? references,
            [lang]Compilation? previousSubmission,
            Type? returnType,
            Type? hostObjectType,
            bool isSubmission)
        {
            var compilation = new [lang]Compilation(
                assemblyName,
                options,
                references,
                previousSubmission,
                returnType,
                hostObjectType,
                isSubmission,
                referenceManager: null,
                reuseReferenceManager: false,
                syntaxAndDeclarations: new SyntaxAndDeclarationManager(
                    options.Language,
                    ImmutableArray<SyntaxTree>.Empty,
                    options.ScriptClassName,
                    options.SourceReferenceResolver,
                    isSubmission,
                    state: null),
                semanticModelProvider: null);

            if (syntaxTrees != null)
            {
                compilation = compilation.AddSyntaxTrees(syntaxTrees);
            }
            return compilation;
        }

        protected [lang]Compilation(string assemblyName, [lang]CompilationOptions options, IEnumerable<MetadataReference> references, [lang]Compilation previousSubmission, Type submissionReturnType, Type hostObjectType, bool isSubmission, ReferenceManager referenceManager, bool reuseReferenceManager, SyntaxAndDeclarationManager syntaxAndDeclarations, SemanticModelProvider semanticModelProvider, AsyncQueue<CompilationEvent> eventQueue = null)
            : base(assemblyName, options, references, previousSubmission, submissionReturnType, hostObjectType, isSubmission, referenceManager, reuseReferenceManager, syntaxAndDeclarations, semanticModelProvider, eventQueue)
        {
        }

        /// <summary>
        /// Create a duplicate of this compilation with different symbol instances.
        /// </summary>
        protected override LanguageCompilation CreateNew(
            string assemblyName, 
            LanguageCompilationOptions options, 
            IEnumerable<MetadataReference> references, 
            LanguageCompilation previousSubmission, 
            Type submissionReturnType, 
            Type hostObjectType, 
            bool isSubmission, 
            ReferenceManager referenceManager, 
            bool reuseReferenceManager, 
            SyntaxAndDeclarationManager syntaxAndDeclarations,
            SemanticModelProvider semanticModelProvider,
            AsyncQueue<CompilationEvent> eventQueue = null)
        {
            return new [lang]Compilation(
                assemblyName,
                ([lang]CompilationOptions)options,
                references,
                ([lang]Compilation)previousSubmission,
                submissionReturnType,
                hostObjectType,
                isSubmission,
                referenceManager,
                reuseReferenceManager,
                syntaxAndDeclarations,
                semanticModelProvider,
                eventQueue);
        }


        protected override Compilation CommonClone()
        {
            return this.Clone();
        }
        /// <summary>
        /// Creates a new compilation with the specified name.
        /// </summary>
        public new [lang]Compilation WithAssemblyName(string assemblyName) => ([lang]Compilation)base.WithAssemblyName(assemblyName);
        /// <summary>
        /// Creates a new compilation with the specified references.
        /// </summary>
        /// <remarks>
        /// The new <see cref="[lang]Compilation"/> will query the given <see cref="MetadataReference"/> for the underlying
        /// metadata as soon as the are needed.
        ///
        /// The new compilation uses whatever metadata is currently being provided by the <see cref="MetadataReference"/>.
        /// E.g. if the current compilation references a metadata file that has changed since the creation of the compilation
        /// the new compilation is going to use the updated version, while the current compilation will be using the previous (it doesn't change).
        /// </remarks>
        public new [lang]Compilation WithReferences(IEnumerable<MetadataReference> references) => ([lang]Compilation)base.WithReferences(references);
        /// <summary>
        /// Creates a new compilation with the specified references.
        /// </summary>
        public new [lang]Compilation WithReferences(params MetadataReference["[]"] references) => ([lang]Compilation)base.WithReferences(references);
        /// <summary>
        /// Creates a new compilation with the specified compilation options.
        /// </summary>
        public [lang]Compilation WithOptions([lang]CompilationOptions options) => ([lang]Compilation)base.WithOptions(options);
        #endregion
        #region Syntax Trees (maintain an ordered list)
        /// <summary>
        /// Creates a new compilation with additional syntax trees.
        /// </summary>
        public new [lang]Compilation AddSyntaxTrees(params SyntaxTree["[]"] trees) => ([lang]Compilation)base.AddSyntaxTrees(trees);
        /// <summary>
        /// Creates a new compilation with additional syntax trees.
        /// </summary>
        public new [lang]Compilation AddSyntaxTrees(IEnumerable<SyntaxTree> trees) => ([lang]Compilation)base.AddSyntaxTrees(trees);
        /// <summary>
        /// Creates a new compilation without the specified syntax trees. Preserves metadata info for use with trees
        /// added later.
        /// </summary>
        public new [lang]Compilation RemoveSyntaxTrees(params SyntaxTree["[]"] trees) => ([lang]Compilation)base.RemoveSyntaxTrees(trees);
        /// <summary>
        /// Creates a new compilation without the specified syntax trees. Preserves metadata info for use with trees
        /// added later.
        /// </summary>
        public new [lang]Compilation RemoveSyntaxTrees(IEnumerable<SyntaxTree> trees) => ([lang]Compilation)base.RemoveSyntaxTrees(trees);
        /// <summary>
        /// Creates a new compilation without any syntax trees. Preserves metadata info
        /// from this compilation for use with trees added later.
        /// </summary>
        public new [lang]Compilation RemoveAllSyntaxTrees() => ([lang]Compilation)base.RemoveAllSyntaxTrees();
        /// <summary>
        /// Creates a new compilation without the old tree but with the new tree.
        /// </summary>
        public new [lang]Compilation ReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree newTree) => ([lang]Compilation)base.ReplaceSyntaxTree(oldTree, newTree);
        #endregion
        #region References
        /// <summary>
        /// Creates a new compilation with additional metadata references.
        /// </summary>
        public new [lang]Compilation AddReferences(params MetadataReference["[]"] references) => ([lang]Compilation)base.AddReferences(references);
        /// <summary>
        /// Creates a new compilation with additional metadata references.
        /// </summary>
        public new [lang]Compilation AddReferences(IEnumerable<MetadataReference> references) => ([lang]Compilation)base.AddReferences(references);
        /// <summary>
        /// Creates a new compilation without the specified metadata references.
        /// </summary>
        public new [lang]Compilation RemoveReferences(params MetadataReference["[]"] references) => ([lang]Compilation)base.RemoveReferences(references);
        /// <summary>
        /// Creates a new compilation without the specified metadata references.
        /// </summary>
        public new [lang]Compilation RemoveReferences(IEnumerable<MetadataReference> references) => ([lang]Compilation)base.RemoveReferences(references);
        /// <summary>
        /// Creates a new compilation without any metadata references
        /// </summary>
        public new [lang]Compilation RemoveAllReferences() => ([lang]Compilation)base.RemoveAllReferences();
        /// <summary>
        /// Creates a new compilation with an old metadata reference replaced with a new metadata reference.
        /// </summary>
        public new [lang]Compilation ReplaceReference(MetadataReference oldReference, MetadataReference newReference) => ([lang]Compilation)base.ReplaceReference(oldReference, newReference);
        #endregion
    }
}
end template

template GenerateCompilationFactory()
using System.Collections.Generic;
using Microsoft.CodeAnalysis;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Binding;
using MetaDslx.CodeAnalysis.Declarations;
using [Properties.DefaultNamespace];
using [Properties.DefaultNamespace].Syntax;
using [Properties.DefaultNamespace].Binding;
using [Properties.DefaultNamespace].Symbols;
[Instances.ParserHeader]
^
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace]
{
    public class [lang]CompilationFactory : CompilationFactory
    {
        internal [lang]CompilationFactory()
        {
        }
^
        public new [lang]Language Language => [lang]Language.Instance;
        protected override Language LanguageCore => this.Language;
^
        /// <summary>
        /// Default compilation options for the [lang] language
        /// </summary>
        public override LanguageCompilationOptions DefaultCompilationOptions => new [lang]CompilationOptions(OutputKind.ConsoleApplication);
^
        /// <summary>
        /// Default compilation options for script submissions for the [lang] language
        /// </summary>
        public override LanguageCompilationOptions DefaultSubmissionOptions => new [lang]CompilationOptions(OutputKind.DynamicallyLinkedLibrary).WithReferencesSupersedeLowerVersions(true);
^
        /// <summary>
        /// Creates a new compilation from scratch. Methods such as AddSyntaxTrees or AddReferences
        /// on the returned object will allow to continue building up the Compilation incrementally.
        /// </summary>
        /// <param name="assemblyName">Simple assembly name.</param>
        /// <param name="syntaxTrees">The syntax trees with the source code for the new compilation.</param>
        /// <param name="references">The references for the new compilation.</param>
        /// <param name="options">The compiler options to use.</param>
        /// <returns>A new compilation.</returns>
        public override LanguageCompilation CreateCompilation(
            string assemblyName,
            IEnumerable<SyntaxTree> syntaxTrees = null,
            IEnumerable<MetadataReference> references = null,
            LanguageCompilationOptions options = null)
        {
            return [lang]Compilation.Create(assemblyName, syntaxTrees, references, ([lang]CompilationOptions)options);
        }
^
        /// <summary>
        /// Creates a new compilation that can be used in scripting.
        /// </summary>
        /// <param name="assemblyName">Simple assembly name.</param>
        /// <param name="syntaxTree">The syntax tree with the source code for the new compilation.</param>
        /// <param name="references">The references for the new compilation.</param>
        /// <param name="options">The compiler options to use.</param>
        /// <param name="previousScriptCompilation">The compilation of the previous state of the script.</param>
        /// <param name="returnType">The return type resulting from the script.</param>
        /// <param name="globalsType">The type from which the script can take the global variables.</param>
        /// <returns>A new compilation.</returns>
        public override LanguageCompilation CreateScriptCompilation(
            string assemblyName,
            SyntaxTree syntaxTree = null,
            IEnumerable<MetadataReference> references = null,
            LanguageCompilationOptions options = null,
            LanguageCompilation previousScriptCompilation = null,
            global::System.Type returnType = null,
            global::System.Type globalsType = null)
        {
            return [lang]Compilation.CreateScriptCompilation(assemblyName, syntaxTree, references, ([lang]CompilationOptions)options, ([lang]Compilation)previousScriptCompilation, returnType, globalsType);
        }
^
        public override BinderFactoryVisitor CreateBinderFactoryVisitor(BinderFactory binderFactory)
        {
            return new [Properties.LanguageName]BinderFactoryVisitor(binderFactory);
        }
^
        public override RootSingleDeclaration CreateDeclarationTree(LanguageSyntaxTree syntaxTree, string scriptClassName, bool isSubmission)
        {
            return [Properties.LanguageName]DeclarationTreeBuilderVisitor.ForTree(([Properties.LanguageName]SyntaxTree)syntaxTree, this.Language.SymbolFacts, scriptClassName, isSubmission);
        }
^
        /*public override ScriptCompilationInfo CreateScriptCompilationInfo(CompilationBase previousSubmission, Type submissionReturnType, Type hostObjectType)
        {
            return new [Properties.LanguageName]ScriptCompilationInfo(([Properties.LanguageName]Compilation)previousSubmission, submissionReturnType, hostObjectType);
        }
^
        public override SymbolBuilder CreateSymbolBuilder(CompilationBase compilation)
        {
            return new [Properties.LanguageName]SymbolBuilder(([Properties.LanguageName]Compilation)compilation);
        }*/
    }
}
end template

template GenerateCompilationOptions()
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Binding;
using Microsoft.CodeAnalysis;
^
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace]
{
    public class [lang]CompilationOptions : LanguageCompilationOptions, IEquatable<LanguageCompilationOptions>
    {
        public [lang]CompilationOptions(OutputKind outputKind, bool reportSuppressedDiagnostics = false, string? moduleName = null, string? mainTypeName = null, string? scriptClassName = null, IEnumerable<string>? usings = null, OptimizationLevel optimizationLevel = OptimizationLevel.Debug, bool checkOverflow = false, bool allowUnsafe = false, string? cryptoKeyContainer = null, string? cryptoKeyFile = null, ImmutableArray<byte> cryptoPublicKey = default, bool? delaySign = null, Platform platform = Platform.AnyCpu, ReportDiagnostic generalDiagnosticOption = ReportDiagnostic.Default, int warningLevel = 4, IEnumerable<KeyValuePair<string, ReportDiagnostic>>? specificDiagnosticOptions = null, bool concurrentBuild = true, bool deterministic = false, XmlReferenceResolver? xmlReferenceResolver = null, SourceReferenceResolver? sourceReferenceResolver = null, MetadataReferenceResolver? metadataReferenceResolver = null, AssemblyIdentityComparer? assemblyIdentityComparer = null, StrongNameProvider? strongNameProvider = null, bool publicSign = false, MetadataImportOptions metadataImportOptions = MetadataImportOptions.Public, NullableContextOptions nullableContextOptions = NullableContextOptions.Disable) 
            : base([lang]Language.Instance, outputKind, reportSuppressedDiagnostics, moduleName, mainTypeName, scriptClassName, usings, optimizationLevel, 
                  checkOverflow, allowUnsafe, cryptoKeyContainer, cryptoKeyFile, cryptoPublicKey, delaySign, platform, generalDiagnosticOption, warningLevel,
                  specificDiagnosticOptions, concurrentBuild, deterministic, xmlReferenceResolver, sourceReferenceResolver, metadataReferenceResolver, 
                  assemblyIdentityComparer, strongNameProvider, publicSign, metadataImportOptions, nullableContextOptions)
        {
        }

        protected [lang]CompilationOptions([lang]CompilationOptions other)
            : base(other)
        {

        }

        protected override Language LanguageCore => [lang]Language.Instance;

        protected override LanguageCompilationOptions Clone()
        {
            return new [lang]CompilationOptions(this);
        }

        public new [lang]CompilationOptions WithOutputKind(OutputKind kind) => ([lang]CompilationOptions)base.WithOutputKind(kind);
        public new [lang]CompilationOptions WithReportSuppressedDiagnostics(bool value) => ([lang]CompilationOptions)base.WithReportSuppressedDiagnostics(value);
        public new [lang]CompilationOptions WithModuleName(string moduleName) => ([lang]CompilationOptions)base.WithModuleName(moduleName);
        public new [lang]CompilationOptions WithMainTypeName(string name) => ([lang]CompilationOptions)base.WithMainTypeName(name);
        public new [lang]CompilationOptions WithScriptClassName(string name) => ([lang]CompilationOptions)base.WithScriptClassName(name);
        public new [lang]CompilationOptions WithUsings(ImmutableArray<string> usings) => ([lang]CompilationOptions)base.WithUsings(usings);
        public new [lang]CompilationOptions WithUsings(IEnumerable<string> usings) => ([lang]CompilationOptions)base.WithUsings(usings);
        public new [lang]CompilationOptions WithUsings(params string["[]"] usings) => ([lang]CompilationOptions)base.WithUsings(usings);
        public new [lang]CompilationOptions WithOptimizationLevel(OptimizationLevel value) => ([lang]CompilationOptions)base.WithOptimizationLevel(value);
        public new [lang]CompilationOptions WithOverflowChecks(bool enabled) => ([lang]CompilationOptions)base.WithOverflowChecks(enabled);
        public new [lang]CompilationOptions WithAllowUnsafe(bool enabled) => ([lang]CompilationOptions)base.WithAllowUnsafe(enabled);
        public new [lang]CompilationOptions WithCryptoKeyContainer(string name) => ([lang]CompilationOptions)base.WithCryptoKeyContainer(name);
        public new [lang]CompilationOptions WithCryptoKeyFile(string path) => ([lang]CompilationOptions)base.WithCryptoKeyFile(path);
        public new [lang]CompilationOptions WithCryptoPublicKey(ImmutableArray<byte> value) => ([lang]CompilationOptions)base.WithCryptoPublicKey(value);
        public new [lang]CompilationOptions WithDelaySign(bool? value) => ([lang]CompilationOptions)base.WithDelaySign(value);
        public new [lang]CompilationOptions WithPlatform(Platform platform) => ([lang]CompilationOptions)base.WithPlatform(platform);
        public new [lang]CompilationOptions WithGeneralDiagnosticOption(ReportDiagnostic value) => ([lang]CompilationOptions)base.WithGeneralDiagnosticOption(value);
        public new [lang]CompilationOptions WithWarningLevel(int warningLevel) => ([lang]CompilationOptions)base.WithWarningLevel(warningLevel);
        public new [lang]CompilationOptions WithSpecificDiagnosticOptions(ImmutableDictionary<string, ReportDiagnostic> values) => ([lang]CompilationOptions)base.WithSpecificDiagnosticOptions(values);
        public new [lang]CompilationOptions WithSpecificDiagnosticOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>> values) => ([lang]CompilationOptions)base.WithSpecificDiagnosticOptions(values);
        public new [lang]CompilationOptions WithConcurrentBuild(bool concurrentBuild) => ([lang]CompilationOptions)base.WithConcurrentBuild(concurrentBuild);
        public new [lang]CompilationOptions WithDeterministic(bool deterministic) => ([lang]CompilationOptions)base.WithDeterministic(deterministic);
        public new [lang]CompilationOptions WithXmlReferenceResolver(XmlReferenceResolver resolver) => ([lang]CompilationOptions)base.WithXmlReferenceResolver(resolver);
        public new [lang]CompilationOptions WithSourceReferenceResolver(SourceReferenceResolver resolver) => ([lang]CompilationOptions)base.WithSourceReferenceResolver(resolver);
        public new [lang]CompilationOptions WithMetadataReferenceResolver(MetadataReferenceResolver resolver) => ([lang]CompilationOptions)base.WithMetadataReferenceResolver(resolver);
        public new [lang]CompilationOptions WithAssemblyIdentityComparer(AssemblyIdentityComparer comparer) => ([lang]CompilationOptions)base.WithAssemblyIdentityComparer(comparer);
        public new [lang]CompilationOptions WithStrongNameProvider(StrongNameProvider provider) => ([lang]CompilationOptions)base.WithStrongNameProvider(provider);
        public new [lang]CompilationOptions WithPublicSign(bool publicSign) => ([lang]CompilationOptions)base.WithPublicSign(publicSign);
        public new [lang]CompilationOptions WithMetadataImportOptions(MetadataImportOptions value) => ([lang]CompilationOptions)base.WithMetadataImportOptions(value);
        public new [lang]CompilationOptions WithNullableContextOptions(NullableContextOptions value) => ([lang]CompilationOptions)base.WithNullableContextOptions(value);

        public new [lang]CompilationOptions WithTopLevelBinderFlags(BinderFlags flags) => ([lang]CompilationOptions)base.WithTopLevelBinderFlags(flags);
        public new [lang]CompilationOptions WithReferencesSupersedeLowerVersions(bool value) => ([lang]CompilationOptions)base.WithReferencesSupersedeLowerVersions(value);

    }
}
end template

template GenerateScriptCompilationInfo()
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MetaDslx.Compiler;
^
namespace [Properties.DefaultNamespace]
{
    public class [Properties.LanguageName]ScriptCompilationInfo : ScriptCompilationInfo
    {
        public new [Properties.LanguageName]Compilation PreviousScriptCompilation { get; }
^
        internal [Properties.LanguageName]ScriptCompilationInfo([Properties.LanguageName]Compilation previousCompilationOpt, Type returnType, Type globalsType)
            : base(returnType, globalsType)
        {
            Debug.Assert(previousCompilationOpt == null || previousCompilationOpt.HostObjectType == globalsType);
^
            PreviousScriptCompilation = previousCompilationOpt;
        }
^
        protected override Compilation CommonPreviousScriptCompilation => PreviousScriptCompilation;
^
        public [Properties.LanguageName]ScriptCompilationInfo WithPreviousScriptCompilation([Properties.LanguageName]Compilation compilation) =>
            (compilation == PreviousScriptCompilation) ? this : new [Properties.LanguageName]ScriptCompilationInfo(compilation, ReturnType, GlobalsType);
^
        protected override ScriptCompilationInfo CommonWithPreviousScriptCompilation(Compilation compilation) =>
            WithPreviousScriptCompilation(([Properties.LanguageName]Compilation)compilation);
    }
}
end template


template GenerateErrorCode()
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using MetaDslx.CodeAnalysis;
^
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace]
{
    public partial class [lang]ErrorCode : ErrorCode
    {
        public new const string Category = "[Instances.ErrorCodeCategory]";
        public new const string MessagePrefix = "[Instances.MessagePrefix]";
^
        private static readonly ErrorCodeMessageProvider s_messages = new ErrorCodeMessageProvider(MessagePrefix, typeof([lang]ErrorCode));

^
        public static readonly [lang]ErrorCode ERR_GeneralError = new [lang]ErrorCode(1, DiagnosticSeverity.Error, "Error", "Error: {0}");
        public static readonly [lang]ErrorCode WRN_GeneralWarning = new [lang]ErrorCode(2, DiagnosticSeverity.Warning, "Warning", "Warning: {0}");
        public static readonly [lang]ErrorCode INF_GeneralInfo = new [lang]ErrorCode(3, DiagnosticSeverity.Info, "Info", "Info: {0}");
        public static readonly [lang]ErrorCode ERR_BadLanguageVersion = new [lang]ErrorCode(4, DiagnosticSeverity.Error, "Bad language version", "Bad [lang] language version: {0}");
        public static readonly [lang]ErrorCode ERR_FeatureNotAvailableInVersion1 = new [lang]ErrorCode(5, DiagnosticSeverity.Error, "Feature not available", "Feature not available in [lang] version 1: {0}");
^
        private [lang]ErrorCode(int code, DiagnosticSeverity defaultSeverity, string title, string messageFormat, bool isEnabledByDefault = true, string description = null, string helpLinkUri = null, params string["[]"] customTags) 
            : base(s_messages, code, title, messageFormat, Category, defaultSeverity, isEnabledByDefault, description, helpLinkUri, customTags)
        {
        }
    }
}
end template

template GenerateSyntaxLexer()
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Antlr4.Runtime;
using Antlr4.Runtime.Tree;
using MetaDslx.CodeAnalysis.Syntax;
using MetaDslx.CodeAnalysis.Syntax.InternalSyntax;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Syntax.InternalSyntax;
using Microsoft.CodeAnalysis.Text;
using MetaDslx.Languages.Antlr4Roslyn.Syntax.InternalSyntax;

namespace [Properties.DefaultNamespace].Syntax.InternalSyntax
{
    public class [Properties.LanguageName]SyntaxLexer : Antlr4SyntaxLexer
    {
        public [Properties.LanguageName]SyntaxLexer(SourceText text, [Properties.LanguageName]ParseOptions options) 
            : base([Properties.LanguageName]Language.Instance, text, options)
        {
        }

        protected override InternalSyntaxToken CreateToken(GreenNode leadingTrivia, SyntaxKind kind, string text, GreenNode trailingTrivia)
        {
            return [Properties.LanguageName]Language.Instance.InternalSyntaxFactory.Token(leadingTrivia, kind, text, trailingTrivia);
        }

        protected override InternalSyntaxTrivia CreateTrivia(SyntaxKind kind, string text)
        {
            return [Properties.LanguageName]Language.Instance.InternalSyntaxFactory.Trivia(kind, text);
        }
    }
}
end template

template GenerateSyntaxParser()
[var lang = Properties.LanguageName]
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Antlr4.Runtime;
using Antlr4.Runtime.Tree;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Syntax;
using MetaDslx.CodeAnalysis.Syntax.InternalSyntax;
using MetaDslx.Languages.Antlr4Roslyn.Syntax.InternalSyntax;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Syntax.InternalSyntax;
using Microsoft.CodeAnalysis.Text;

namespace [Properties.DefaultNamespace].Syntax.InternalSyntax
{
    public class [lang]SyntaxParser : Antlr4SyntaxParser
    {
        private readonly Antlr4ToRoslynVisitor _visitor;

        public [lang]SyntaxParser(
            SourceText text,
            [lang]ParseOptions options,
            [lang]SyntaxNode oldTree, 
			ParseData oldParseData,
            IEnumerable<TextChangeRange> changes,
            CancellationToken cancellationToken = default)
            : base([lang]Language.Instance, text, options, oldTree, oldParseData, changes, cancellationToken)
        {
            _visitor = new Antlr4ToRoslynVisitor(this);
        }

        protected new [lang]Parser Antlr4Parser => ([lang]Parser)base.Antlr4Parser;

		public override LanguageSyntaxNode Parse()
		{
			BeginRoot();
            ParserState state = null;
			var green = this.Parse[Instances.MainRule().PlainName()](ref state);
			EndRoot(ref green);
			var red = ([lang]SyntaxNode)green.CreateRed();
			return red;
		}

        [loop(rule:Instances.ParserRules)]
		[GenerateAntlr4ToRoslynSyntaxParseRule(rule, null)]
		[end loop]

        private class Antlr4ToRoslynVisitor : [lang]ParserBaseVisitor<GreenNode>
        {
			// list pools - allocators for lists that are used to build sequences of nodes. The lists
			// can be reused (hence pooled) since the syntax factory methods don't keep references to
			// them
			private readonly SyntaxListPool _pool = new SyntaxListPool(); // Don't need to reset this.
			
			private readonly [lang]InternalSyntaxFactory _factory;
            private readonly [lang]SyntaxParser _syntaxParser;

            public Antlr4ToRoslynVisitor([lang]SyntaxParser syntaxParser)
            {
				_factory = ([lang]InternalSyntaxFactory)syntaxParser.Language.InternalSyntaxFactory;
                _syntaxParser = syntaxParser;
            }
			
            private GreenNode VisitTerminal(IToken token, [lang]SyntaxKind kind)
            {
				if (kind == SyntaxKind.Eof)
				{
					return _syntaxParser.EatToken();
				}
				if (token == null)
				{
					if (kind != null)
					{
						return _factory.MissingToken(kind);
					}
					else
					{
						return null;
					}
				}
                var green = ((IncrementalToken)token).GreenToken;
				Debug.Assert(kind == null || green.Kind == kind);
				return green;
            }
            public GreenNode VisitTerminal(IToken token)
            {
				return VisitTerminal(token, null);
            }
            private GreenNode VisitTerminal(ITerminalNode node, [lang]SyntaxKind kind)
            {
				if (kind == SyntaxKind.Eof)
				{
					return _syntaxParser.EatToken();
				}
                if (node == null || node.Symbol == null)
				{
					if (kind != null)
					{
						return _factory.MissingToken(kind);
					}
					else
					{
						return null;
					}
				}
				var green = ((IncrementalToken)node.Symbol).GreenToken;
				Debug.Assert(kind == null || green.Kind == kind);
				return green;
			}
            public override GreenNode VisitTerminal(ITerminalNode node)
            {
                return VisitTerminal(node, null);
            }

			public override GreenNode Visit(IParseTree tree)
			{
                if (tree is ICachedRuleContext cached)
                {
                    return cached.CachedNode;
                }
				else if (tree is ParserRuleContext context)
                {
                    if (_syntaxParser.TryGetGreenNode(context, out var existingGreenNode)) return existingGreenNode;
    				return base.Visit(tree);
                }
                else
                {
                    return base.Visit(tree);
                }
			}
            [loop(rule:Instances.ParserRules)]
			[GenerateAntlr4ToRoslynVisitorRule(rule, null)]
			[end loop]
        }
    }

    public partial class [lang]Parser
    {
        [loop(rule:Instances.ParserRules)]
		[GenerateAntlr4ToRoslynCachedParserRuleContext(rule, null)]
		[end loop]
    }
}
end template

template GenerateAntlr4ToRoslynGetIncrementalContext(Antlr4ParserRule rule, Antlr4ParserRule superRule)
[var lang = Properties.LanguageName]
case [lang]Parser.RULE_[rule.Name]:
	return CanReuse[rule.PlainName()](CurrentNode as [rule.RedName()]) ? new [lang]Parser.[rule.PlainName()]Context_Cached(parent, invokingState, EatNode()) : null;
end template

template GenerateAntlr4ToRoslynSyntaxParseRule(Antlr4ParserRule rule, Antlr4ParserRule superRule)
[var lang = Properties.LanguageName]
public GreenNode Parse[rule.PlainName()](ref ParserState state)
{
    RestoreParserState(state);
	try
	{
        [if (rule == Instances.MainRule())]
        var context = this.IsIncremental ? this.Antlr4Parser.[rule.Name]() : _Antlr4Parse[rule.PlainName()]();
        [else]
		var context = this.Antlr4Parser.[rule.Name]();
        [end if]
        if (TryGetGreenNode(context, out var green)) return green;
        else return _visitor.Visit(context);
	}
	finally
	{
		state = this.State;
	}
}
^
protected virtual bool CanReuse[rule.PlainName()]([rule.RedName()] node)
{
	return node != null;
}
^
internal [lang]Parser.[rule.PlainName()]Context _Antlr4Parse[rule.PlainName()]([rule.IsRecursive ? "int precedence" : ""])
{
	BeginNode();
    [lang]Parser.[rule.PlainName()]Context context = null;
    GreenNode green = null;
    try
    {
		if (IsIncremental && CanReuse[rule.PlainName()](CurrentNode as [rule.RedName()]))
		{
			green = EatNode();
			context = new [lang]Parser.[rule.PlainName()]Context_Cached(this.Antlr4Parser.Context, this.Antlr4Parser.State, green);
			this.Antlr4Parser.Context.AddChild(context);
		}
		else
		{
			context = this.Antlr4Parser._DoParse[rule.PlainName()]([rule.IsRecursive ? "precedence" : ""]);
			green = _visitor.Visit(context);
		}
    }
    finally
    {
        EndNode(ref green);
        CacheGreenNode(context, green);
    }
    return context;
}
^
end template

template GenerateAntlr4ToRoslynCachedParserRuleContext(Antlr4ParserRule rule, Antlr4ParserRule superRule)
[var lang = Properties.LanguageName]
^
internal class [rule.PlainName()]Context_Cached : [rule.PlainName()]Context, ICachedRuleContext
{
    private GreenNode _cachedNode;

    public [rule.PlainName()]Context_Cached(ParserRuleContext parent, int invokingState, GreenNode cachedNode)
		: base(parent, invokingState)
    {
        _cachedNode = cachedNode;
    }

    public GreenNode CachedNode => _cachedNode;
}
end template

template GenerateAntlr4ToRoslynVisitorRule(Antlr4ParserRule rule, Antlr4ParserRule superRule)
[var lang = Properties.LanguageName]
[if (rule.Alternatives.Count > 0)]
	[loop(alt:rule.Alternatives)]
[GenerateAntlr4ToRoslynVisitorRule(alt, rule)]
	[end loop]
[else]
^
public override GreenNode Visit[rule.PlainName()]([lang]Parser.[rule.PlainName()]Context context)
{
	if (context == null) return [rule.GreenName()].__Missing;
	[if (rule.IsSimpleAlt)]
		[loop(elem:rule.Elements)]
	[lang]Parser.[elem.PlainType(false)]Context [elem.FieldName()]Context = context.[elem.GetAccessorName()];
			[if (elem.IsSimplified && elem.IsList && elem.IsSeparated)]
	if ([elem.FieldName()]Context != null) 
	{
		return _factory.[rule.PlainName()]((([elem.GreenType(TypeKind.Public, false)])this.Visit([elem.FieldName()]Context))?.[elem.Grammar.FindParserRule(elem.OriginalType).Elements[0].GreenName()]);
	}
			[else]
	if ([elem.FieldName()]Context != null) 
	{
		return _factory.[rule.PlainName()](([elem.GreenType(TypeKind.Public, false)])this.Visit([elem.FieldName()]Context));
	}
			[end if]
		[end loop]
	return [rule.GreenName()].__Missing;
	[else]
	[loop(elem:rule.AllElements)]
		[if(elem.IsSimplified)]
	[lang]Parser.[elem.PlainType(false)]Context [elem.FieldName()]Context = context.[elem.GetAccessorName()];
	[elem.GreenType(TypeKind.Public, false)] [elem.FieldName()] = null;
	if ([elem.FieldName()]Context != null) [elem.FieldName()] = ([elem.GreenType(TypeKind.Public, false)])this.Visit([elem.FieldName()]Context);
            [if (!elem.IsOptional)]
	if ([elem.FieldName()] == null) [elem.FieldName()] = [elem.GreenType(TypeKind.Public, false)].__Missing;
            [end if]
		[else]
		[if(elem.IsBlock)]
			[if(elem.IsFixedTokenAltBlock)]
	InternalSyntaxToken [elem.FieldName()] = null;
				[loop(item:elem.BlockItems; separator delim = "else ")]
	if (context.[item.GetAccessorName()] != null)
	{
		[elem.FieldName()] = (InternalSyntaxToken)this.VisitTerminal(context.[item.GetAccessorName()]);
	}
	[delim]\
				[end loop]
				[if (!elem.IsOptional)]
					[if (hasloop(item:elem.BlockItems))]
	else
	{
		[elem.FieldName()] = _factory.MissingToken(SyntaxKind.MissingToken);
	}
					[else]
	[elem.FieldName()] = _factory.MissingToken(SyntaxKind.MissingToken);
					[end if]
				[end if]
			[else]
	// throw new NotImplementedException("Error in Antlr4Roslyn compiler. Unhandled element: [elem.GreenType(TypeKind.Field)] [elem.FieldName()]");
			[end if]
		[else]
			[if(elem.IsList)]
				[if(elem.IsSeparated)]
                    [if(elem.IsMappedToIList())]
    IList<[lang]Parser.[elem.PlainType()]Context> [elem.FieldName()]Context = context.[elem.GetAccessorName()];
    IList<IToken> [elem.Separator.FieldName()]Context = context.[elem.Separator.GetAccessorName()];
                    [else]
    [lang]Parser.[elem.PlainType()]Context["[]"] [elem.FieldName()]Context = context.[elem.GetAccessorName()];
    ITerminalNode["[]"] [elem.Separator.FieldName()]Context = context.[elem.Separator.GetAccessorName()];
                    [end if]
    var [elem.FieldName()]Builder = _pool.AllocateSeparated<[elem.GreenInnerType()]>();
                    [if(elem.IsMappedToIList())]
    for (int i = 0; i < [elem.FieldName()]Context.Count; i++)
                    [else]
    for (int i = 0; i < [elem.FieldName()]Context.Length; i++)
                    [end if]
    {
        [elem.FieldName()]Builder.Add(([elem.GreenInnerType()])this.Visit([elem.FieldName()]Context["[i]"]));
                    [if(elem.IsMappedToIList())]
        if (i < [elem.Separator.FieldName()]Context.Count)
                    [else]
        if (i < [elem.Separator.FieldName()]Context.Length)
                    [end if]
        {
            [elem.FieldName()]Builder.AddSeparator((InternalSyntaxToken)this.VisitTerminal([elem.Separator.FieldName()]Context["[i]"], [lang]SyntaxKind.[elem.Separator.SyntaxKind()]));
        }
    }
	var [elem.FieldName()] = [elem.FieldName()]Builder.ToList();
	_pool.Free([elem.FieldName()]Builder);
				[else]
					[if(elem.IsToken)]
                        [if(elem.IsMappedToIList())]
    IList<IToken> [elem.FieldName()]Context = context.[elem.GetAccessorName()];
                        [else]
    ITerminalNode["[]"] [elem.FieldName()]Context = context.[elem.GetAccessorName()];
                        [end if]
    var [elem.FieldName()]Builder = _pool.Allocate<[elem.GreenInnerType()]>();
                        [if(elem.IsMappedToIList())]
    for (int i = 0; i < [elem.FieldName()]Context.Count; i++)
                        [else]
    for (int i = 0; i < [elem.FieldName()]Context.Length; i++)
                        [end if]
    {
        [elem.FieldName()]Builder.Add(([elem.GreenInnerType()])this.VisitTerminal([elem.FieldName()]Context["[i]"], [lang]SyntaxKind.[elem.SyntaxKind()]));
    }
	var [elem.FieldName()] = [elem.FieldName()]Builder.ToList();
	_pool.Free([elem.FieldName()]Builder);
					[else]
                        [if(elem.IsMappedToIList())]
    IList<[lang]Parser.[elem.PlainType()]Context> [elem.FieldName()]Context = context.[elem.GetAccessorName()];
                        [else]
    [lang]Parser.[elem.PlainType()]Context["[]"] [elem.FieldName()]Context = context.[elem.GetAccessorName()];
                        [end if]
    var [elem.FieldName()]Builder = _pool.Allocate<[elem.GreenInnerType()]>();
                        [if(elem.IsMappedToIList())]
    for (int i = 0; i < [elem.FieldName()]Context.Count; i++)
                        [else]
    for (int i = 0; i < [elem.FieldName()]Context.Length; i++)
                        [end if]
    {
        [elem.FieldName()]Builder.Add(([elem.GreenInnerType()])this.Visit([elem.FieldName()]Context["[i]"]));
    }
	var [elem.FieldName()] = [elem.FieldName()]Builder.ToList();
	_pool.Free([elem.FieldName()]Builder);
					[end if]
				[end if]
			[else]
				[if(elem.IsToken)]
					[if (elem.IsOptional)]
	InternalSyntaxToken [elem.FieldName()] = (InternalSyntaxToken)this.VisitTerminal(context.[elem.Antlr4Name()]);
					[else]
	InternalSyntaxToken [elem.FieldName()] = (InternalSyntaxToken)this.VisitTerminal(context.[elem.Antlr4Name()], [lang]SyntaxKind.[elem.SyntaxKind()]);
					[end if]
				[else]
	[lang]Parser.[elem.PlainType()]Context [elem.FieldName()]Context = context.[elem.GetAccessorName()];
	[elem.GreenType(TypeKind.Field)] [elem.FieldName()] = null;
	if ([elem.FieldName()]Context != null) [elem.FieldName()] = ([elem.GreenType(TypeKind.Field)])this.Visit([elem.FieldName()]Context);
                    [if (!elem.IsOptional)]
	if ([elem.FieldName()] == null) [elem.FieldName()] = [elem.GreenType(TypeKind.Field)].__Missing;
                    [end if]
				[end if]
			[end if]
		[end if]
		[end if]
	[end loop]
	return _factory.[rule.PlainName()]([GetRoslynVisitorElemParamList(rule, false, false)]);
	[end if]
}
[end if]
end template


template GenerateSyntaxTree()
[var lang = Properties.LanguageName]
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Syntax;
using MetaDslx.Languages.Antlr4Roslyn.Syntax.InternalSyntax;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using [Properties.DefaultNamespace];
using [Properties.DefaultNamespace].Syntax;
using [Properties.DefaultNamespace].Syntax.InternalSyntax;

namespace [Properties.DefaultNamespace]
{
    /// <summary>
    /// The parsed representation of a C# source document.
    /// </summary>
    public abstract partial class [lang]SyntaxTree : LanguageSyntaxTree
    {
        internal static readonly [lang]SyntaxTree Dummy = new DummySyntaxTree();
        /// <summary>
        /// The options used by the parser to produce the syntax tree.
        /// </summary>
        public new abstract [lang]ParseOptions Options { get; }

        /// <summary>
        /// Gets the root node of the syntax tree.
        /// </summary>
        public new abstract [lang]SyntaxNode GetRoot(CancellationToken cancellationToken = default(CancellationToken));
        /// <summary>
        /// Gets the root node of the syntax tree if it is already available.
        /// </summary>
        public abstract bool TryGetRoot(out [lang]SyntaxNode root);
        /// <summary>
        /// Gets the root node of the syntax tree asynchronously.
        /// </summary>
        /// <remarks>
        /// By default, the work associated with this method will be executed immediately on the current thread.
        /// Implementations that wish to schedule this work differently should override <see cref="GetRootAsync(CancellationToken)"/>.
        /// </remarks>
        public new virtual Task<[lang]SyntaxNode> GetRootAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            [lang]SyntaxNode node;
            return Task.FromResult(this.TryGetRoot(out node) ? node : this.GetRoot(cancellationToken));
        }
        /// <summary>
        /// Gets the root of the syntax tree statically typed as <see cref="[Instances.MainRule().RedName()]"/>.
        /// </summary>
        /// <remarks>
        /// Ensure that <see cref="SyntaxTree.HasCompilationUnitRoot"/> is true for this tree prior to invoking this method.
        /// </remarks>
        /// <exception cref="InvalidCastException">Throws this exception if <see cref="SyntaxTree.HasCompilationUnitRoot"/> is false.</exception>
        public [Instances.MainRule().RedName()] GetCompilationUnitRoot(CancellationToken cancellationToken = default(CancellationToken))
        {
            return ([Instances.MainRule().RedName()])this.GetRoot(cancellationToken);
        }
        #region Factories
        /// <summary>
        /// Creates a new syntax tree from a syntax node.
        /// </summary>
        public static [lang]SyntaxTree Create([lang]SyntaxNode root, ParseData parseData, [lang]ParseOptions? options = null, string path = "", SourceText? text = null, Encoding? encoding = null, SourceHashAlgorithm checksumAlgorithm = SourceHashAlgorithm.Sha1)
        {
            if (root == null)
            {
                throw new ArgumentNullException(nameof(root));
            }
            var directives = root.Kind == [lang]SyntaxKind.Main && root is ICompilationUnitRootSyntax compilationUnitRoot ?
                ((ICompilationUnitRootSyntax)root).GetConditionalDirectivesStack() :
                DirectiveStack.Empty;
            return new ParsedSyntaxTree(
                textOpt: text,
                encodingOpt: encoding,
                checksumAlgorithm: checksumAlgorithm,
                path: path,
                options: options ?? [lang]ParseOptions.Default,
                root: root,
                parseData: parseData.WithDirectives(directives));
        }
        /// <summary>
        /// Creates a new syntax tree from a syntax node with text that should correspond to the syntax node.
        /// </summary>
        /// <remarks>This is used by the ExpressionEvaluator.</remarks>
        internal static [lang]SyntaxTree CreateForDebugger([lang]SyntaxNode root, ParseData parseData, SourceText text, [lang]ParseOptions options)
        {
            Debug.Assert(root != null);
            return new DebuggerSyntaxTree(root, parseData, text, options);
        }
        /// <summary>
        /// <para>
        /// Internal helper for <see cref="[lang]SyntaxNode"/> class to create a new syntax tree rooted at the given root node.
        /// This method does not create a clone of the given root, but instead preserves it's reference identity.
        /// </para>
        /// <para>NOTE: This method is only intended to be used from <see cref="[lang]SyntaxNode.SyntaxTree"/> property.</para>
        /// <para>NOTE: Do not use this method elsewhere, instead use <see cref="Create([lang]SyntaxNode, CSharpParseOptions, string, Encoding)"/> method for creating a syntax tree.</para>
        /// </summary>
        internal static [lang]SyntaxTree CreateWithoutClone([lang]SyntaxNode root, ParseData parseData)
        {
            Debug.Assert(root != null);
            return new ParsedSyntaxTree(
                textOpt: null,
                encodingOpt: null,
                checksumAlgorithm: SourceHashAlgorithm.Sha1,
                path: "",
                options: [lang]ParseOptions.Default,
                root: root,
                parseData: parseData.WithDirectives(DirectiveStack.Empty),
                cloneRoot: false);
        }
        /// <summary>
        /// Produces a syntax tree by parsing the source text.
        /// </summary>
        public static [lang]SyntaxTree ParseText(
            string text,
            [lang]ParseOptions options = null,
            string path = "",
            Encoding encoding = null,
            CancellationToken cancellationToken = default(CancellationToken))
        {
            return ParseText(SourceText.From(text, encoding), options, path, cancellationToken);
        }
        /// <summary>
        /// Produces a syntax tree by parsing the source text.
        /// </summary>
        public static [lang]SyntaxTree ParseText(
            SourceText text,
            [lang]ParseOptions options = null,
            string path = "",
            CancellationToken cancellationToken = default(CancellationToken))
        {
            if (text == null)
            {
                throw new ArgumentNullException(nameof(text));
            }
            options = options ?? [lang]ParseOptions.Default;
            using (var parser = new [lang]SyntaxParser(text, options, oldTree: null, oldParseData: ParseData.Empty, changes: null, cancellationToken: cancellationToken))
            {
                var compilationUnit = ([Instances.MainRule().RedName()])parser.Parse();
                var tree = new ParsedSyntaxTree(text, text.Encoding, text.ChecksumAlgorithm, path, options, compilationUnit, parser.ParseData);
                tree.VerifySource();
                return tree;
            }
        }
        #endregion
        #region Completion
        protected override ImmutableArray<SyntaxKind> LookupTokensCore(int position, CancellationToken cancellationToken = default)
        {
            return new Antlr4CompletionSource(this.ParseData, this.GetRoot(cancellationToken), [lang]Parser._ATN).GetTokenSuggestions(position, cancellationToken);
        }
        public new ImmutableArray<[lang]SyntaxKind> LookupTokens(int position, CancellationToken cancellationToken)
        {
            return this.LookupTokensCore(position, cancellationToken).Select(kind => ([lang]SyntaxKind)kind).ToImmutableArray();
        }
        #endregion
        #region Changes
        /// <summary>
        /// Creates a new syntax based off this tree using a new source text.
        /// </summary>
        /// <remarks>
        /// If the new source text is a minor change from the current source text an incremental parse will occur
        /// reusing most of the current syntax tree internal data.  Otherwise, a full parse will occur using the new
        /// source text.
        /// </remarks>
        public override SyntaxTree WithChangedText(SourceText newText)
        {
            // try to find the changes between the old text and the new text.
            SourceText oldText;
            if (this.TryGetText(out oldText))
            {
                var changes = newText.GetChangeRanges(oldText);
                if (changes.Count == 0 && newText == oldText)
                {
                    return this;
                }
                return this.WithChanges(newText, changes);
            }
            // if we do not easily know the old text, then specify entire text as changed so we do a full reparse.
            return this.WithChanges(newText, new["[]"] { new TextChangeRange(new TextSpan(0, this.Length), newText.Length) });
        }
        private SyntaxTree WithChanges(SourceText newText, IReadOnlyList<TextChangeRange> changes)
        {
            if (changes == null)
            {
                throw new ArgumentNullException(nameof(changes));
            }
            var oldTree = this;
            // if changes is entire text do a full reparse
            if (changes.Count == 1 && changes[0].Span == new TextSpan(0, this.Length) && changes[0].NewLength == newText.Length)
            {
                // parser will do a full parse if we give it no changes
                changes = null;
                oldTree = null;
            }
            using (var parser = new [lang]SyntaxParser(newText, this.Options, oldTree?.GetRoot(), oldTree?.ParseData ?? ParseData.Empty, changes))
            {
                var compilationUnit = ([Instances.MainRule().RedName()])parser.Parse();
                var tree = new ParsedSyntaxTree(newText, newText.Encoding, newText.ChecksumAlgorithm, this.FilePath, this.Options, compilationUnit, parser.ParseData);
                tree.VerifySource(changes);
                return tree;
            }
        }
        #endregion
        #region SyntaxTree
        protected override ParseOptions OptionsCore => this.Options;
        protected override SyntaxNode GetRootCore(CancellationToken cancellationToken)
        {
            return this.GetRoot(cancellationToken);
        }
        protected override async Task<SyntaxNode> GetRootAsyncCore(CancellationToken cancellationToken)
        {
            return await this.GetRootAsync(cancellationToken).ConfigureAwait(false);
        }
        protected override bool TryGetRootCore(out SyntaxNode root)
        {
            [lang]SyntaxNode node;
            if (this.TryGetRoot(out node))
            {
                root = node;
                return true;
            }
            else
            {
                root = null;
                return false;
            }
        }
        #endregion
        internal sealed class DummySyntaxTree : [lang]SyntaxTree
        {
            private readonly [lang]SyntaxNode _node;
            public DummySyntaxTree()
            {
                _node = this.CloneNodeAsRoot(([Instances.MainRule().RedName()])[Instances.MainRule().GreenName()].__Missing.CreateRed());
            }
            public override string ToString()
            {
                return string.Empty;
            }
            public override SourceText GetText(CancellationToken cancellationToken)
            {
                return SourceText.From(string.Empty, Encoding.UTF8);
            }
            public override bool TryGetText(out SourceText text)
            {
                text = SourceText.From(string.Empty, Encoding.UTF8);
                return true;
            }
            public override Encoding Encoding
            {
                get { return Encoding.UTF8; }
            }
            public override int Length
            {
                get { return 0; }
            }
            public override [lang]ParseOptions Options
            {
                get { return [lang]ParseOptions.Default; }
            }
            public override string FilePath
            {
                get { return string.Empty; }
            }
            public override SyntaxReference GetReference(SyntaxNode node)
            {
                return new SimpleSyntaxReference(node);
            }
            public override [lang]SyntaxNode GetRoot(CancellationToken cancellationToken)
            {
                return _node;
            }
            public override bool TryGetRoot(out [lang]SyntaxNode root)
            {
                root = _node;
                return true;
            }
            public override bool HasCompilationUnitRoot
            {
                get { return true; }
            }

            protected override ParseData ParseData => ParseData.Empty;

            public override FileLinePositionSpan GetLineSpan(TextSpan span, CancellationToken cancellationToken = default(CancellationToken))
            {
                return default(FileLinePositionSpan);
            }
            public override SyntaxTree WithRootAndOptions(SyntaxNode root, ParseOptions options)
            {
                return [lang]Language.Instance.SyntaxFactory.SyntaxTree((LanguageSyntaxNode)root, options: ([lang]ParseOptions)options, path: FilePath, encoding: null);
            }
            public override SyntaxTree WithFilePath(string path)
            {
                return [lang]Language.Instance.SyntaxFactory.SyntaxTree(_node, options: this.Options, path: path, encoding: null);
            }
        }
        private class ParsedSyntaxTree : [lang]SyntaxTree
        {
            private readonly [lang]ParseOptions _options;
            private readonly string _path;
            private readonly [lang]SyntaxNode _root;
            private readonly ParseData _parseData;
            private readonly bool _hasCompilationUnitRoot;
            private readonly Encoding? _encodingOpt;
            private readonly SourceHashAlgorithm _checksumAlgorithm;
            private SourceText _lazyText;
            internal ParsedSyntaxTree(SourceText? textOpt, Encoding? encodingOpt, SourceHashAlgorithm checksumAlgorithm, string path, [lang]ParseOptions options, [lang]SyntaxNode root, ParseData parseData, bool cloneRoot = true)
            {
                Debug.Assert(root != null);
                Debug.Assert(options != null);
                Debug.Assert(textOpt == null || textOpt.Encoding == encodingOpt && textOpt.ChecksumAlgorithm == checksumAlgorithm);
                _lazyText = textOpt;
                _encodingOpt = encodingOpt ?? textOpt?.Encoding;
                _checksumAlgorithm = checksumAlgorithm;
                _options = options;
                _path = path ?? string.Empty;
                _root = cloneRoot ? this.CloneNodeAsRoot(root) : root;
                _parseData = parseData;
                _hasCompilationUnitRoot = root.Kind == [lang]SyntaxKind.Main;
            }
            protected override ParseData ParseData => _parseData;
            public override string FilePath
            {
                get { return _path; }
            }
            public override SourceText GetText(CancellationToken cancellationToken)
            {
                if (_lazyText == null)
                {
                    Interlocked.CompareExchange(ref _lazyText, this.GetRoot(cancellationToken).GetText(_encodingOpt, _checksumAlgorithm), null);
                }
                return _lazyText;
            }
            public override bool TryGetText(out SourceText text)
            {
                text = _lazyText;
                return text != null;
            }
            public override Encoding Encoding
            {
                get { return _encodingOpt; }
            }
            public override int Length
            {
                get { return _root.FullSpan.Length; }
            }
            public override [lang]SyntaxNode GetRoot(CancellationToken cancellationToken)
            {
                return _root;
            }
            public override bool TryGetRoot(out [lang]SyntaxNode root)
            {
                root = _root;
                return true;
            }
            public override bool HasCompilationUnitRoot
            {
                get
                {
                    return _hasCompilationUnitRoot;
                }
            }
            public override [lang]ParseOptions Options
            {
                get
                {
                    return _options;
                }
            }
            public override SyntaxReference GetReference(SyntaxNode node)
            {
                return new SimpleSyntaxReference(node);
            }
            public override SyntaxTree WithRootAndOptions(SyntaxNode root, ParseOptions options)
            {
                if (ReferenceEquals(_root, root) && ReferenceEquals(_options, options))
                {
                    return this;
                }
                return new ParsedSyntaxTree(
                    null,
                    _encodingOpt,
                    _checksumAlgorithm,
                    _path,
                    ([lang]ParseOptions)options,
                    ([lang]SyntaxNode)root,
                    this.ParseData);
            }
            public override SyntaxTree WithFilePath(string path)
            {
                if (_path == path)
                {
                    return this;
                }
                return new ParsedSyntaxTree(
                    _lazyText,
                    _encodingOpt,
                    _checksumAlgorithm,
                    path,
                    _options,
                    _root,
                    this.ParseData);
            }
        }
        private class DebuggerSyntaxTree : ParsedSyntaxTree
        {
            public DebuggerSyntaxTree([lang]SyntaxNode root, ParseData parseData, SourceText text, [lang]ParseOptions options)
                : base(
                    text,
                    text.Encoding,
                    text.ChecksumAlgorithm,
                    path: "",
                    options: options,
                    root: root,
                    parseData: parseData.WithDirectives(DirectiveStack.Empty))
            {
            }
            protected override bool SupportsLocations
            {
                get { return true; }
            }
        }
    }
}
end template

template GenerateInternalSyntax()
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
^
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace].Syntax.InternalSyntax
{
    using System.Runtime.CompilerServices;
    using MetaDslx.CodeAnalysis;
    using MetaDslx.CodeAnalysis.Syntax;
    using MetaDslx.CodeAnalysis.Syntax.InternalSyntax;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.Syntax;
	using Microsoft.CodeAnalysis.Syntax.InternalSyntax;
	using Microsoft.CodeAnalysis.Text;
    using Roslyn.Utilities;
    using MetaDslx.Languages.Antlr4Roslyn.Syntax.InternalSyntax;
^	
	internal abstract class GreenSyntaxNode : InternalSyntaxNode
    {
        protected GreenSyntaxNode(SyntaxKind kind)
            : base(kind)
        {
        }
^
        protected GreenSyntaxNode(SyntaxKind kind, int fullWidth)
            : base(kind, fullWidth)
        {
        }
^
        protected GreenSyntaxNode(SyntaxKind kind, DiagnosticInfo["[]"] diagnostics)
            : base(kind, diagnostics)
        {
        }
^
        protected GreenSyntaxNode(SyntaxKind kind, DiagnosticInfo["[]"] diagnostics, int fullWidth)
            : base(kind, diagnostics, fullWidth)
        {
        }
^
        protected GreenSyntaxNode(SyntaxKind kind, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
            : base(kind, diagnostics, annotations)
        {
        }
^
        protected GreenSyntaxNode(SyntaxKind kind, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations, int fullWidth)
            : base(kind, diagnostics, annotations, fullWidth)
        {
        }
^
        protected GreenSyntaxNode(ObjectReader reader)
            : base(reader)
        {
        }
^
        public override TResult Accept<TResult>(InternalSyntaxVisitor<TResult> visitor)
        {
            if (visitor is [lang]SyntaxVisitor<TResult> typedVisitor) return this.Accept(typedVisitor);
            else return visitor.DefaultVisit(this);
        }
^
        public override void Accept(InternalSyntaxVisitor visitor) 
        {
            if (visitor is [lang]SyntaxVisitor typedVisitor) this.Accept(typedVisitor);
            else visitor.DefaultVisit(this);
        }
^
        public abstract TResult Accept<TResult>([lang]SyntaxVisitor<TResult> visitor);
        public abstract void Accept([lang]SyntaxVisitor visitor);
^
        public new [lang]Language Language => [lang]Language.Instance;
        protected override Language LanguageCore => this.Language;
        public new [lang]SyntaxKind Kind => ([lang]SyntaxKind)this.RawKind;
        protected override SyntaxKind KindCore => this.Kind;
^
		// Use conditional weak table so we always return same identity for structured trivia
		private static readonly ConditionalWeakTable<SyntaxNode, Dictionary<SyntaxTrivia, SyntaxNode>> s_structuresTable
			= new ConditionalWeakTable<SyntaxNode, Dictionary<SyntaxTrivia, SyntaxNode>>();
^
		/// <summary>
		/// Gets the syntax node represented the structure of this trivia, if any. The HasStructure property can be used to 
		/// determine if this trivia has structure.
		/// </summary>
		/// <returns>
		/// A [lang]SyntaxNode derived from StructuredTriviaSyntax, with the structured view of this trivia node. 
		/// If this trivia node does not have structure, returns null.
		/// </returns>
		/// <remarks>
		/// Some types of trivia have structure that can be accessed as additional syntax nodes.
		/// These forms of trivia include: 
		///   directives, where the structure describes the structure of the directive.
		///   documentation comments, where the structure describes the XML structure of the comment.
		///   skipped tokens, where the structure describes the tokens that were skipped by the parser.
		/// </remarks>
		public override SyntaxNode GetStructure(Microsoft.CodeAnalysis.SyntaxTrivia trivia)
		{
			if (trivia.HasStructure)
			{
				var parent = trivia.Token.Parent;
				if (parent != null)
				{
					SyntaxNode structure;
					var structsInParent = s_structuresTable.GetOrCreateValue(parent);
					lock (structsInParent)
					{
						if (!structsInParent.TryGetValue(trivia, out structure))
						{
							structure = [lang]StructuredTriviaSyntax.Create(trivia);
							structsInParent.Add(trivia, structure);
						}
					}
^
					return structure;
				}
				else
				{
					return [lang]StructuredTriviaSyntax.Create(trivia);
				}
			}
^
			return null;
		}
^
	}
^
    internal class GreenSyntaxTrivia : InternalSyntaxTrivia
    {
        internal GreenSyntaxTrivia([lang]SyntaxKind kind, string text, DiagnosticInfo["[]"] diagnostics = null, SyntaxAnnotation["[]"] annotations = null)
            : base(kind, text, diagnostics, annotations)
        {
        }
^
        internal GreenSyntaxTrivia(ObjectReader reader)
            : base(reader)
        {
        }
^
        static GreenSyntaxTrivia()
        {
            ObjectBinder.RegisterTypeReader(typeof(GreenSyntaxTrivia), r => new GreenSyntaxTrivia(r));
        }
^
        public new [lang]Language Language => [lang]Language.Instance;
        protected override Language LanguageCore => this.Language;
        public new [lang]SyntaxKind Kind => EnumObject.FromIntUnsafe<[lang]SyntaxKind>(this.RawKind);
        protected override SyntaxKind KindCore => this.Kind;
^
        protected override bool ShouldReuseInSerialization => this.Kind == Language.SyntaxFacts.DefaultWhitespaceKind &&
                                                             FullWidth < Language.SyntaxFacts.MaxCachedTokenSize;
^
        protected override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteString(this.Text);
        }
^
        internal static GreenSyntaxTrivia Create([lang]SyntaxKind kind, string text)
        {
            return new GreenSyntaxTrivia(kind, text);
        }
^
        public override InternalSyntaxNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
        {
            return new GreenSyntaxTrivia(this.Kind, this.Text, diagnostics, GetAnnotations());
        }
^
        public override InternalSyntaxNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
        {
            return new GreenSyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), annotations);
        }
^
        public override GreenNode Clone()
        {
			return new GreenSyntaxTrivia(this.Kind, this.Text, GetDiagnostics(), GetAnnotations());
		}
^
        public static implicit operator SyntaxTrivia(GreenSyntaxTrivia trivia)
        {
            return new SyntaxTrivia(default, trivia, position: 0, index: 0);
        }
    }
^
    internal abstract class GreenStructuredTriviaSyntax : GreenSyntaxNode
    {
        internal GreenStructuredTriviaSyntax([lang]SyntaxKind kind, DiagnosticInfo["[]"] diagnostics = null, SyntaxAnnotation["[]"] annotations = null)
            : base(kind, diagnostics, annotations)
        {
            this.Initialize();
        }
^
        internal GreenStructuredTriviaSyntax(ObjectReader reader)
            : base(reader)
        {
            this.Initialize();
        }
^
        private void Initialize()
        {
            this.flags |= NodeFlags.ContainsStructuredTrivia;
^
            if (this.Kind == SyntaxKind.SkippedTokensTrivia)
            {
                this.flags |= NodeFlags.ContainsSkippedText;
            }
        }
^
        public override bool IsStructuredTrivia => true;
    }
^
    internal sealed partial class GreenSkippedTokensTriviaSyntax : GreenStructuredTriviaSyntax
    {
        internal readonly GreenNode tokens;
^
        internal GreenSkippedTokensTriviaSyntax([lang]SyntaxKind kind, GreenNode tokens, DiagnosticInfo["[]"] diagnostics = null, SyntaxAnnotation["[]"] annotations = null)
            : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            if (tokens != null)
            {
                this.AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
        }
^
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<InternalSyntaxToken> Tokens => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<InternalSyntaxToken>(this.tokens);
^
        protected override GreenNode GetSlot(int index)
        {
            switch (index)
            {
                case 0: return this.tokens;
                default: return null;
            }
        }
^
        protected override SyntaxNode CreateRed(SyntaxNode parent, int position) => new [lang]SkippedTokensTriviaSyntax(this, ([lang]SyntaxNode)parent, position);
^
        public override TResult Accept<TResult>([lang]SyntaxVisitor<TResult> visitor) => visitor.VisitSkippedTokensTrivia(this);
^
        public override void Accept([lang]SyntaxVisitor visitor) => visitor.VisitSkippedTokensTrivia(this);
^
        public GreenSkippedTokensTriviaSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<InternalSyntaxToken> tokens)
        {
            if (tokens != this.Tokens)
            {
                var newNode = Language.InternalSyntaxFactory.SkippedTokensTrivia(tokens.Node);
                var diags = this.GetDiagnostics();
                if (diags != null && diags.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = this.GetAnnotations();
                if (annotations != null && annotations.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return (GreenSkippedTokensTriviaSyntax)newNode;
            }
            return this;
        }
^
		public override InternalSyntaxNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
		{
			return new GreenSkippedTokensTriviaSyntax(this.Kind, this.tokens, diagnostics, GetAnnotations());
		}
^
		public override InternalSyntaxNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
		{
			return new GreenSkippedTokensTriviaSyntax(this.Kind, this.tokens, GetDiagnostics(), annotations);
		}
^
        public override GreenNode Clone()
        {
			return new GreenSkippedTokensTriviaSyntax(this.Kind, this.tokens, GetDiagnostics(), GetAnnotations());
		}
^
        internal GreenSkippedTokensTriviaSyntax(ObjectReader reader)
            : base(reader)
        {
            this.SlotCount = 1;
            var tokens = (GreenNode)reader.ReadValue();
            if (tokens != null)
            {
                AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
        }
^
        protected override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.tokens);
        }
^
        static GreenSkippedTokensTriviaSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(GreenSkippedTokensTriviaSyntax), r => new GreenSkippedTokensTriviaSyntax(r));
        }
    }
^
	[GenerateGreenToken()]
	[loop(rule:Instances.ParserRules)]
	[GenerateInternalSyntaxRule(rule, null)]
	[end loop]
^
	[GenerateInternalSyntaxVisitor()]
	[GenerateInternalSyntaxFactory()]
}
end template


function string GetCompilationUnitInternal(Antlr4ParserRule rule)
	/*if (rule.HasEof())
		return ", ICompilationUnitInternalSyntax";
	else*/
		return "";
	//end if
end function

function string GetCompilationUnit(Antlr4ParserRule rule)
	if (rule.HasEof())
		return ", ICompilationUnitSyntax";
	else
		return "";
	end if
end function

function string GetInternalElemTypedParamList(Antlr4ParserRule rule, TypeKind kind, bool leadingComma = false, bool trailingComma = false)
	string result = "";
	if (rule.AllElements.Count == 0)
		return result;
	end if
	if (leadingComma)
		result = ", ";
	end if
	loop(elem:rule.AllElements; separator delim = ", ")
		result += elem.GreenType(kind) + " " + elem.FieldName() + delim;
	end loop
	if (trailingComma)
		result += ", ";
	end if
	return result;
end function

function string GetRoslynVisitorElemParamList(Antlr4ParserRule rule, bool leadingComma = false, bool trailingComma = false)
	string result = "";
	if (rule.AllElements.Count == 0)
		return result;
	end if
	if (leadingComma)
		result = ", ";
	end if
	loop(elem:rule.AllElements; separator delim = ", ")
		result += elem.FieldName();
		if (elem.IsList && elem.IsSeparated && elem.IsSimplified) 
			result += "?."+elem.Grammar.FindParserRule(elem.OriginalType).Elements[0].GreenName();
		end if
		result += delim;
	end loop
	if (trailingComma)
		result += ", ";
	end if
	return result;
end function

function string GetElemTypedParamList(Antlr4ParserRule rule, bool leadingComma = false, bool trailingComma = false, bool optional = false)
	string result = "";
	if (rule.AllElements.Count == 0)
		return result;
	end if
	if (leadingComma)
		result = ", ";
	end if
	loop(elem:rule.AllElements where !optional || !(elem.IsOptional || (elem.IsToken && elem.IsFixedToken && !elem.IsList)); separator delim = ", ")
		result += elem.RedType() + " " + elem.FieldName() + delim;
	end loop
	if (trailingComma)
		result += ", ";
	end if
	return result;
end function

function string GetInternalElemParamList(Antlr4ParserRule rule, bool listAsNode = false, bool leadingComma = false, bool trailingComma = false, string prefix = "this.", Antlr4ParserRuleElement skip = null)
	string result = "";
	if (rule.AllElements.Count == 0)
		return result;
	end if
	if (leadingComma)
		result = ", ";
	end if
	loop(elem:rule.AllElements; separator delim = ", ")
		string fieldName = elem.FieldName();
		if (elem.IsList && listAsNode)
			fieldName = fieldName+".Node";
		end if
		if (elem == skip)
			result += fieldName+delim;
		else
			result += prefix+fieldName+delim;
		end if
	end loop
	if (trailingComma)
		result += ", ";
	end if
	return result;
end function

function string GetElemDefaultParamList(Antlr4ParserRule rule, bool leadingComma = false, bool trailingComma = false)
	string result = "";
	if (rule.AllElements.Count == 0)
		return result;
	end if
	if (leadingComma)
		result = ", ";
	end if
	loop(elem:rule.AllElements; separator delim = ", ")
		result += "default"+delim;
	end loop
	if (trailingComma)
		result += ", ";
	end if
	return result;
end function

function string GetElemParamList(Antlr4ParserRule rule, bool leadingComma = false, bool trailingComma = false, string prefix = "this.", Antlr4ParserRuleElement skip = null)
	string result = "";
	if (rule.AllElements.Count == 0)
		return result;
	end if
	if (leadingComma)
		result = ", ";
	end if
	loop(elem:rule.AllElements; separator delim = ", ")
		if (elem == skip)
			result += elem.RedName()+delim;
		else
			result += prefix+elem.RedName()+delim;
		end if
	end loop
	if (trailingComma)
		result += ", ";
	end if
	return result;
end function

function string GetGreenConstructorSimpleAltParamList(Antlr4ParserRule rule, bool leadingComma = false, bool trailingComma = false, Antlr4ParserRuleElement include = null)
	string result = "";
	if (rule.AllElements.Count == 0)
		return result;
	end if
	if (leadingComma)
		result = ", ";
	end if
	loop(elem:rule.AllElements; separator delim = ", ")
		if (elem == include)
			result += elem.FieldName();
			if (elem.IsList)
				result += ".Node";
			end if
		else
			result += "null";
		end if
		result += delim;
	end loop
	if (trailingComma)
		result += ", ";
	end if
	return result;
end function

function string GetRedToGreenParamElem(Antlr4ParserRuleElement elem, string delim = "")
	string result = "";
	if (elem.IsOptional)
		if (!elem.IsList && !elem.IsToken)
			result += elem.FieldName() + " == null ? null : ";
		end if
	end if
	if (elem.IsList)
		if (elem.IsToken)
			result += "Microsoft.CodeAnalysis.Syntax.InternalSyntax.GreenNodeExtensions.ToGreenList<"+elem.GreenInnerType()+">("+elem.FieldName()+".Node)"+delim;
		else
			if (elem.IsSeparated)
				result += "Microsoft.CodeAnalysis.Syntax.InternalSyntax.GreenNodeExtensions.ToGreenSeparatedList<"+elem.GreenInnerType()+">("+elem.FieldName()+".Node)"+delim;
			else
				result += "Microsoft.CodeAnalysis.Syntax.InternalSyntax.GreenNodeExtensions.ToGreenList<"+elem.GreenInnerType()+">("+elem.FieldName()+".Node)"+delim;
			end if
		end if
	else
		if (elem.IsToken || (elem.IsBlock && elem.IsFixedTokenAltBlock))
			result += "(InternalSyntaxToken)"+elem.FieldName()+".Node"+delim;
		else
			result += "(Syntax.InternalSyntax."+elem.GreenType(TypeKind.Public)+")"+elem.FieldName()+".Green"+delim;
		end if
	end if
	return result;
end function

function string GetRedToGreenParamList(Antlr4ParserRule rule, bool leadingComma = false, bool trailingComma = false, bool optional = false)
	string result = "";
	if (rule.AllElements.Count == 0)
		return result;
	end if
	if (leadingComma)
		result = ", ";
	end if
	loop(elem:rule.AllElements; separator delim = ", ")
		if (optional && (elem.IsOptional || (elem.IsToken && elem.IsFixedToken && !elem.IsList)))
			if (elem.IsToken && elem.IsFixedToken && !elem.IsOptional)
				result += "this.Token("+Properties.LanguageName+"SyntaxKind."+elem.SyntaxKind()+")"+delim;
			else 
				result += "default"+delim;
			end if
		else
			if (optional)
				result += elem.FieldName()+delim;
			else
				result += GetRedToGreenParamElem(elem, delim);
			end if
		end if
	end loop
	if (trailingComma)
		result += ", ";
	end if
	return result;
end function

function string GetInternalElemUpdateList(Antlr4ParserRule rule)
	string result = "";
	loop(elem:rule.AllElements; separator delim = " ||\n\t\t\t")
		if (elem.IsList)
			result += "this."+elem.GreenName()+" != "+elem.FieldName()/*+".Node"*/+delim;
		else
			result += "this."+elem.GreenName()+" != "+elem.FieldName()+delim;
		end if
	end loop
	return result;
end function

function string GetElemUpdateList(Antlr4ParserRule rule)
	string result = "";
	loop(elem:rule.AllElements; separator delim = " ||\n\t\t\t")
		if (elem.IsList && !elem.IsToken)
			result += "this."+elem.RedName()+" != "+elem.FieldName()+delim;
		else
			result += "this."+elem.RedName()+" != "+elem.FieldName()+delim;
		end if
	end loop
	return result;
end function

template GenerateInternalSyntaxRule(Antlr4ParserRule rule, Antlr4ParserRule superRule)
[if (rule.Alternatives.Count > 0)]
^
internal abstract class [rule.GreenName()] : GreenSyntaxNode
{
	[if (rule.FirstNonAbstractAlternative != null)]
    internal static readonly [rule.GreenName()] __Missing = [rule.FirstNonAbstractAlternative.GreenName()].__Missing;
	[end if]
^
    public [rule.GreenName()]([Properties.LanguageName]SyntaxKind kind, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
        : base(kind, diagnostics, annotations)
    {
		this.SlotCount = [rule.AllElements.Count];
    }
}
	[loop(alt:rule.Alternatives)]
[GenerateInternalSyntaxRule(alt, rule)]
	[end loop]
[else]
^
	[if (superRule != null)]
internal class [rule.GreenName()] : [superRule.GreenName()][GetCompilationUnitInternal(rule)]
	[else]
internal class [rule.GreenName()] : GreenSyntaxNode[GetCompilationUnitInternal(rule)]
	[end if]
{
	[if (rule.ParentRule != null && rule.ParentRule.Alternatives.Count > 0)]
    internal static new readonly [rule.GreenName()] __Missing = new [rule.GreenName()]();
	[else]
    internal static readonly [rule.GreenName()] __Missing = new [rule.GreenName()]();
	[end if]
	
	[loop(elem:rule.AllElements)]
    private [elem.GreenType(TypeKind.Field)] [elem.FieldName()];
	[end loop]
^
    public [rule.GreenName()]([Properties.LanguageName]SyntaxKind kind[GetInternalElemTypedParamList(rule, TypeKind.Field, true)])
        : base(kind, null, null)
    {
		this.SlotCount = [rule.AllElements.Count];
		[loop(elem:rule.AllElements)]
		if ([elem.FieldName()] != null)
		{
			this.AdjustFlagsAndWidth([elem.FieldName()]);
			this.[elem.FieldName()] = [elem.FieldName()];
		}
		[end loop]
    }
^
    public [rule.GreenName()]([Properties.LanguageName]SyntaxKind kind[GetInternalElemTypedParamList(rule, TypeKind.Field, true)], DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
        : base(kind, diagnostics, annotations)
    {
		this.SlotCount = [rule.AllElements.Count];
		[loop(elem:rule.AllElements)]
		if ([elem.FieldName()] != null)
		{
			this.AdjustFlagsAndWidth([elem.FieldName()]);
			this.[elem.FieldName()] = [elem.FieldName()];
		}
		[end loop]
    }
^
	private [rule.GreenName()]()
		: base(([Properties.LanguageName]SyntaxKind)[Properties.LanguageName]SyntaxKind.[rule.PlainName()], null, null)
	{
		this.flags &= ~NodeFlags.IsNotMissing;
	}
^
	[loop(elem:rule.AllElements)]
		[if (elem.IsList)]
    public [elem.GreenType(TypeKind.Public)] [elem.GreenName()] { get { return new [elem.GreenType(TypeKind.Public)](this.[elem.FieldName()]); } }
		[else]
    public [elem.GreenType(TypeKind.Public)] [elem.GreenName()] { get { return this.[elem.FieldName()]; } }
		[end if]
	[end loop]
^
    protected override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
        return new global::[Properties.DefaultNamespace].Syntax.[rule.RedName()](this, ([Properties.LanguageName]SyntaxNode)parent, position);
    }
^
    protected override GreenNode GetSlot(int index)
    {
        switch (index)
        {
			[loop(i:CompilerGeneratorUtils.Range(rule.AllElements.Count))]
            case [i]: return this.[rule.AllElements[i].FieldName()];
			[end loop]
            default: return null;
        }
    }
^
    public override TResult Accept<TResult>([Properties.LanguageName]SyntaxVisitor<TResult> visitor) => visitor.Visit[rule.GreenName()](this);
^
    public override void Accept([Properties.LanguageName]SyntaxVisitor visitor) => visitor.Visit[rule.GreenName()](this);
^
    public override InternalSyntaxNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
    {
        return new [rule.GreenName()](this.Kind, [GetInternalElemParamList(rule, false, false, true)]diagnostics, this.GetAnnotations());
    }
^
    public override InternalSyntaxNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
    {
        return new [rule.GreenName()](this.Kind, [GetInternalElemParamList(rule, false, false, true)]this.GetDiagnostics(), annotations);
    }
^
    public override GreenNode Clone()
    {
		return new [rule.GreenName()](this.Kind, [GetInternalElemParamList(rule, false, false, true)]this.GetDiagnostics(), this.GetAnnotations());
	}
^
	[if (rule.IsSimpleAlt)]
		[loop(elem:rule.Elements)]
^
    public [rule.GreenName()] Update([elem.GreenType(TypeKind.Public)] [elem.FieldName()])
    {
        [if (elem.IsList)]
        if (this.[elem.FieldName()] != [elem.FieldName()].Node)
        [else]
        if (this.[elem.FieldName()] != [elem.FieldName()])
        [end if]
        {
            InternalSyntaxNode newNode = [Properties.LanguageName]Language.Instance.InternalSyntaxFactory.[rule.PlainName()]([elem.FieldName()]);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
			return ([rule.GreenName()])newNode;
        }
        return this;
    }
		[end loop]
	[else]
^
    public [rule.GreenName()] Update([GetInternalElemTypedParamList(rule, TypeKind.Public)])
    {
        if ([GetInternalElemUpdateList(rule)])
        {
            InternalSyntaxNode newNode = [Properties.LanguageName]Language.Instance.InternalSyntaxFactory.[rule.PlainName()]([GetInternalElemParamList(rule, false, false, false, "")]);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnostics(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
			return ([rule.GreenName()])newNode;
        }
        return this;
    }
	[end if]
}
[end if]
end template

template GenerateInternalSyntaxVisitor()
internal class [Properties.LanguageName]SyntaxVisitor : InternalSyntaxVisitor
{
	public virtual void VisitSkippedTokensTrivia(GreenSkippedTokensTriviaSyntax node) => this.DefaultVisit(node);
[loop(rule:Instances.ParserRules)]
	[if (rule.Alternatives.Count > 0)]
		[loop(alt:rule.Alternatives)]
	public virtual void Visit[alt.GreenName()]([alt.GreenName()] node) => this.DefaultVisit(node);
		[end loop]
	[else]
	public virtual void Visit[rule.GreenName()]([rule.GreenName()] node) => this.DefaultVisit(node);
	[end if]
[end loop]
}
^
internal class [Properties.LanguageName]SyntaxVisitor<TResult> : InternalSyntaxVisitor<TResult>
{
	public virtual TResult VisitSkippedTokensTrivia(GreenSkippedTokensTriviaSyntax node) => this.DefaultVisit(node);
[loop(rule:Instances.ParserRules)]
	[if (rule.Alternatives.Count > 0)]
		[loop(alt:rule.Alternatives)]
	public virtual TResult Visit[alt.GreenName()]([alt.GreenName()] node) => this.DefaultVisit(node);
		[end loop]
	[else]
	public virtual TResult Visit[rule.GreenName()]([rule.GreenName()] node) => this.DefaultVisit(node);
	[end if]
[end loop]
}
end template


template GenerateInternalSyntaxFactory()
[var lang = Properties.LanguageName]
internal class [lang]InternalSyntaxFactory : InternalSyntaxFactory, global::MetaDslx.Languages.Antlr4Roslyn.Syntax.InternalSyntax.IAntlr4SyntaxFactory
{
	public [lang]InternalSyntaxFactory([lang]SyntaxFacts syntaxFacts) 
	    : base(syntaxFacts)
	{
	}
^
    public global::MetaDslx.Languages.Antlr4Roslyn.Syntax.InternalSyntax.Antlr4Lexer CreateAntlr4Lexer(Antlr4.Runtime.ICharStream input)
    {
        return new [lang]Lexer(input);
    }
^
    public global::MetaDslx.Languages.Antlr4Roslyn.Syntax.InternalSyntax.Antlr4Parser CreateAntlr4Parser(Antlr4.Runtime.ITokenStream input)
    {
        return new [lang]Parser(input);
    }
^
	public override SyntaxLexer CreateLexer(SourceText text, LanguageParseOptions? options)
	{
		return new [lang]SyntaxLexer(text, ([lang]ParseOptions)(options ?? [lang]ParseOptions.Default));
	}
^	
	public override SyntaxParser CreateParser(SourceText text, LanguageParseOptions? options, LanguageSyntaxNode? oldTree, ParseData? oldParseData, IEnumerable<TextChangeRange>? changes, CancellationToken cancellationToken = default)
	{
		return new [lang]SyntaxParser(text, ([lang]ParseOptions)(options ?? [lang]ParseOptions.Default), ([lang]SyntaxNode?)oldTree, oldParseData, changes, cancellationToken);
	}
^
	private [lang]SyntaxKind To[lang]SyntaxKind(SyntaxKind kind)
    {
        return kind.CastUnsafe<[lang]SyntaxKind>();
    }
^
    public override InternalSyntaxTrivia Trivia(SyntaxKind kind, string text, bool elastic = false)
    {
        var trivia = GreenSyntaxTrivia.Create(To[lang]SyntaxKind(kind), text);
        if (!elastic)
        {
            return trivia;
        }
        return trivia.WithAnnotationsGreen(new["[]"] { SyntaxAnnotation.ElasticAnnotation });
    }
^
    public override InternalSyntaxTrivia ConflictMarker(string text)
    {
        return GreenSyntaxTrivia.Create(To[lang]SyntaxKind(SyntaxKind.ConflictMarkerTrivia), text);
    }
^
    public override InternalSyntaxTrivia DisabledText(string text)
    {
        return GreenSyntaxTrivia.Create(To[lang]SyntaxKind(SyntaxKind.DisabledTextTrivia), text);
    }
^
	public override InternalSyntaxNode SkippedTokensTrivia(GreenNode token)
	{
		return new GreenSkippedTokensTriviaSyntax(To[lang]SyntaxKind(SyntaxKind.SkippedTokensTrivia), token);
	}
^
    public override InternalSyntaxToken Token(SyntaxKind kind)
    {
        return GreenSyntaxToken.Create(To[lang]SyntaxKind(kind));
    }
^
    public override InternalSyntaxToken Token(GreenNode leading, SyntaxKind kind, GreenNode trailing)
    {
        return GreenSyntaxToken.Create(To[lang]SyntaxKind(kind), leading, trailing);
    }
^
    public override InternalSyntaxToken Token(GreenNode leading, SyntaxKind kind, string text, GreenNode trailing)
    {
		[lang]SyntaxKind typedKind = To[lang]SyntaxKind(kind);
        Debug.Assert([lang]Language.Instance.SyntaxFacts.IsToken(typedKind));
        string defaultText = [lang]Language.Instance.SyntaxFacts.GetText(typedKind);
        return typedKind >= GreenSyntaxToken.FirstTokenWithWellKnownText && typedKind <= GreenSyntaxToken.LastTokenWithWellKnownText && text == defaultText
            ? Token(leading, kind, trailing)
            : GreenSyntaxToken.Identifier(typedKind, leading, text, trailing);
    }
^
    public override InternalSyntaxToken Token(GreenNode leading, SyntaxKind kind, string text, string valueText, GreenNode trailing)
    {
		[lang]SyntaxKind typedKind = To[lang]SyntaxKind(kind);
        Debug.Assert([lang]Language.Instance.SyntaxFacts.IsToken(typedKind));
        string defaultText = [lang]Language.Instance.SyntaxFacts.GetText(typedKind);
        return typedKind >= GreenSyntaxToken.FirstTokenWithWellKnownText && typedKind <= GreenSyntaxToken.LastTokenWithWellKnownText && text == defaultText && valueText == defaultText
            ? Token(leading, kind, trailing)
            : GreenSyntaxToken.WithValue(typedKind, leading, text, valueText, trailing);
    }
^
    public override InternalSyntaxToken Token(GreenNode leading, SyntaxKind kind, string text, object value, GreenNode trailing)
    {
		[lang]SyntaxKind typedKind = To[lang]SyntaxKind(kind);
        Debug.Assert([lang]Language.Instance.SyntaxFacts.IsToken(typedKind));
        string defaultText = [lang]Language.Instance.SyntaxFacts.GetText(typedKind);
        return typedKind >= GreenSyntaxToken.FirstTokenWithWellKnownText && typedKind <= GreenSyntaxToken.LastTokenWithWellKnownText && text == defaultText && defaultText.Equals(value)
            ? Token(leading, kind, trailing)
            : GreenSyntaxToken.WithValue(typedKind, leading, text, value, trailing);
    }
^
    public override InternalSyntaxToken MissingToken(SyntaxKind kind)
    {
        return GreenSyntaxToken.CreateMissing(To[lang]SyntaxKind(kind), null, null);
    }
^
    public override InternalSyntaxToken MissingToken(GreenNode leading, SyntaxKind kind, GreenNode trailing)
    {
        return GreenSyntaxToken.CreateMissing(To[lang]SyntaxKind(kind), leading, trailing);
    }
^
    public override InternalSyntaxToken BadToken(GreenNode leading, string text, GreenNode trailing)
    {
        return GreenSyntaxToken.WithValue(To[lang]SyntaxKind(SyntaxKind.BadToken), leading, text, text, trailing);
    }
^
    public override IEnumerable<InternalSyntaxToken> GetWellKnownTokens()
    {
        return GreenSyntaxToken.GetWellKnownTokens();
    }
^
[loop(rule:Instances.LexerRules where rule.FixedToken == null)]
^
    internal InternalSyntaxToken [rule.PlainName()](string text)
    {
        return Token(null, [lang]SyntaxKind.[rule.PlainName()], text, null);
    }
^
    internal InternalSyntaxToken [rule.PlainName()](string text, object value)
    {
        return Token(null, [lang]SyntaxKind.[rule.PlainName()], text, value, null);
    }
[end loop]
[loop(rule:Instances.ParserRules)]
	[if (rule.Alternatives.Count > 0)]
		[loop(alt:rule.Alternatives)]
[GenerateInternalSyntaxFactoryCreate(alt)]
		[end loop]
	[else]
[GenerateInternalSyntaxFactoryCreate(rule)]
	[end if]
[end loop]
^
    internal static IEnumerable<Type> GetNodeTypes()
    {
        return new Type["[]"] {
[loop(rule:Instances.ParserRules)]
	[if (rule.Alternatives.Count > 0)]
		[loop(alt:rule.Alternatives)]
			typeof([alt.GreenName()]),
		[end loop]
	[else]
			typeof([rule.GreenName()]),
	[end if]
[end loop]
		};
	}
}
end template

template GenerateInternalSyntaxFactoryCreate(Antlr4ParserRule rule)
[if (rule.IsSimpleAlt)]
	[loop(elem:rule.Elements)]
^
	public [rule.GreenName()] [rule.PlainName()]([elem.GreenType(TypeKind.Public)] [elem.FieldName()])
    {
#if DEBUG
		[if (!elem.IsOptional)]
			[if (!elem.IsList)]
	    if ([elem.FieldName()] == null) throw new ArgumentNullException(nameof([elem.FieldName()]));
			[end if]
			[if (elem.IsToken && !elem.IsList)]
		if ([elem.FieldName()].Kind != [Properties.LanguageName]SyntaxKind.[elem.SyntaxKind()]) throw new ArgumentException(nameof([elem.FieldName()]));
			[end if]
		[else]
			[if (elem.IsToken && !elem.IsList)]
		if ([elem.FieldName()] != null && [elem.FieldName()].Kind != [Properties.LanguageName]SyntaxKind.[elem.SyntaxKind()]) throw new ArgumentException(nameof([elem.FieldName()]));
			[end if]
		[end if]
#endif
		[if (rule.Elements.Count <= 3)]
		int hash;
		[if (elem.IsList)]
		var cached = SyntaxNodeCache.TryGetNode((int)([Properties.LanguageName]SyntaxKind)[Properties.LanguageName]SyntaxKind.[rule.PlainName()], [elem.FieldName()].Node, out hash);
		[else]
		var cached = SyntaxNodeCache.TryGetNode((int)([Properties.LanguageName]SyntaxKind)[Properties.LanguageName]SyntaxKind.[rule.PlainName()], [elem.FieldName()], out hash);
		[end if]
		if (cached != null) return ([rule.GreenName()])cached;
		
		var result = new [rule.GreenName()]([Properties.LanguageName]SyntaxKind.[rule.PlainName()][GetGreenConstructorSimpleAltParamList(rule, true, false, elem)]);
		if (hash >= 0)
		{
			SyntaxNodeCache.AddNode(result, hash);
		}
		return result;
		[else]
		return new [rule.GreenName()]([Properties.LanguageName]SyntaxKind.[rule.PlainName()][GetGreenConstructorSimpleAltParamList(rule, true, false, elem)]);
		[end if]
    }
	[end loop]
[else]
^
	public [rule.GreenName()] [rule.PlainName()]([GetInternalElemTypedParamList(rule, TypeKind.Public, false, false)])
    {
#if DEBUG
		[loop(elem:rule.AllElements)]
			[if (!elem.IsOptional)]
				[if (!elem.IsList)]
		if ([elem.FieldName()] == null) throw new ArgumentNullException(nameof([elem.FieldName()]));
				[end if]
				[if (elem.IsToken && !elem.IsList)]
		if ([elem.FieldName()].Kind != [Properties.LanguageName]SyntaxKind.[elem.SyntaxKind()]) throw new ArgumentException(nameof([elem.FieldName()]));
				[end if]
			[else]
				[if (elem.IsToken && !elem.IsList)]
		if ([elem.FieldName()] != null && [elem.FieldName()].Kind != [Properties.LanguageName]SyntaxKind.[elem.SyntaxKind()]) throw new ArgumentException(nameof([elem.FieldName()]));
				[end if]
			[end if]
		[end loop]
#endif
		[if (rule.AllElements.Count <= 3)]
		int hash;
		var cached = SyntaxNodeCache.TryGetNode((int)([Properties.LanguageName]SyntaxKind)[Properties.LanguageName]SyntaxKind.[rule.PlainName()][GetInternalElemParamList(rule, true, true, false, "")], out hash);
		if (cached != null) return ([rule.GreenName()])cached;
		
		var result = new [rule.GreenName()]([Properties.LanguageName]SyntaxKind.[rule.PlainName()][GetInternalElemParamList(rule, true, true, false, "")]);
		if (hash >= 0)
		{
			SyntaxNodeCache.AddNode(result, hash);
		}
		
		return result;
		[else]
        return new [rule.GreenName()]([Properties.LanguageName]SyntaxKind.[rule.PlainName()][GetInternalElemParamList(rule, true, true, false, "")]);
		[end if]
    }
[end if]
end template

template GenerateSyntaxKind(bool forParser, string className, string baseClassName)
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MetaDslx.CodeAnalysis.Syntax;
using Roslyn.Utilities;
^
namespace [Properties.DefaultNamespace].Syntax
{
	public class [className] : [baseClassName]
	{
		[if (!forParser)]
			[if(hasloop(rule:Instances.LexerRules where rule.Kind > 0))]
        public static readonly [className] __FirstToken;
        public static readonly int __FirstTokenValue;
        public static readonly [className] __LastToken;
        public static readonly int __LastTokenValue;
        public static readonly [className] __FirstFixedToken;
        public static readonly int __FirstFixedTokenValue;
        public static readonly [className] __LastFixedToken;
        public static readonly int __LastFixedTokenValue;
^
		// Tokens:
			[loop(rule:Instances.LexerRules where rule.Kind > 0)]
		public const string [rule.PlainName()] = nameof([rule.PlainName()]); // [rule.Kind]
			[end loop]
			[end if]
		[else]
			[if(hasloop(rule:Instances.ParserRules))]
        public static new readonly [className] __FirstToken;
        public static new readonly [className] __LastToken;
        public static new readonly [className] __FirstFixedToken;
        public static new readonly [className] __LastFixedToken;
        public static readonly [className] __FirstRule;
        public static readonly int __FirstRuleValue;
        public static readonly [className] __LastRule;
        public static readonly int __LastRuleValue;
^
		// Rules:
			[loop(rule:Instances.ParserRules)]
			[if (rule.Alternatives.Count > 0)]
				[loop(alt:rule.Alternatives)]
		public const string [alt.PlainName()] = nameof([alt.PlainName()]);
				[end loop]
			[else]
		public const string [rule.PlainName()] = nameof([rule.PlainName()]);
			[end if]
			[end loop]
			[end if]
		[end if]
^
		protected [className](string name)
            : base(name)
        {
        }
^
        protected [className](EnumObject retargetedValue)
            : base(retargetedValue)
        {
        }
^
        static [className]()
        {
            EnumObject.AutoInit<[className]>();
			[if(!forParser && hasloop(rule:Instances.LexerRules where rule.Kind > 0))]
            __FirstToken = [Instances.FirstTokenSyntaxKind.PlainName()];
			__FirstTokenValue = (int)__FirstToken;
            __LastToken = [Instances.LastTokenSyntaxKind.PlainName()];
			__LastTokenValue = (int)__LastToken;
            __FirstFixedToken = [Instances.FirstFixedTokenSyntaxKind.PlainName()];
			__FirstFixedTokenValue = (int)__FirstFixedToken;
            __LastFixedToken = [Instances.LastFixedTokenSyntaxKind.PlainName()];
			__LastFixedTokenValue = (int)__LastFixedToken;
			[end if]
			[if(forParser && hasloop(rule:Instances.ParserRules))]
            __FirstToken = [Instances.FirstTokenSyntaxKind.PlainName()];
            __LastToken = [Instances.LastTokenSyntaxKind.PlainName()];
            __FirstFixedToken = [Instances.FirstFixedTokenSyntaxKind.PlainName()];
            __LastFixedToken = [Instances.LastFixedTokenSyntaxKind.PlainName()];
            __FirstRule = [Instances.FirstParserRuleSyntaxKind.PlainName()];
			__FirstRuleValue = (int)__FirstRule;
            __LastRule = [Instances.LastParserRuleSyntaxKind.PlainName()];
			__LastRuleValue = (int)__LastRule;
			[end if]
        }
^
        public static implicit operator [className](string name)
        {
            return FromString<[className]>(name);
        }
^
        public static explicit operator [className](int value)
        {
            return FromIntUnsafe<[className]>(value);
        }
^
	}
}
end template

template GenerateSyntax()
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Syntax;
using MetaDslx.CodeAnalysis.Syntax.InternalSyntax;
^
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace].Syntax
{
    public abstract class [lang]SyntaxNode : LanguageSyntaxNode
    {
        protected [lang]SyntaxNode(InternalSyntaxNode green, [lang]SyntaxTree syntaxTree, int position)
            : base(green, syntaxTree, position)
        {
        }
^
        protected [lang]SyntaxNode(InternalSyntaxNode green, [lang]SyntaxNode parent, int position)
            : base(green, parent, position)
        {
        }
^
        public new [lang]Language Language => [lang]Language.Instance;
        protected override Language LanguageCore => this.Language;
        public new [lang]SyntaxKind Kind => ([lang]SyntaxKind)this.RawKind;
        protected override SyntaxKind KindCore => this.Kind;
^
        protected override SyntaxTree CreateSyntaxTreeForRoot()
        {
            return [lang]SyntaxTree.CreateWithoutClone(this);
        }
^
        public override TResult Accept<TArg, TResult>(SyntaxVisitor<TArg, TResult> visitor, TArg argument)
        {
            if (visitor is I[lang]SyntaxVisitor<TArg, TResult> typedVisitor) return this.Accept(typedVisitor, argument);
            else return visitor.DefaultVisit(this, argument);
        }
^
        public abstract TResult Accept<TArg, TResult>(I[lang]SyntaxVisitor<TArg, TResult> visitor, TArg argument);
^
        public override TResult Accept<TResult>(SyntaxVisitor<TResult> visitor)
        {
            if (visitor is I[lang]SyntaxVisitor<TResult> typedVisitor) return this.Accept(typedVisitor);
            else return visitor.DefaultVisit(this);
        }
^
        public abstract TResult Accept<TResult>(I[lang]SyntaxVisitor<TResult> visitor);
^
        public override void Accept(SyntaxVisitor visitor)
        {
            if (visitor is I[lang]SyntaxVisitor typedVisitor) this.Accept(typedVisitor);
            else visitor.DefaultVisit(this);
        }

        public abstract void Accept(I[lang]SyntaxVisitor visitor);
    }
^
    /// <summary>
    /// It's a non terminal Trivia [lang]SyntaxNode that has a tree underneath it.
    /// </summary>
    public abstract partial class [lang]StructuredTriviaSyntax : [lang]SyntaxNode, IStructuredTriviaSyntax
    {
        private SyntaxTrivia _parent;

        internal [lang]StructuredTriviaSyntax(InternalSyntaxNode green, [lang]SyntaxNode parent, int position)
            : base(green, parent == null ? null : ([lang]SyntaxTree)parent.SyntaxTree, position)
        {
            System.Diagnostics.Debug.Assert(parent == null || position >= 0);
        }

		internal static [lang]StructuredTriviaSyntax Create(SyntaxTrivia trivia)
		{
			var red = ([lang]StructuredTriviaSyntax)[lang]Language.Instance.SyntaxFactory.CreateStructure(trivia);
			red._parent = trivia;
			return red;
		}

        /// <summary>
        /// Get parent trivia.
        /// </summary>
        public override SyntaxTrivia ParentTrivia => _parent;
    }
^
    public sealed partial class [lang]SkippedTokensTriviaSyntax : [lang]StructuredTriviaSyntax
    {
        internal [lang]SkippedTokensTriviaSyntax(InternalSyntaxNode green, [lang]SyntaxNode parent, int position)
            : base(green, parent, position)
        {
        }
^
        public SyntaxTokenList Tokens 
        {
            get
            {
				var slot = ((global::[Properties.DefaultNamespace].Syntax.InternalSyntax.GreenSkippedTokensTriviaSyntax)this.Green).Tokens;
				if (slot != null)
				{
					return new SyntaxTokenList(this, slot.Node, this.GetChildPosition(0), this.GetChildIndex(0));
				}
                return default;
            }
        }
^
        public override SyntaxNode GetNodeSlot(int index)
        {
            switch (index)
            {
                default: return null;
            }
        }
^
		public override SyntaxNode GetCachedSlot(int index)
        {
            switch (index)
            {
                default: return null;
            }
        }
^
		public override TResult Accept<TArg, TResult>(I[lang]SyntaxVisitor<TArg, TResult> visitor, TArg argument)
		{
			return visitor.VisitSkippedTokensTrivia(this, argument);
		}
^
		public override TResult Accept<TResult>(I[lang]SyntaxVisitor<TResult> visitor)
        {
            return visitor.VisitSkippedTokensTrivia(this);
        }
^
        public override void Accept(I[lang]SyntaxVisitor visitor)
        {
            visitor.VisitSkippedTokensTrivia(this);
        }
^
        public [lang]SkippedTokensTriviaSyntax Update(SyntaxTokenList tokens)
        {
            if (tokens != this.Tokens)
            {
                var newNode = ([lang]SkippedTokensTriviaSyntax)Language.SyntaxFactory.SkippedTokensTrivia(tokens);
                var annotations = this.GetAnnotations();
                if (annotations != null && annotations.Length > 0)
                    return newNode.WithAnnotations(annotations);
                return newNode;
            }
            return this;
        }
^
        public [lang]SkippedTokensTriviaSyntax WithTokens(SyntaxTokenList tokens)
        {
            return this.Update(tokens);
        }
^
        public [lang]SkippedTokensTriviaSyntax AddTokens(params SyntaxToken["[]"] items)
        {
            return this.WithTokens(this.Tokens.AddRange(items));
        }
    }
^
	[loop(rule:Instances.ParserRules)]
	[GenerateSyntaxRule(rule, null)]
	[end loop]
}
^
namespace [Properties.DefaultNamespace]
{
    using System.Threading;
    using Microsoft.CodeAnalysis.Text;
	using [Properties.DefaultNamespace].Syntax;
    using [Properties.DefaultNamespace].Syntax.InternalSyntax;
^
	[GenerateSyntaxVisitor()]
^
	//GenerateDetailedSyntaxVisitor()
^
	[GenerateSyntaxTypedArgVisitor()]
^
	[GenerateSyntaxTypedVisitor()]
^
	[GenerateSyntaxRewriter()]
^
	[GenerateSyntaxFactory()]
}
end template

template GenerateSyntaxRule(Antlr4ParserRule rule, Antlr4ParserRule superRule)
[var lang = Properties.LanguageName]
[if (rule.Alternatives.Count > 0)]
^
public abstract class [rule.RedName()] : [lang]SyntaxNode
{
    protected [rule.RedName()](InternalSyntaxNode green, [lang]SyntaxTree syntaxTree, int position)
        : base(green, syntaxTree, position)
    {
    }
^
    protected [rule.RedName()](InternalSyntaxNode green, [lang]SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }
}
	[loop(alt:rule.Alternatives)]
[GenerateSyntaxRule(alt, rule)]
	[end loop]
[else]
^
	[if (superRule != null)]
public sealed class [rule.RedName()] : [superRule.RedName()][GetCompilationUnit(rule)]
	[else]
public sealed class [rule.RedName()] : [Properties.LanguageName]SyntaxNode[GetCompilationUnit(rule)]
	[end if]
{
	[loop(elem:rule.AllElements)]
		[if (elem.IsParserRule)]
    private [elem.RedFieldType()] [elem.FieldName()];
		[end if]
	[end loop]
^
    public [rule.RedName()](InternalSyntaxNode green, [lang]SyntaxTree syntaxTree, int position)
        : base(green, syntaxTree, position)
    {
    }
^
    public [rule.RedName()](InternalSyntaxNode green, [lang]SyntaxNode parent, int position)
        : base(green, parent, position)
    {
    }
^
	[loop(elem:rule.AllElements)]
		[if (elem.IsList)]
    public [elem.RedType()] [elem.RedName()] 
	{ 
		get
		{
			[if (elem.IsSeparated)]
			var red = this.GetRed(ref this.[elem.FieldName()], [rule.IndexOf(elem)]);
			if (red != null)
			{
				return new [elem.RedType()](red, this.GetChildIndex([rule.IndexOf(elem)]));
			}
			return default;
			[else if (elem.IsToken)]
			var green = (global::[Properties.DefaultNamespace].Syntax.InternalSyntax.[rule.GreenName()])this.Green;
			var greenTokens = green.[elem.GreenName()];
			if (greenTokens.Node != null)
			{
				return new [elem.RedType()](this, greenTokens.Node, this.GetChildPosition([rule.IndexOf(elem)]), this.GetChildIndex([rule.IndexOf(elem)]));
			}
			return default;
			[else]
			var red = this.GetRed(ref this.[elem.FieldName()], [rule.IndexOf(elem)]);
			if (red != null) return new [elem.RedType()](red);
			return default;
			[end if]
		} 
	}
		[else]
			[if (elem.IsToken || elem.IsFixedTokenAltBlock)]
    public [elem.RedType()] [elem.RedName()] 
	{ 
		get 
		{ 
			var green = (global::[Properties.DefaultNamespace].Syntax.InternalSyntax.[rule.GreenName()])this.Green;
			var greenToken = green.[elem.GreenName()];
			return new SyntaxToken(this, greenToken, this.GetChildPosition([rule.IndexOf(elem)]), this.GetChildIndex([rule.IndexOf(elem)]));
		}
	}
			[else]
    public [elem.RedType()] [elem.RedName()] 
	{ 
		get { return this.GetRed(ref this.[elem.FieldName()], [rule.IndexOf(elem)]); } 
	}
			[end if]
		[end if]
	[end loop]
^
    public override SyntaxNode GetNodeSlot(int index)
    {
        switch (index)
        {
			[loop(elem:rule.AllElements)]
				[if (elem.IsParserRule)]
			case [rule.IndexOf(elem)]: return this.GetRed(ref this.[elem.FieldName()], [rule.IndexOf(elem)]);
				[end if]
			[end loop]
			default: return null;
        }
    }
^
    public override SyntaxNode GetCachedSlot(int index)
    {
        switch (index)
        {
			[loop(elem:rule.AllElements)]
				[if (elem.IsParserRule)]
			case [rule.IndexOf(elem)]: return this.[elem.FieldName()];
				[end if]
			[end loop]
			default: return null;
        }
    }
	[loop(elem:rule.AllElements)]
^
    public [rule.RedName()] With[elem.RedName()]([elem.RedType()] [elem.FieldName()])
	{
		[if (rule.IsSimpleAlt)]
		return this.Update([elem.FieldName()]);
		[else]
		return this.Update([GetElemParamList(rule, false, false, "this.", elem)]);
		[end if]
	}
		[if (elem.IsList && !elem.IsToken)]
^
    public [rule.RedName()] Add[elem.RedName()](params [elem.RedInnerType()]["[]"] [elem.FieldName()])
	{
		return this.With[elem.RedName()](this.[elem.RedName()].AddRange([elem.FieldName()]));
	}
		[end if]
	[end loop]
	[if (rule.IsSimpleAlt)]
		[loop(elem:rule.Elements)]
^
    public [rule.RedName()] Update([elem.RedType()] [elem.FieldName()])
    {
        if (this.[elem.RedName()] != [elem.FieldName()])
        {
            var newNode = [Properties.LanguageName]Language.Instance.SyntaxFactory.[rule.PlainName()]([elem.FieldName()]);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
			return ([rule.RedName()])newNode;
        }
        return this;
    }
		[end loop]
	[else]
^
    public [rule.RedName()] Update([GetElemTypedParamList(rule)])
    {
        if ([GetElemUpdateList(rule)])
        {
            var newNode = [lang]Language.Instance.SyntaxFactory.[rule.PlainName()]([GetInternalElemParamList(rule, false, false, false, "")]);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotations(annotations);
			return ([rule.RedName()])newNode;
        }
        return this;
    }
	[end if]
^
    public override TResult Accept<TArg, TResult>(I[lang]SyntaxVisitor<TArg, TResult> visitor, TArg argument)
    {
        return visitor.Visit[rule.PlainName()](this, argument);
    }
^
    public override TResult Accept<TResult>(I[lang]SyntaxVisitor<TResult> visitor)
    {
        return visitor.Visit[rule.PlainName()](this);
    }
^
    public override void Accept(I[lang]SyntaxVisitor visitor)
    {
        visitor.Visit[rule.PlainName()](this);
    }
}
[end if]
end template

template GenerateTokenSyntaxFacts()
using System;
using System.Collections.Generic;
using System.Threading;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Syntax;
using Roslyn.Utilities;
^
[string className = Properties.LanguageName+"TokensSyntaxFacts"]
[string syntaxKind = Properties.LanguageName+"TokensSyntaxKind"]
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace].Syntax
{
	public enum [lang]TokenKind : int
	{
		None = 0,
		[loop (kind:Instances.LexerTokenKinds.Keys.OrderBy(k => k); separator sep=",")]
		[kind][sep]
		[end loop]
	}
^
	public enum [lang]LexerMode : int
	{
		None = 0,
		[loop (mode:Instances.LexerModes; separator sep=",")]
		[mode.PlainName()] = [mode.Kind][sep]
		[end loop]
	}
^
	public class [className] : SyntaxFacts
	{
        public [className]() 
            : base(typeof([syntaxKind]))
        {
        }
^
        protected [className](Type syntaxKindType) 
            : base(syntaxKindType)
        {
        }
^
        public override SyntaxKind DefaultWhitespaceKind => ([syntaxKind])[syntaxKind].[Instances.DefaultWhitespaceKind.PlainName()];
        public override SyntaxKind DefaultEndOfLineKind => ([syntaxKind])[syntaxKind].[Instances.DefaultEndOfLineKind.PlainName()];
        public override SyntaxKind DefaultSeparatorKind => ([syntaxKind])[syntaxKind].[Instances.DefaultSeparatorKind.PlainName()];
        public override SyntaxKind DefaultIdentifierKind => ([syntaxKind])[syntaxKind].[Instances.DefaultIdentifierKind.PlainName()];
^
		public override bool IsToken(SyntaxKind kind)
		{
			switch (kind.Switch())
			{
				case [syntaxKind].Eof:
				[loop(literal:Instances.LexerRules where literal.Kind > 0)]
				case [syntaxKind].[literal.PlainName()]:
				[end loop]
					return true;
				default:
					return false;
			}
		}
^
		public override bool IsFixedToken(SyntaxKind kind)
		{
			switch (kind.Switch())
			{
				[loop(literal:Instances.FixedTokens where literal.Kind > 0)]
				case [syntaxKind].[literal.PlainName()]:
				[end loop]
					return true;
				default:
					return false;
			}
		}
^
		public override SyntaxKind GetFixedTokenKind(string text)
		{
			switch (text)
			{
				[loop(literal:Instances.FixedTokens where literal.Kind > 0)]
				case [literal.FixedToken.FixedTokenToCSharpString()]:
					return [syntaxKind].[literal.PlainName()];
				[end loop]
				default:
					return [syntaxKind].None;
			}
		}
^
		public override string GetText(SyntaxKind kind)
		{
			switch (kind.Switch())
			{
				[loop(literal:Instances.FixedTokens where literal.Kind > 0)]
				case [syntaxKind].[literal.PlainName()]:
					return [literal.FixedToken.FixedTokenToCSharpString()];
				[end loop]
				default:
					return string.Empty;
			}
		}
^
		public [lang]TokenKind GetTokenKind(int rawKind)
		{
			return this.GetTokenKind(EnumObject.FromIntUnsafe<[syntaxKind]>(rawKind));
		}
^
		public [lang]TokenKind GetTokenKind(SyntaxKind kind)
		{
			switch(kind.Switch())
			{
			[loop (rule:Instances.LexerRules where rule.Kind > 0 && rule.Annotations.HasAnnotation("Token"))]
				[MetaCompilerAnnotation annot = rule.Annotations.GetAnnotation("Token")]
				[if (annot.GetValue("kind") != null)]
					[if (annot.HasProperty("first") && annot.HasProperty("last"))]
						[loop (child:Instances.LexerRulesBetween(annot.GetValue("first"), annot.GetValue("last")) where child.Kind > 0)]
				case [syntaxKind].[child.PlainName()]:
						[end loop]
					return [lang]TokenKind.[annot.GetValue("kind")];
					[else]
				case [syntaxKind].[rule.PlainName()]:
					return [lang]TokenKind.[annot.GetValue("kind")];
					[end if]
				[end if]
			[end loop]
				default:
					return [lang]TokenKind.None;
			}
		}
^
		public [lang]TokenKind GetModeTokenKind(int rawKind)
		{
			return this.GetModeTokenKind(([lang]LexerMode)rawKind);
		}
^
		public [lang]TokenKind GetModeTokenKind([lang]LexerMode kind)
		{
			switch(kind)
			{
			[loop (mode:Instances.LexerModes where mode.Annotations.HasAnnotation("Token"))]
				[MetaCompilerAnnotation annot = mode.Annotations.GetAnnotation("Token")]
				case [lang]LexerMode.[mode.PlainName()]:
					return [lang]TokenKind.[annot.GetValue("kind")];
			[end loop]
				default:
					return [lang]TokenKind.None;
			}
		}
^
		public override bool IsTriviaWithEndOfLine(SyntaxKind kind)
		{
			switch(kind.Switch())
			{
			[loop (rule:Instances.LexerRules where rule.Kind > 0 && rule.Annotations.HasAnnotation("Token"))]
				[MetaCompilerAnnotation annot = rule.Annotations.GetAnnotation("Token")]
				[if (annot.HasProperty("endOfLine") && annot.GetValue("endOfLine") == "true")]
					[if (annot.HasProperty("first") && annot.HasProperty("last"))]
						[loop (child:Instances.LexerRulesBetween(annot.GetValue("first"), annot.GetValue("last")) where child.Kind > 0)]
				case [syntaxKind].[child.PlainName()]:
						[end loop]
					return true;
					[else]
				case [syntaxKind].[rule.PlainName()]:
					return true;
					[end if]
				[end if]
			[end loop]
				default:
					return false;
			}
		}
^
	[loop (kind:Instances.LexerTokenKinds where kind.Key != "Token" && kind.Key != "FixedToken")]
		public[GenerateSyntaxFactsTokenKindOverride(kind.Key)] bool Is[kind.Key](SyntaxKind kind)
		{
			switch(kind.Switch())
			{
			[loop (rule:kind.Value where rule.Kind > 0)]
				[MetaCompilerAnnotation annot = rule.Annotations.GetAnnotation("Token")]
				[if (annot.HasProperty("first") && annot.HasProperty("last"))]
					[loop (child:Instances.LexerRulesBetween(annot.GetValue("first"), annot.GetValue("last")) where child.Kind > 0)]
				case [syntaxKind].[child.PlainName()]:
					[end loop]
					return true;
				[else]
				case [syntaxKind].[rule.PlainName()]:
					return true;
				[end if]
			[end loop]
				default:
					return false;
			}
		}
		[if (kind.Key == "ReservedKeyword" || kind.Key == "ContextualKeyword")]
^
        public override IEnumerable<SyntaxKind> Get[kind.Key]Kinds()
        {
			[if (hasloop(rule:kind.Value where rule.Kind > 0))]
			[loop (rule:kind.Value where rule.Kind > 0)]
				[MetaCompilerAnnotation annot = rule.Annotations.GetAnnotation("Token")]
				[if (annot.HasProperty("first") && annot.HasProperty("last"))]
					[loop (child:Instances.LexerRulesBetween(annot.GetValue("first"), annot.GetValue("last")) where child.Kind > 0)]
				yield return [syntaxKind].[child.PlainName()];
					[end loop]
				[end if]
			[end loop]
			[else]
			yield break;
			[end if]
        }
^
        public override SyntaxKind Get[kind.Key]Kind(string text)
        {
			switch(text)
			{
			[loop (rule:kind.Value where rule.Kind > 0)]
				[MetaCompilerAnnotation annot = rule.Annotations.GetAnnotation("Token")]
				[if (annot.HasProperty("first") && annot.HasProperty("last"))]
					[loop (child:Instances.LexerRulesBetween(annot.GetValue("first"), annot.GetValue("last")) where child.Kind > 0 && !string.IsNullOrWhiteSpace(child.FixedToken))]
				case [child.FixedToken.FixedTokenToCSharpString()]:
					return [syntaxKind].[child.PlainName()];
					[end loop]
				[else]
					[if (rule.Kind > 0 && !string.IsNullOrWhiteSpace(rule.FixedToken))]
				case [rule.FixedToken.FixedTokenToCSharpString()]:
					return [syntaxKind].[rule.PlainName()];
					[end if]
				[end if]
			[end loop]
				default:
					return SyntaxKind.None;
			}
        }
		[end if]
	[end loop]
	}
}
end template

template GenerateNodeSyntaxFacts()
using System;
using System.Collections.Generic;
using System.Threading;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Syntax;
using Roslyn.Utilities;
^
[string className = Properties.LanguageName+"SyntaxFacts"]
[string syntaxKind = Properties.LanguageName+"SyntaxKind"]
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace].Syntax
{
	public class [className] : [lang]TokensSyntaxFacts
	{
        public [className]() 
            : base(typeof([syntaxKind]))
        {
        }
^
		[if (Instances.MainRule() != null)]
        public override SyntaxKind CompilationUnitKind => ([syntaxKind])[syntaxKind].[Instances.MainRule().PlainName()];
		[end if]
	}
}
end template

template GenerateSyntaxFactsTokenKindOverride(string tokenKind)
[if (Instances.VirtualTokenKinds.Contains(tokenKind))]
 override
[end if]
end template

template GenerateSyntaxVisitor()
public interface I[Properties.LanguageName]SyntaxVisitor
{
    void VisitSkippedTokensTrivia([Properties.LanguageName]SkippedTokensTriviaSyntax node);
   	[loop(rule:Instances.ParserRules)]
		[if (rule.Alternatives.Count > 0)]
			[loop(alt:rule.Alternatives)]
	[GenerateSyntaxVisitorVisit(alt, true)]
			[end loop]
		[else]
	[GenerateSyntaxVisitorVisit(rule, true)]
		[end if]
	[end loop]
}
^
public class [Properties.LanguageName]SyntaxVisitor : SyntaxVisitor, I[Properties.LanguageName]SyntaxVisitor
{
    public virtual void VisitSkippedTokensTrivia([Properties.LanguageName]SkippedTokensTriviaSyntax node)
    {
        this.DefaultVisit(node);
    }
    [loop(rule:Instances.ParserRules)]
		[if (rule.Alternatives.Count > 0)]
			[loop(alt:rule.Alternatives)]
	[GenerateSyntaxVisitorVisit(alt, false)]
			[end loop]
		[else]
	[GenerateSyntaxVisitorVisit(rule, false)]
		[end if]
	[end loop]
}
end template

template GenerateSyntaxVisitorVisit(Antlr4ParserRule rule, bool intf)
^
[if (intf)]
void Visit[rule.PlainName()]([rule.RedName()] node);
[else]
public virtual void Visit[rule.PlainName()]([rule.RedName()] node)
{
    this.DefaultVisit(node);
}
[end if]
end template

template GenerateSyntaxTypedVisitor()
public interface I[Properties.LanguageName]SyntaxVisitor<TResult> 
{
    TResult VisitSkippedTokensTrivia([Properties.LanguageName]SkippedTokensTriviaSyntax node);
   	[loop(rule:Instances.ParserRules)]
		[if (rule.Alternatives.Count > 0)]
			[loop(alt:rule.Alternatives)]
	[GenerateSyntaxTypedVisitorVisit(alt, true)]
			[end loop]
		[else]
	[GenerateSyntaxTypedVisitorVisit(rule, true)]
		[end if]
	[end loop]
}
^
public class [Properties.LanguageName]SyntaxVisitor<TResult> : SyntaxVisitor<TResult>, I[Properties.LanguageName]SyntaxVisitor<TResult>
{
    public virtual TResult VisitSkippedTokensTrivia([Properties.LanguageName]SkippedTokensTriviaSyntax node)
    {
        return this.DefaultVisit(node);
    }
   	[loop(rule:Instances.ParserRules)]
		[if (rule.Alternatives.Count > 0)]
			[loop(alt:rule.Alternatives)]
	[GenerateSyntaxTypedVisitorVisit(alt, false)]
			[end loop]
		[else]
	[GenerateSyntaxTypedVisitorVisit(rule, false)]
		[end if]
	[end loop]
}
end template

template GenerateSyntaxTypedVisitorVisit(Antlr4ParserRule rule, bool intf)
^
[if (intf)]
TResult Visit[rule.PlainName()]([rule.RedName()] node);
[else]
public virtual TResult Visit[rule.PlainName()]([rule.RedName()] node)
{
    return this.DefaultVisit(node);
}
[end if]
end template

template GenerateSyntaxTypedArgVisitor()
public interface I[Properties.LanguageName]SyntaxVisitor<TArg, TResult> 
{
    TResult VisitSkippedTokensTrivia([Properties.LanguageName]SkippedTokensTriviaSyntax node, TArg argument);
   	[loop(rule:Instances.ParserRules)]
		[if (rule.Alternatives.Count > 0)]
			[loop(alt:rule.Alternatives)]
	[GenerateSyntaxTypedArgVisitorVisit(alt, true)]
			[end loop]
		[else]
	[GenerateSyntaxTypedArgVisitorVisit(rule, true)]
		[end if]
	[end loop]
}
^
public class [Properties.LanguageName]SyntaxVisitor<TArg, TResult> : SyntaxVisitor<TArg, TResult>, I[Properties.LanguageName]SyntaxVisitor<TArg, TResult>
{
    public virtual TResult VisitSkippedTokensTrivia([Properties.LanguageName]SkippedTokensTriviaSyntax node, TArg argument)
    {
        return this.DefaultVisit(node, argument);
    }
   	[loop(rule:Instances.ParserRules)]
		[if (rule.Alternatives.Count > 0)]
			[loop(alt:rule.Alternatives)]
	[GenerateSyntaxTypedArgVisitorVisit(alt, false)]
			[end loop]
		[else]
	[GenerateSyntaxTypedArgVisitorVisit(rule, false)]
		[end if]
	[end loop]
}
end template

template GenerateSyntaxTypedArgVisitorVisit(Antlr4ParserRule rule, bool intf)
^
[if (intf)]
TResult Visit[rule.PlainName()]([rule.RedName()] node, TArg argument);
[else]
public virtual TResult Visit[rule.PlainName()]([rule.RedName()] node, TArg argument)
{
    return this.DefaultVisit(node, argument);
}
[end if]
end template

template GenerateDetailedSyntaxVisitor()
public class [Properties.LanguageName]DetailedSyntaxVisitor : DetailedSyntaxVisitor, I[Properties.LanguageName]SyntaxVisitor
{
    public [Properties.LanguageName]DetailedSyntaxVisitor(bool visitIntoStructuredToken = false, bool visitIntoStructuredTrivia = false)
		: base(visitIntoStructuredToken, visitIntoStructuredTrivia)
    {
    }
   	[loop(rule:Instances.ParserRules)]
		[if (rule.Alternatives.Count > 0)]
			[loop(alt:rule.Alternatives)]
	[GenerateDetailedSyntaxVisitorVisit(alt)]
			[end loop]
		[else]
	[GenerateDetailedSyntaxVisitorVisit(rule)]
		[end if]
	[end loop]
}
end template

template GenerateDetailedSyntaxVisitorVisit(Antlr4ParserRule rule)
^
public virtual void Visit[rule.PlainName()]([rule.RedName()] node)
{
		[loop(elem:rule.AllElements)]
			[if (elem.IsList)]
	this.VisitList(node.[elem.RedName()]);
			[else]
				[if (elem.IsToken || elem.IsFixedTokenAltBlock)]
	this.VisitToken(node.[elem.RedName()]);
				[else]
	this.Visit(node.[elem.RedName()]);
				[end if]
			[end if]
		[end loop]    
}
end template

template GenerateSyntaxRewriter()
public class [Properties.LanguageName]SyntaxRewriter : SyntaxRewriter, I[Properties.LanguageName]SyntaxVisitor<SyntaxNode>
{
    public [Properties.LanguageName]SyntaxRewriter(bool visitIntoStructuredTrivia = false)
		: base([Properties.LanguageName]Language.Instance, visitIntoStructuredTrivia)
    {
    }
^
    public virtual SyntaxNode VisitSkippedTokensTrivia([Properties.LanguageName]SkippedTokensTriviaSyntax node)
    {
      var tokens = this.VisitList(node.Tokens);
      return node.Update(tokens);
    }
    [loop(rule:Instances.ParserRules)]
		[if (rule.Alternatives.Count > 0)]
			[loop(alt:rule.Alternatives)]
	[GenerateSyntaxRewriterVisit(alt)]
			[end loop]
		[else]
	[GenerateSyntaxRewriterVisit(rule)]
		[end if]
	[end loop]
}
end template

template GenerateSyntaxRewriterVisit(Antlr4ParserRule rule)
^
public virtual SyntaxNode Visit[rule.PlainName()]([rule.RedName()] node)
{
	[if (rule.IsSimpleAlt)]
		[loop(elem:rule.Elements)]
	var old[elem.RedName()] = node.[elem.RedName()];
	if (old[elem.RedName()] != null)
	{
			[if (elem.IsList)]
		var new[elem.RedName()] = this.VisitList(old[elem.RedName()]);
			[else]
				[if (elem.IsToken || elem.IsFixedTokenAltBlock)]
		var new[elem.RedName()] = (InternalSyntaxToken)this.Visit(old[elem.RedName()]);
				[else]
	    var new[elem.RedName()] = ([elem.RedType()])this.Visit(old[elem.RedName()]);
				[end if]
			[end if]
		return node.Update(new[elem.RedName()]);
	}
		[end loop] 
	return node;   
	[else]
		[loop(elem:rule.AllElements)]
			[if (elem.IsList)]
    var [elem.FieldName()] = this.VisitList(node.[elem.RedName()]);
			[else]
				[if (elem.IsToken || elem.IsFixedTokenAltBlock)]
    var [elem.FieldName()] = this.VisitToken(node.[elem.RedName()]);
				[else]
    var [elem.FieldName()] = ([elem.RedType()])this.Visit(node.[elem.RedName()]);
				[end if]
			[end if]
		[end loop]    
	return node.Update([GetInternalElemParamList(rule, false, false, false, "")]);
	[end if]
}
end template

template GenerateSyntaxFactory()
[var lang = Properties.LanguageName]
public class [Properties.LanguageName]SyntaxFactory : SyntaxFactory
{
	internal [lang]SyntaxFactory([lang]InternalSyntaxFactory internalSyntaxFactory) 
		: base(internalSyntaxFactory)
	{
	}
	
    public new [lang]Language Language => [lang]Language.Instance;
    protected override Language LanguageCore => this.Language;

    public override LanguageParseOptions DefaultParseOptions => [lang]ParseOptions.Default;
	
	/// <summary>
	/// Create a new syntax tree from a syntax node.
	/// </summary>
	public [lang]SyntaxTree SyntaxTree(SyntaxNode root, [lang]ParseOptions options = null, string path = "", Encoding encoding = null)
	{
		return [lang]SyntaxTree.Create(([lang]SyntaxNode)root, ([lang]ParseOptions)options, path, null, encoding);
	}
	
	/// <summary>
	/// Produces a syntax tree by parsing the source text.
	/// </summary>
	public [lang]SyntaxTree ParseSyntaxTree(
		string text,
		[lang]ParseOptions options = null,
		string path = "",
		Encoding encoding = null,
		CancellationToken cancellationToken = default(CancellationToken))
	{
		return ([lang]SyntaxTree)this.ParseSyntaxTreeCore(SourceText.From(text, encoding), options, path, cancellationToken);
	}
	
	/// <summary>
	/// Produces a syntax tree by parsing the source text.
	/// </summary>
	public [lang]SyntaxTree ParseSyntaxTree(
		SourceText text,
		[lang]ParseOptions options = null,
		string path = "",
		CancellationToken cancellationToken = default(CancellationToken))
	{
		return ([lang]SyntaxTree)this.ParseSyntaxTreeCore(text, options, path, cancellationToken);
	}
	
	protected override LanguageSyntaxTree ParseSyntaxTreeCore(
		SourceText text,
		ParseOptions options = null,
		string path = "",
		CancellationToken cancellationToken = default(CancellationToken))
	{
		return [lang]SyntaxTree.ParseText(text, ([lang]ParseOptions)options, path, cancellationToken);
	}
^
	public override LanguageSyntaxTree MakeSyntaxTree(LanguageSyntaxNode root, ParseOptions options = null, string path = "", Encoding encoding = null)
	{
		return [lang]SyntaxTree.Create(([lang]SyntaxNode)root, ParseData.Empty, ([lang]ParseOptions)options, path, null, encoding);
	}
^
[loop(rule:Instances.LexerRules)]
	[if (rule.FixedToken == null)]
^
    public SyntaxToken [rule.PlainName()](string text)
    {
        return new SyntaxToken([Properties.LanguageName]Language.Instance.InternalSyntaxFactory.[rule.PlainName()](text));
    }
^
    public SyntaxToken [rule.PlainName()](string text, object value)
    {
        return new SyntaxToken([Properties.LanguageName]Language.Instance.InternalSyntaxFactory.[rule.PlainName()](text, value));
    }
	[end if]
[end loop]
[loop(rule:Instances.ParserRules)]
	[if (rule.Alternatives.Count > 0)]
		[loop(alt:rule.Alternatives)]
	[GenerateSyntaxFactoryCreate(alt)]
		[end loop]
	[else]
	[GenerateSyntaxFactoryCreate(rule)]
	[end if]
[end loop]
^
    internal static IEnumerable<Type> GetNodeTypes()
    {
        return new Type["[]"] {
[loop(rule:Instances.ParserRules)]
	[if (rule.Alternatives.Count > 0)]
		[loop(alt:rule.Alternatives)]
			typeof([alt.RedName()]),
		[end loop]
	[else]
			typeof([rule.RedName()]),
	[end if]
[end loop]
		};
	}
}
end template

template GenerateSyntaxFactoryCreate(Antlr4ParserRule rule)
[if (rule.IsSimpleAlt)]
	[loop(elem:rule.Elements)]
^
public [rule.RedName()] [rule.PlainName()]([elem.RedType()] [elem.FieldName()])
{
		[if (!elem.IsOptional)]
    if ([elem.FieldName()] == null) throw new ArgumentNullException(nameof([elem.FieldName()]));
			[if (elem.IsToken && !elem.IsList)]
    if ([elem.FieldName()].GetKind() != [Properties.LanguageName]SyntaxKind.[elem.SyntaxKind()]) throw new ArgumentException(nameof([elem.FieldName()]));
			[end if]
		[else]
			[if (elem.IsToken && !elem.IsList)]
    if ([elem.FieldName()] != null && [elem.FieldName()].GetKind() != [Properties.LanguageName]SyntaxKind.[elem.SyntaxKind()]) throw new ArgumentException(nameof([elem.FieldName()]));
			[end if]
		[end if]
    return ([rule.RedName()])[Properties.LanguageName]Language.Instance.InternalSyntaxFactory.[rule.PlainName()]([GetRedToGreenParamElem(elem)]).CreateRed();
}
	[end loop]
[else]
^
public [rule.RedName()] [rule.PlainName()]([GetElemTypedParamList(rule)])
{
	[loop(elem:rule.AllElements)]
		[if (!elem.IsOptional)]
    if ([elem.FieldName()] == null) throw new ArgumentNullException(nameof([elem.FieldName()]));
			[if (elem.IsToken && !elem.IsList)]
    if ([elem.FieldName()].GetKind() != [Properties.LanguageName]SyntaxKind.[elem.SyntaxKind()]) throw new ArgumentException(nameof([elem.FieldName()]));
			[end if]
		[else]
			[if (elem.IsToken && !elem.IsList)]
    if ([elem.FieldName()] != null && [elem.FieldName()].GetKind() != [Properties.LanguageName]SyntaxKind.[elem.SyntaxKind()]) throw new ArgumentException(nameof([elem.FieldName()]));
			[end if]
		[end if]
	[end loop]
    return ([rule.RedName()])[Properties.LanguageName]Language.Instance.InternalSyntaxFactory.[rule.PlainName()]([GetRedToGreenParamList(rule)]).CreateRed();
}
[if (rule.HasOptionalElements())]
^
public [rule.RedName()] [rule.PlainName()]([GetElemTypedParamList(rule, false, false, true)])
{
	return this.[rule.PlainName()]([GetRedToGreenParamList(rule, false, false, true)]);
}
[end if]
[end if]
end template


template GenerateGreenToken()
[var lang = Properties.LanguageName]
internal partial class GreenSyntaxToken : InternalSyntaxToken
{
    //====================
    // Optimization: Normally, we wouldn't accept this much duplicate code, but these constructors
    // are called A LOT and we want to keep them as short and simple as possible and increase the
    // likelihood that they will be inlined.

    internal GreenSyntaxToken([lang]SyntaxKind kind)
        : base(kind)
    {
    }

    internal GreenSyntaxToken([lang]SyntaxKind kind, DiagnosticInfo["[]"] diagnostics)
        : base(kind, diagnostics)
    {
    }

    internal GreenSyntaxToken([lang]SyntaxKind kind, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
        : base(kind, diagnostics, annotations)
    {
    }

    internal GreenSyntaxToken([lang]SyntaxKind kind, int fullWidth)
        : base(kind, fullWidth)
    {
    }

    internal GreenSyntaxToken([lang]SyntaxKind kind, int fullWidth, DiagnosticInfo["[]"] diagnostics)
        : base(kind, fullWidth, diagnostics)
    {
    }

    internal GreenSyntaxToken([lang]SyntaxKind kind, int fullWidth, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
        : base(kind, fullWidth, diagnostics, annotations)
    {
    }

    internal GreenSyntaxToken(ObjectReader reader)
        : base(reader)
    {
        var text = this.Text;
        if (text != null)
        {
            FullWidth = text.Length;
        }

        this.flags |= NodeFlags.IsNotMissing;  //note: cleared by subclasses representing missing tokens
    }

    public new [lang]Language Language => [lang]Language.Instance;
    protected override Language LanguageCore => this.Language;
    public new [lang]SyntaxKind Kind => EnumObject.FromIntUnsafe<[lang]SyntaxKind>(this.RawKind);
    protected override SyntaxKind KindCore => this.Kind;

    protected override bool ShouldReuseInSerialization => base.ShouldReuseInSerialization &&
                                                            FullWidth < Language.SyntaxFacts.MaxCachedTokenSize;

    //====================

    internal static GreenSyntaxToken Create([lang]SyntaxKind kind)
    {
        if (kind > LastTokenWithWellKnownText)
        {
            if (![lang]Language.Instance.SyntaxFacts.IsToken(kind))
            {
                throw new ArgumentException(string.Format("Invalid [lang]SyntaxKind: {0}. This method can only be used to create tokens.", kind), nameof(kind));
            }

            return CreateMissing(kind, null, null);
        }

        return s_tokensWithNoTrivia["[(int)kind]"].Value;
    }

    internal static GreenSyntaxToken Create([lang]SyntaxKind kind, GreenNode leading, GreenNode trailing)
    {
        if (kind > LastTokenWithWellKnownText)
        {
            if (![lang]Language.Instance.SyntaxFacts.IsToken(kind))
            {
                throw new ArgumentException(string.Format("Invalid [lang]SyntaxKind: {0}. This method can only be used to create tokens.", kind), nameof(kind));
            }

            return CreateMissing(kind, leading, trailing);
        }

        if (leading == null)
        {
            if (trailing == null)
            {
                return s_tokensWithNoTrivia["[(int)kind]"].Value;
            }
            else if (trailing == [lang]Language.Instance.InternalSyntaxFactory.Space)
            {
                return s_tokensWithSingleTrailingSpace["[(int)kind]"].Value;
            }
            else if (trailing == [lang]Language.Instance.InternalSyntaxFactory.CarriageReturnLineFeed)
            {
                return s_tokensWithSingleTrailingCRLF["[(int)kind]"].Value;
            }
        }

        if (leading == [lang]Language.Instance.InternalSyntaxFactory.ElasticZeroSpace && trailing == [lang]Language.Instance.InternalSyntaxFactory.ElasticZeroSpace)
        {
            return s_tokensWithElasticTrivia["[(int)kind]"].Value;
        }

        return new SyntaxTokenWithTrivia(kind, leading, trailing);
    }

    internal static GreenSyntaxToken CreateMissing([lang]SyntaxKind kind, GreenNode leading, GreenNode trailing)
    {
        return new MissingTokenWithTrivia(kind, leading, trailing);
    }

    internal static readonly [lang]SyntaxKind FirstTokenWithWellKnownText;
    internal static readonly [lang]SyntaxKind LastTokenWithWellKnownText;

    // TODO: eliminate the blank space before the first interesting element?
    private static readonly ArrayElement<GreenSyntaxToken>["[]"] s_tokensWithNoTrivia;
    private static readonly ArrayElement<GreenSyntaxToken>["[]"] s_tokensWithElasticTrivia;
    private static readonly ArrayElement<GreenSyntaxToken>["[]"] s_tokensWithSingleTrailingSpace;
    private static readonly ArrayElement<GreenSyntaxToken>["[]"] s_tokensWithSingleTrailingCRLF;

    static GreenSyntaxToken()
    {
        ObjectBinder.RegisterTypeReader(typeof(GreenSyntaxToken), r => new GreenSyntaxToken(r));

        FirstTokenWithWellKnownText = [lang]SyntaxKind.__FirstFixedToken;
        LastTokenWithWellKnownText = [lang]SyntaxKind.__LastFixedToken;

        s_tokensWithNoTrivia = new ArrayElement<GreenSyntaxToken>["[(int)LastTokenWithWellKnownText + 1]"];
        s_tokensWithElasticTrivia = new ArrayElement<GreenSyntaxToken>["[(int)LastTokenWithWellKnownText + 1]"];
        s_tokensWithSingleTrailingSpace = new ArrayElement<GreenSyntaxToken>["[(int)LastTokenWithWellKnownText + 1]"];
        s_tokensWithSingleTrailingCRLF = new ArrayElement<GreenSyntaxToken>["[(int)LastTokenWithWellKnownText + 1]"];
		InternalSyntaxFactory factory = [lang]Language.Instance.InternalSyntaxFactory;
        for (EnumObject kind = FirstTokenWithWellKnownText; kind <= LastTokenWithWellKnownText; kind++)
        {
            s_tokensWithNoTrivia["[(int)kind]"].Value = new GreenSyntaxToken(([lang]SyntaxKind)kind);
            s_tokensWithElasticTrivia["[(int)kind]"].Value = new SyntaxTokenWithTrivia(([lang]SyntaxKind)kind, factory.ElasticZeroSpace, factory.ElasticZeroSpace);
            s_tokensWithSingleTrailingSpace["[(int)kind]"].Value = new SyntaxTokenWithTrivia(([lang]SyntaxKind)kind, null, factory.Space);
            s_tokensWithSingleTrailingCRLF["[(int)kind]"].Value = new SyntaxTokenWithTrivia(([lang]SyntaxKind)kind, null, factory.CarriageReturnLineFeed);
        }
    }

    internal static IEnumerable<GreenSyntaxToken> GetWellKnownTokens()
    {
        foreach (var element in s_tokensWithNoTrivia)
        {
            if (element.Value != null)
            {
                yield return element.Value;
            }
        }

        foreach (var element in s_tokensWithElasticTrivia)
        {
            if (element.Value != null)
            {
                yield return element.Value;
            }
        }

        foreach (var element in s_tokensWithSingleTrailingSpace)
        {
            if (element.Value != null)
            {
                yield return element.Value;
            }
        }

        foreach (var element in s_tokensWithSingleTrailingCRLF)
        {
            if (element.Value != null)
            {
                yield return element.Value;
            }
        }
    }

    internal static GreenSyntaxToken Identifier([lang]SyntaxKind kind, string text)
    {
        return new SyntaxIdentifier(kind, text);
    }

    internal static GreenSyntaxToken Identifier([lang]SyntaxKind kind, GreenNode leading, string text, GreenNode trailing)
    {
        if (leading == null)
        {
            if (trailing == null)
            {
                return Identifier(kind, text);
            }
            else
            {
                return new SyntaxIdentifierWithTrailingTrivia(kind, text, trailing);
            }
        }

        return new SyntaxIdentifierWithTrivia(kind, kind, text, text, leading, trailing);
    }

    internal static GreenSyntaxToken Identifier([lang]SyntaxKind kind, [lang]SyntaxKind contextualKind, GreenNode leading, string text, string valueText, GreenNode trailing)
    {
        if (contextualKind == kind && valueText == text)
        {
            return Identifier(kind, leading, text, trailing);
        }

        return new SyntaxIdentifierWithTrivia(kind, contextualKind, text, valueText, leading, trailing);
    }

    internal static GreenSyntaxToken WithValue<T>([lang]SyntaxKind kind, string text, T value)
    {
        return new SyntaxTokenWithValue<T>(kind, text, value);
    }

    internal static GreenSyntaxToken WithValue<T>([lang]SyntaxKind kind, GreenNode leading, string text, T value, GreenNode trailing)
    {
        return new SyntaxTokenWithValueAndTrivia<T>(kind, text, value, leading, trailing);
    }

    public new virtual [lang]SyntaxKind ContextualKind => this.Kind;

    public override int RawContextualKind => (int)this.ContextualKind;

    public override InternalSyntaxToken TokenWithLeadingTrivia(GreenNode trivia)
    {
        return new SyntaxTokenWithTrivia(this.Kind, trivia, null, this.GetDiagnostics(), this.GetAnnotations());
    }

    public override InternalSyntaxToken TokenWithTrailingTrivia(GreenNode trivia)
    {
        return new SyntaxTokenWithTrivia(this.Kind, null, trivia, this.GetDiagnostics(), this.GetAnnotations());
    }

    public override InternalSyntaxNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
    {
        System.Diagnostics.Debug.Assert(this.GetType() == typeof(GreenSyntaxToken));
        return new GreenSyntaxToken(this.Kind, this.FullWidth, diagnostics, this.GetAnnotations());
    }

    public override InternalSyntaxNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
    {
        System.Diagnostics.Debug.Assert(this.GetType() == typeof(GreenSyntaxToken));
        return new GreenSyntaxToken(this.Kind, this.FullWidth, this.GetDiagnostics(), annotations);
    }

	public override GreenNode Clone()
	{
        System.Diagnostics.Debug.Assert(this.GetType() == typeof(GreenSyntaxToken));
		return new GreenSyntaxToken(this.Kind, this.FullWidth, GetDiagnostics(), GetAnnotations());
	}

    public override TResult Accept<TResult>(InternalSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitToken(this);
    }

    public override void Accept(InternalSyntaxVisitor visitor)
    {
        visitor.VisitToken(this);
    }

    protected override void WriteTokenTo(System.IO.TextWriter writer, bool leading, bool trailing)
    {
        if (leading)
        {
            var trivia = this.GetLeadingTrivia();
            if (trivia != null)
            {
                trivia.WriteTo(writer);
            }
        }

        writer.Write(this.Text);

        if (trailing)
        {
            var trivia = this.GetTrailingTrivia();
            if (trivia != null)
            {
                trivia.WriteTo(writer);
            }
        }
    }
^
    internal class MissingTokenWithTrivia : SyntaxTokenWithTrivia
    {
        internal MissingTokenWithTrivia([lang]SyntaxKind kind, GreenNode leading, GreenNode trailing)
            : base(kind, leading, trailing)
        {
            this.flags &= ~NodeFlags.IsNotMissing;
        }

        internal MissingTokenWithTrivia([lang]SyntaxKind kind, GreenNode leading, GreenNode trailing, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
            : base(kind, leading, trailing, diagnostics, annotations)
        {
            this.flags &= ~NodeFlags.IsNotMissing;
        }

        internal MissingTokenWithTrivia(ObjectReader reader)
            : base(reader)
        {
            this.flags &= ~NodeFlags.IsNotMissing;
        }

        static MissingTokenWithTrivia()
        {
            ObjectBinder.RegisterTypeReader(typeof(MissingTokenWithTrivia), r => new MissingTokenWithTrivia(r));
        }

        public override string Text
        {
            get { return string.Empty; }
        }

        public override object Value
        {
            get
            {
                if (Language.SyntaxFacts.IsIdentifier(this.Kind)) return string.Empty;
                else return null;
            }
        }

        public override InternalSyntaxToken TokenWithLeadingTrivia(GreenNode trivia)
        {
            return new MissingTokenWithTrivia(this.Kind, trivia, this.TrailingField, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxToken TokenWithTrailingTrivia(GreenNode trivia)
        {
            return new MissingTokenWithTrivia(this.Kind, this.LeadingField, trivia, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
        {
            return new MissingTokenWithTrivia(this.Kind, this.LeadingField, this.TrailingField, diagnostics, this.GetAnnotations());
        }

        public override InternalSyntaxNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
        {
            return new MissingTokenWithTrivia(this.Kind, this.LeadingField, this.TrailingField, this.GetDiagnostics(), annotations);
        }

	    public override GreenNode Clone()
	    {
		    return new MissingTokenWithTrivia(this.Kind, this.LeadingField, this.TrailingField, this.GetDiagnostics(), this.GetAnnotations());
	    }
    }
^
    internal class SyntaxIdentifier : GreenSyntaxToken
    {
        static SyntaxIdentifier()
        {
            ObjectBinder.RegisterTypeReader(typeof(SyntaxIdentifier), r => new SyntaxIdentifier(r));
        }

        protected readonly string TextField;

        internal SyntaxIdentifier([lang]SyntaxKind kind, string text)
            : base(kind, text.Length)
        {
            this.TextField = text;
        }

        internal SyntaxIdentifier([lang]SyntaxKind kind, string text, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
            : base(kind, text.Length, diagnostics, annotations)
        {
            this.TextField = text;
        }

        internal SyntaxIdentifier(ObjectReader reader)
            : base(reader)
        {
            this.TextField = reader.ReadString();
            this.FullWidth = this.TextField.Length;
        }

        protected override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteString(this.TextField);
        }

        public override string Text
        {
            get { return this.TextField; }
        }

        public override object Value
        {
            get { return this.TextField; }
        }

        public override string ValueText
        {
            get { return this.TextField; }
        }

        public override InternalSyntaxToken TokenWithLeadingTrivia(GreenNode trivia)
        {
            return new SyntaxIdentifierWithTrivia(this.Kind, this.ContextualKind, this.TextField, this.TextField, trivia, null, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxToken TokenWithTrailingTrivia(GreenNode trivia)
        {
            return new SyntaxIdentifierWithTrivia(this.Kind, this.ContextualKind, this.TextField, this.TextField, null, trivia, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
        {
            return new SyntaxIdentifier(this.Kind, this.Text, diagnostics, this.GetAnnotations());
        }

        public override InternalSyntaxNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
        {
            return new SyntaxIdentifier(this.Kind, this.Text, this.GetDiagnostics(), annotations);
        }

	    public override GreenNode Clone()
	    {
		    return new SyntaxIdentifier(this.Kind, this.Text, this.GetDiagnostics(), this.GetAnnotations());
	    }
    }
^
    internal class SyntaxIdentifierExtended : SyntaxIdentifier
    {
        protected readonly [lang]SyntaxKind contextualKind;
        protected readonly string valueText;

        internal SyntaxIdentifierExtended([lang]SyntaxKind kind, [lang]SyntaxKind contextualKind, string text, string valueText)
            : base(kind, text)
        {
            this.contextualKind = contextualKind;
            this.valueText = valueText;
        }

        internal SyntaxIdentifierExtended([lang]SyntaxKind kind, [lang]SyntaxKind contextualKind, string text, string valueText, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
            : base(kind, text, diagnostics, annotations)
        {
            this.contextualKind = contextualKind;
            this.valueText = valueText;
        }

        internal SyntaxIdentifierExtended(ObjectReader reader)
            : base(reader)
        {
            this.contextualKind = EnumObject.FromIntUnsafe<[lang]SyntaxKind>(reader.ReadInt32());
            this.valueText = reader.ReadString();
        }

        static SyntaxIdentifierExtended()
        {
            ObjectBinder.RegisterTypeReader(typeof(SyntaxIdentifierExtended), r => new SyntaxIdentifierExtended(r));
        }

        protected override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteInt32((int)this.contextualKind);
            writer.WriteString(this.valueText);
        }

        public override [lang]SyntaxKind ContextualKind
        {
            get { return this.contextualKind; }
        }

        public override string ValueText
        {
            get { return this.valueText; }
        }

        public override object Value
        {
            get { return this.valueText; }
        }

        public override InternalSyntaxToken TokenWithLeadingTrivia(GreenNode trivia)
        {
            return new SyntaxIdentifierWithTrivia(this.Kind, this.contextualKind, this.TextField, this.valueText, trivia, null, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxToken TokenWithTrailingTrivia(GreenNode trivia)
        {
            return new SyntaxIdentifierWithTrivia(this.Kind, this.contextualKind, this.TextField, this.valueText, null, trivia, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
        {
            return new SyntaxIdentifierExtended(this.Kind, this.contextualKind, this.TextField, this.valueText, diagnostics, this.GetAnnotations());
        }

        public override InternalSyntaxNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
        {
            return new SyntaxIdentifierExtended(this.Kind, this.contextualKind, this.TextField, this.valueText, this.GetDiagnostics(), annotations);
        }

	    public override GreenNode Clone()
	    {
		    return new SyntaxIdentifierExtended(this.Kind, this.contextualKind, this.TextField, this.valueText, this.GetDiagnostics(), this.GetAnnotations());
	    }
    }
^
	internal class SyntaxIdentifierWithTrailingTrivia : SyntaxIdentifier
    {
        private readonly GreenNode _trailing;

        internal SyntaxIdentifierWithTrailingTrivia([lang]SyntaxKind kind, string text, GreenNode trailing)
            : base(kind, text)
        {
            if (trailing != null)
            {
                this.AdjustFlagsAndWidth(trailing);
                _trailing = trailing;
            }
        }

        internal SyntaxIdentifierWithTrailingTrivia([lang]SyntaxKind kind, string text, GreenNode trailing, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
            : base(kind, text, diagnostics, annotations)
        {
            if (trailing != null)
            {
                this.AdjustFlagsAndWidth(trailing);
                _trailing = trailing;
            }
        }

        internal SyntaxIdentifierWithTrailingTrivia(ObjectReader reader)
            : base(reader)
        {
            var trailing = (GreenNode)reader.ReadValue();
            if (trailing != null)
            {
                this.AdjustFlagsAndWidth(trailing);
                _trailing = trailing;
            }
        }

        static SyntaxIdentifierWithTrailingTrivia()
        {
            ObjectBinder.RegisterTypeReader(typeof(SyntaxIdentifierWithTrailingTrivia), r => new SyntaxIdentifierWithTrailingTrivia(r));
        }

        protected override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(_trailing);
        }

        public override GreenNode GetTrailingTrivia()
        {
            return _trailing;
        }

        public override InternalSyntaxToken TokenWithLeadingTrivia(GreenNode trivia)
        {
            return new SyntaxIdentifierWithTrivia(this.Kind, this.ContextualKind, this.TextField, this.TextField, trivia, _trailing, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxToken TokenWithTrailingTrivia(GreenNode trivia)
        {
            return new SyntaxIdentifierWithTrailingTrivia(this.Kind, this.TextField, trivia, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
        {
            return new SyntaxIdentifierWithTrailingTrivia(this.Kind, this.TextField, _trailing, diagnostics, this.GetAnnotations());
        }

        public override InternalSyntaxNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
        {
            return new SyntaxIdentifierWithTrailingTrivia(this.Kind, this.TextField, _trailing, this.GetDiagnostics(), annotations);
        }

	    public override GreenNode Clone()
	    {
		    return new SyntaxIdentifierWithTrailingTrivia(this.Kind, this.TextField, _trailing, this.GetDiagnostics(), this.GetAnnotations());
	    }
    }
^
    internal class SyntaxIdentifierWithTrivia : SyntaxIdentifierExtended
    {
        private readonly GreenNode _leading;
        private readonly GreenNode _trailing;

        internal SyntaxIdentifierWithTrivia(
            [lang]SyntaxKind kind,
            [lang]SyntaxKind contextualKind,
            string text,
            string valueText,
            GreenNode leading,
            GreenNode trailing)
            : base(kind, contextualKind, text, valueText)
        {
            if (leading != null)
            {
                this.AdjustFlagsAndWidth(leading);
                _leading = leading;
            }
            if (trailing != null)
            {
                this.AdjustFlagsAndWidth(trailing);
                _trailing = trailing;
            }
        }

        internal SyntaxIdentifierWithTrivia(
            [lang]SyntaxKind kind,
            [lang]SyntaxKind contextualKind,
            string text,
            string valueText,
            GreenNode leading,
            GreenNode trailing,
            DiagnosticInfo["[]"] diagnostics,
            SyntaxAnnotation["[]"] annotations)
            : base(kind, contextualKind, text, valueText, diagnostics, annotations)
        {
            if (leading != null)
            {
                this.AdjustFlagsAndWidth(leading);
                _leading = leading;
            }
            if (trailing != null)
            {
                this.AdjustFlagsAndWidth(trailing);
                _trailing = trailing;
            }
        }

        internal SyntaxIdentifierWithTrivia(ObjectReader reader)
            : base(reader)
        {
            var leading = (GreenNode)reader.ReadValue();
            if (leading != null)
            {
                this.AdjustFlagsAndWidth(leading);
                _leading = leading;
            }
            var trailing = (GreenNode)reader.ReadValue();
            if (trailing != null)
            {
                _trailing = trailing;
                this.AdjustFlagsAndWidth(trailing);
            }
        }

        static SyntaxIdentifierWithTrivia()
        {
            ObjectBinder.RegisterTypeReader(typeof(SyntaxIdentifierWithTrivia), r => new SyntaxIdentifierWithTrivia(r));
        }

        protected override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(_leading);
            writer.WriteValue(_trailing);
        }

        public override GreenNode GetLeadingTrivia()
        {
            return _leading;
        }

        public override GreenNode GetTrailingTrivia()
        {
            return _trailing;
        }

        public override InternalSyntaxToken TokenWithLeadingTrivia(GreenNode trivia)
        {
            return new SyntaxIdentifierWithTrivia(this.Kind, this.contextualKind, this.TextField, this.valueText, trivia, _trailing, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxToken TokenWithTrailingTrivia(GreenNode trivia)
        {
            return new SyntaxIdentifierWithTrivia(this.Kind, this.contextualKind, this.TextField, this.valueText, _leading, trivia, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
        {
            return new SyntaxIdentifierWithTrivia(this.Kind, this.contextualKind, this.TextField, this.valueText, _leading, _trailing, diagnostics, this.GetAnnotations());
        }

        public override InternalSyntaxNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
        {
            return new SyntaxIdentifierWithTrivia(this.Kind, this.contextualKind, this.TextField, this.valueText, _leading, _trailing, this.GetDiagnostics(), annotations);
        }

	    public override GreenNode Clone()
	    {
		    return new SyntaxIdentifierWithTrivia(this.Kind, this.contextualKind, this.TextField, this.valueText, _leading, _trailing, this.GetDiagnostics(), this.GetAnnotations());
	    }
    }
^
    internal class SyntaxTokenWithValue<T> : GreenSyntaxToken
    {
        protected readonly string TextField;
        protected readonly T ValueField;

        internal SyntaxTokenWithValue([lang]SyntaxKind kind, string text, T value)
            : base(kind, text.Length)
        {
            this.TextField = text;
            this.ValueField = value;
        }

        internal SyntaxTokenWithValue([lang]SyntaxKind kind, string text, T value, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
            : base(kind, text.Length, diagnostics, annotations)
        {
            this.TextField = text;
            this.ValueField = value;
        }

        internal SyntaxTokenWithValue(ObjectReader reader)
            : base(reader)
        {
            this.TextField = reader.ReadString();
            this.FullWidth = this.TextField.Length;
            this.ValueField = (T)reader.ReadValue();
        }

        static SyntaxTokenWithValue()
        {
            ObjectBinder.RegisterTypeReader(typeof(SyntaxTokenWithValue<T>), r => new SyntaxTokenWithValue<T>(r));
        }

        protected override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteString(this.TextField);
            writer.WriteValue(this.ValueField);
        }

        public override string Text
        {
            get
            {
                return this.TextField;
            }
        }

        public override object Value
        {
            get
            {
                return this.ValueField;
            }
        }

        public override string ValueText
        {
            get
            {
                return Convert.ToString(this.ValueField, CultureInfo.InvariantCulture);
            }
        }

        public override InternalSyntaxToken TokenWithLeadingTrivia(GreenNode trivia)
        {
            return new SyntaxTokenWithValueAndTrivia<T>(this.Kind, this.TextField, this.ValueField, trivia, null, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxToken TokenWithTrailingTrivia(GreenNode trivia)
        {
            return new SyntaxTokenWithValueAndTrivia<T>(this.Kind, this.TextField, this.ValueField, null, trivia, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
        {
            return new SyntaxTokenWithValue<T>(this.Kind, this.TextField, this.ValueField, diagnostics, this.GetAnnotations());
        }

        public override InternalSyntaxNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
        {
            return new SyntaxTokenWithValue<T>(this.Kind, this.TextField, this.ValueField, this.GetDiagnostics(), annotations);
        }

	    public override GreenNode Clone()
	    {
		    return new SyntaxTokenWithValue<T>(this.Kind, this.TextField, this.ValueField, this.GetDiagnostics(), this.GetAnnotations());
	    }
    }
^
    internal class SyntaxTokenWithValueAndTrivia<T> : SyntaxTokenWithValue<T>
    {
        static SyntaxTokenWithValueAndTrivia()
        {
            ObjectBinder.RegisterTypeReader(typeof(SyntaxTokenWithValueAndTrivia<T>), r => new SyntaxTokenWithValueAndTrivia<T>(r));
        }

        private readonly GreenNode _leading;
        private readonly GreenNode _trailing;

        internal SyntaxTokenWithValueAndTrivia([lang]SyntaxKind kind, string text, T value, GreenNode leading, GreenNode trailing)
            : base(kind, text, value)
        {
            if (leading != null)
            {
                this.AdjustFlagsAndWidth(leading);
                _leading = leading;
            }
            if (trailing != null)
            {
                this.AdjustFlagsAndWidth(trailing);
                _trailing = trailing;
            }
        }

        internal SyntaxTokenWithValueAndTrivia(
            [lang]SyntaxKind kind,
            string text,
            T value,
            GreenNode leading,
            GreenNode trailing,
            DiagnosticInfo["[]"] diagnostics,
            SyntaxAnnotation["[]"] annotations)
            : base(kind, text, value, diagnostics, annotations)
        {
            if (leading != null)
            {
                this.AdjustFlagsAndWidth(leading);
                _leading = leading;
            }
            if (trailing != null)
            {
                this.AdjustFlagsAndWidth(trailing);
                _trailing = trailing;
            }
        }

        internal SyntaxTokenWithValueAndTrivia(ObjectReader reader)
            : base(reader)
        {
            var leading = (GreenNode)reader.ReadValue();
            if (leading != null)
            {
                this.AdjustFlagsAndWidth(leading);
                _leading = leading;
            }
            var trailing = (GreenNode)reader.ReadValue();
            if (trailing != null)
            {
                this.AdjustFlagsAndWidth(trailing);
                _trailing = trailing;
            }
        }

        protected override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(_leading);
            writer.WriteValue(_trailing);
        }

        public override GreenNode GetLeadingTrivia()
        {
            return _leading;
        }

        public override GreenNode GetTrailingTrivia()
        {
            return _trailing;
        }

        public override InternalSyntaxToken TokenWithLeadingTrivia(GreenNode trivia)
        {
            return new SyntaxTokenWithValueAndTrivia<T>(this.Kind, this.TextField, this.ValueField, trivia, _trailing, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxToken TokenWithTrailingTrivia(GreenNode trivia)
        {
            return new SyntaxTokenWithValueAndTrivia<T>(this.Kind, this.TextField, this.ValueField, _leading, trivia, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
        {
            return new SyntaxTokenWithValueAndTrivia<T>(this.Kind, this.TextField, this.ValueField, _leading, _trailing, diagnostics, this.GetAnnotations());
        }

        public override InternalSyntaxNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
        {
            return new SyntaxTokenWithValueAndTrivia<T>(this.Kind, this.TextField, this.ValueField, _leading, _trailing, this.GetDiagnostics(), annotations);
        }

	    public override GreenNode Clone()
	    {
		    return new SyntaxTokenWithValueAndTrivia<T>(this.Kind, this.TextField, this.ValueField, _leading, _trailing, this.GetDiagnostics(), this.GetAnnotations());
	    }
    }
^
    internal class SyntaxTokenWithTrivia : GreenSyntaxToken
    {
        static SyntaxTokenWithTrivia()
        {
            ObjectBinder.RegisterTypeReader(typeof(SyntaxTokenWithTrivia), r => new SyntaxTokenWithTrivia(r));
        }

        protected readonly GreenNode LeadingField;
        protected readonly GreenNode TrailingField;

        internal SyntaxTokenWithTrivia([lang]SyntaxKind kind, GreenNode leading, GreenNode trailing)
            : base(kind)
        {
            if (leading != null)
            {
                this.AdjustFlagsAndWidth(leading);
                this.LeadingField = leading;
            }
            if (trailing != null)
            {
                this.AdjustFlagsAndWidth(trailing);
                this.TrailingField = trailing;
            }
        }

        internal SyntaxTokenWithTrivia([lang]SyntaxKind kind, GreenNode leading, GreenNode trailing, DiagnosticInfo["[]"] diagnostics, SyntaxAnnotation["[]"] annotations)
            : base(kind, diagnostics, annotations)
        {
            if (leading != null)
            {
                this.AdjustFlagsAndWidth(leading);
                this.LeadingField = leading;
            }
            if (trailing != null)
            {
                this.AdjustFlagsAndWidth(trailing);
                this.TrailingField = trailing;
            }
        }

        internal SyntaxTokenWithTrivia(ObjectReader reader)
            : base(reader)
        {
            var leading = (GreenNode)reader.ReadValue();
            if (leading != null)
            {
                this.AdjustFlagsAndWidth(leading);
                this.LeadingField = leading;
            }
            var trailing = (GreenNode)reader.ReadValue();
            if (trailing != null)
            {
                this.AdjustFlagsAndWidth(trailing);
                this.TrailingField = trailing;
            }
        }

        protected override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.LeadingField);
            writer.WriteValue(this.TrailingField);
        }

        public override GreenNode GetLeadingTrivia()
        {
            return this.LeadingField;
        }

        public override GreenNode GetTrailingTrivia()
        {
            return this.TrailingField;
        }

        public override InternalSyntaxToken TokenWithLeadingTrivia(GreenNode trivia)
        {
            return new SyntaxTokenWithTrivia(this.Kind, trivia, this.TrailingField, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxToken TokenWithTrailingTrivia(GreenNode trivia)
        {
            return new SyntaxTokenWithTrivia(this.Kind, this.LeadingField, trivia, this.GetDiagnostics(), this.GetAnnotations());
        }

        public override InternalSyntaxNode WithDiagnostics(DiagnosticInfo["[]"] diagnostics)
        {
            return new SyntaxTokenWithTrivia(this.Kind, this.LeadingField, this.TrailingField, diagnostics, this.GetAnnotations());
        }

        public override InternalSyntaxNode WithAnnotations(SyntaxAnnotation["[]"] annotations)
        {
            return new SyntaxTokenWithTrivia(this.Kind, this.LeadingField, this.TrailingField, this.GetDiagnostics(), annotations);
        }

	    public override GreenNode Clone()
	    {
		    return new SyntaxTokenWithTrivia(this.Kind, this.LeadingField, this.TrailingField, this.GetDiagnostics(), this.GetAnnotations());
	    }
    }
}
end template


template GenerateDeclarationTreeBuilder()
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Declarations;
using MetaDslx.CodeAnalysis.Symbols;
using Microsoft.CodeAnalysis;
using [Properties.DefaultNamespace];
using [Properties.DefaultNamespace].Syntax;
using [Properties.DefaultNamespace].Symbols;
[Instances.ParserHeader]

^
namespace [Properties.DefaultNamespace].Binding
{
	public class [Properties.LanguageName]DeclarationTreeBuilderVisitor : DeclarationTreeBuilderVisitor, I[Properties.LanguageName]SyntaxVisitor
	{
        protected [Properties.LanguageName]DeclarationTreeBuilderVisitor([Properties.LanguageName]SyntaxTree syntaxTree, SymbolFacts symbolFacts, string scriptClassName, bool isSubmission)
            : base(syntaxTree, symbolFacts, scriptClassName, isSubmission)
        {
        }
^
        public static RootSingleDeclaration ForTree(
            [Properties.LanguageName]SyntaxTree syntaxTree,
            SymbolFacts symbolFacts,
            string scriptClassName,
            bool isSubmission)
        {
            var builder = new [Properties.LanguageName]DeclarationTreeBuilderVisitor(syntaxTree, symbolFacts, scriptClassName, isSubmission);
            return builder.CreateRoot(syntaxTree.GetRoot(), [Instances.MainRule().Annotations.GetObjectType(MetaCompilerAnnotationInfo.Root)]);
        }
^
		[loop(annot:Instances.CustomAnnotations)]
^
        protected virtual void Begin[annot.Name](SyntaxNodeOrToken syntax)
        {
        }
^
        protected virtual void End[annot.Name](SyntaxNodeOrToken syntax)
        {
        }
		[end loop]
^
		public virtual void VisitSkippedTokensTrivia([Properties.LanguageName]SkippedTokensTriviaSyntax node)
		{
		}
   		[loop(rule:Instances.ParserRules)]
			[if (rule.Alternatives.Count > 0)]
				[loop(alt:rule.Alternatives)]
		[GenerateDeclarationTreeBuilderVisit(alt)]
				[end loop]
			[else]
		[GenerateDeclarationTreeBuilderVisit(rule)]
			[end if]
		[end loop]
	}
}
end template


template GenerateDeclarationTreeBuilderVisit(Antlr4ParserRule rule)
^
public virtual void Visit[rule.PlainName()]([rule.RedName()] node)
{
	[GetDeclarationTreeBuilderVisitBody(rule)]
}
end template

template GenerateDeclarationTreeBuilderVisitBody(Antlr4ParserRule rule)
[if (rule.ContainsAnnotations)]
	[loop(elem:rule.AllElements where elem.ContainsAnnotations)]
        [if (elem.IsToken)]
if (node.[elem.RedName()].GetKind() != MetaDslx.CodeAnalysis.Syntax.SyntaxKind.None)
        [else]
if (node.[elem.RedName()] != null)
        [end if]
{
        [if (elem.IsList)]
	foreach (var child in node.[elem.RedName()])
	{
        [GenerateDeclarationTreeBuilderVisitElement(rule, elem, "child")]
	}
        [else]
    [GenerateDeclarationTreeBuilderVisitElement(rule, elem, "node."+elem.RedName())]
        [end if]
}
	[end loop]    
[end if]
end template

template GenerateDeclarationTreeBuilderVisitElementBody(Antlr4ParserRuleElement elem, string elemName)
this.Visit([elemName]);
end template

template GenerateDeclarationTreeBuilderAnnotation(MetaCompilerAnnotation annot, string elemName, string body)
this.Begin[annot.Name]([elemName][annot.GetAnnotationParams()]);
try
{
	[body]
}
finally
{
	this.End[annot.Name]([elemName][annot.GetAnnotationParams()]);
}
end template

function string GetDeclarationTreeBuilderVisitBody(Antlr4ParserRule rule)
	string body = GenerateDeclarationTreeBuilderVisitBody(rule);
	loop (annot:rule.Annotations.Annotations.Reverse())
		body = GenerateDeclarationTreeBuilderAnnotation(annot, "node", body);
	end loop
	return body;
end function

function string GetDeclarationTreeBuilderVisitElement(Antlr4ParserRule rule, Antlr4ParserRuleElement elem, string elemName)
	string body = GenerateDeclarationTreeBuilderVisitElementBody(elem, elemName);
	loop (annot:elem.Annotations.Annotations.Reverse())
		body = GenerateDeclarationTreeBuilderAnnotation(annot, elemName, body);
	end loop
	return body;
end function

template GenerateDeclarationTreeBuilderVisitElement(Antlr4ParserRule rule, Antlr4ParserRuleElement elem, string elemName)
	[if (elem.IsFixedTokenAltBlock)]
switch ([elemName].GetKind().Switch())
{
	[loop (alt:elem.BlockItems)]
	case [Properties.LanguageName]SyntaxKind.[alt.RedName()]:
		[GetDeclarationTreeBuilderVisitElement(rule, alt, elemName)]
		break;
	[end loop]
	default:
		break;
}
	[else]
[GetDeclarationTreeBuilderVisitElement(rule, elem, elemName)]
	[end if]
end template

template GenerateBinderFactoryVisitor()
using System.Diagnostics;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Binding;
using MetaDslx.CodeAnalysis.Syntax;
using [Properties.DefaultNamespace];
using [Properties.DefaultNamespace].Syntax;
using [Properties.DefaultNamespace].Symbols;
[Instances.ParserHeader]
^
namespace [Properties.DefaultNamespace].Binding
{
    public class [Properties.LanguageName]BinderFactoryVisitor : BinderFactoryVisitor, I[Properties.LanguageName]SyntaxVisitor<Binder>
    {
		[loop (use:Instances.ParserRuleElemUses)]
		public static object Use[use] = new object();
		[end loop]
^
        public [Properties.LanguageName]BinderFactoryVisitor(BinderFactory symbolBuilder)
			: base(symbolBuilder)
        {
^
        }
		[loop(annot:Instances.CustomAnnotations)]
^
        protected virtual Binder Create[annot.Name]Binder(Binder parentBinder, SyntaxNodeOrToken syntax)
        {
            return this.Create[annot.Name]BinderCore(parentBinder, syntax);
        }
^
        protected virtual Binder Create[annot.Name]BinderCore(Binder parentBinder, SyntaxNodeOrToken syntax)
        {
            return new [annot.Name]Binder(parentBinder, syntax);
        }
		[end loop]
^
        public Binder VisitSkippedTokensTrivia([Properties.LanguageName]SkippedTokensTriviaSyntax parent)
        {
            return null;
        }
^		
		[loop(rule:Instances.ParserRules)]
			[if (rule.Alternatives.Count > 0)]
				[loop(alt:rule.Alternatives)]
		[GenerateBinderFactoryVisit(alt)]
				[end loop]
			[else]
		[GenerateBinderFactoryVisit(rule)]
			[end if]
		[end loop]
    }
}
end template


template GenerateBinderFactoryVisit(Antlr4ParserRule rule)
^
public Binder Visit[rule.PlainName()]([rule.RedName()] parent)
{
    [if (rule == Instances.MainRule())]
	return this.GetCompilationUnitBinder(parent, inUsing: IsInUsing(parent), inScript: InScript);
	[else]
    if (!parent.FullSpan.Contains(this.Position))
    {
        return VisitParent(parent);
    }
	object use = null;
	[GenerateBinderFactoryVisitElemUses(rule)]
	Binder resultBinder = null;
	if (!this.BinderFactory.TryGetBinder(parent, use, out resultBinder))
	{
		resultBinder = VisitParent(parent);
		[loop (annot:rule.Annotations.BinderAnnotations)]
		resultBinder = this.Create[annot.Name]Binder(resultBinder, parent[annot.GetAnnotationParams()]);
		[end loop]
		this.BinderFactory.TryAddBinder(parent, null, ref resultBinder);
		[GenerateBinderFactoryVisitBody(rule)]
	}
	return resultBinder;
	[end if]
}
end template


template GenerateBinderFactoryVisitBody(Antlr4ParserRule rule)
[if (rule.ContainsBinderAnnotations && hasloop(elem:rule.AllElements where elem.HasBinderAnnotations || elem.BlockItems.Any(bi => bi.HasBinderAnnotations)))]
	[loop(elem:rule.AllElements where elem.ContainsBinderAnnotations)]
[GenerateBinderFactoryVisitElement(rule, elem)]
	[end loop]    
[end if]
end template

template GenerateBinderFactoryVisitElement(Antlr4ParserRule rule, Antlr4ParserRuleElement elem)
	[if (elem.IsFixedTokenAltBlock)]
[GenerateBinderFactoryVisitTokenAltBody(rule, elem)]
	[else]
[GenerateBinderFactoryVisitElementBody(rule, elem)]
	[end if]
end template

template GenerateBinderFactoryVisitElementBody(Antlr4ParserRule rule, Antlr4ParserRuleElement elem)
	[if (elem.HasBinderAnnotations)]
if (use == Use[elem.RedName()])
{
    [loop (annot:elem.Annotations.BinderAnnotations)]
		[if (elem.IsList)]
	resultBinder = this.Create[annot.Name]Binder(resultBinder, parent.[elem.RedName()].Node[annot.GetAnnotationParams()]);
		[else]
	resultBinder = this.Create[annot.Name]Binder(resultBinder, parent.[elem.RedName()][annot.GetAnnotationParams()]);
		[end if]
	[end loop]
	this.BinderFactory.TryAddBinder(parent, use, ref resultBinder);
}
	[end if]
end template

template GenerateBinderFactoryVisitTokenAltBody(Antlr4ParserRule rule, Antlr4ParserRuleElement elem)
	[if (elem.BlockItems.Any(bi => bi.HasBinderAnnotations))]
if (use == Use[elem.RedName()])
{
	switch (parent.[elem.RedName()].GetKind().Switch())
	{
			[loop (alt:elem.BlockItems)]
		case [Properties.LanguageName]SyntaxKind.[alt.RedName()]:
				[loop (annot:alt.Annotations.BinderAnnotations)]
			resultBinder = this.Create[annot.Name]Binder(resultBinder, parent.[elem.RedName()][annot.GetAnnotationParams()]);
				[end loop]
			break;
			[end loop]
		default:
			break;
	}
	this.BinderFactory.TryAddBinder(parent, use, ref resultBinder);
}
	[end if]
end template

template GenerateBinderFactoryVisitElemUses(Antlr4ParserRule rule)
[if (rule.ContainsBinderAnnotations && hasloop(elem:rule.AllElements where elem.HasBinderAnnotations || elem.BlockItems.Any(bi => bi.HasBinderAnnotations)))]
if (this.ForChild)
{
	[loop(elem:rule.AllElements where elem.HasBinderAnnotations || elem.BlockItems.Any(bi => bi.HasBinderAnnotations))]
		[if (elem.IsList)]
	if (LookupPosition.IsInNode(this.Position, parent.[elem.RedName()].Node)) use = Use[elem.RedName()];
		[else]
	if (LookupPosition.IsInNode(this.Position, parent.[elem.RedName()])) use = Use[elem.RedName()];
		[end if]
	[end loop]    
}
[end if]
end template

template GenerateSymbolFacts()
using System;
using System.Collections.Generic;
using System.Text;
using MetaDslx.CodeAnalysis;
using MetaDslx.CodeAnalysis.Symbols;
using [Properties.DefaultNamespace];
using [Properties.DefaultNamespace].Syntax.InternalSyntax;
[Instances.ParserHeader]
^
[var lang = Properties.LanguageName]
namespace [Properties.DefaultNamespace].Symbols
{
    public class [lang]SymbolFacts : global::MetaDslx.CodeAnalysis.Symbols.Metadata.MetaSymbolFacts
    {
    }
}
end template


