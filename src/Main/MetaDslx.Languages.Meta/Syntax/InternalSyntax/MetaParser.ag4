parser grammar MetaParser;

options
{
    tokenVocab = MetaLexer; 
	generateCompiler=true;
}

main: namespaceDeclaration EOF;

$Name
name : identifier;

$Name
qualifiedName : qualifier;

$Qualifier
qualifier : identifier (TDot identifier)*;

$Property(Annotations)
$SymbolUse(MetaAnnotation)
annotation : TOpenBracket qualifier /*annotationParams?*/ TCloseBracket;

/*
annotationParams : TOpenParen annotationParamList? TCloseParen;
annotationParamList : annotationParam (TComma annotationParam)*;

$Property(Properties)
$SymbolDef(MetaAnnotationProperty)
annotationParam : $Property(Name) name;
*/

$SymbolDef(symbolType=MetaNamespace,nestingProperty=Declarations,merge=true)
namespaceDeclaration: annotation* KNamespace qualifiedName namespaceBody;

$Scope
namespaceBody : TOpenBrace metamodelDeclaration declaration* TCloseBrace;

$Property(MetaModel)
$SymbolDef(MetaModel)
metamodelDeclaration: annotation* KMetamodel name (TOpenParen metamodelPropertyList? TCloseParen)? TSemicolon;

metamodelPropertyList : metamodelProperty (TComma metamodelProperty)*;

metamodelProperty : metamodelUriProperty;

$Property(Uri)
metamodelUriProperty : IUri TAssign $Value stringLiteral;

$Property(Declarations) 
declaration : enumDeclaration | classDeclaration | associationDeclaration | constDeclaration | externTypeDeclaration;

$SymbolDef(MetaEnum)
enumDeclaration : annotation* KEnum name enumBody;
$Scope
enumBody : TOpenBrace $Property(EnumLiterals) enumValues (TSemicolon enumMemberDeclaration*)? TCloseBrace;
enumValues : enumValue (TComma enumValue)*;
$SymbolDef(MetaEnumLiteral)
enumValue : annotation* name;
enumMemberDeclaration : $Property(Operations) operationDeclaration;

$SymbolDef(MetaClass)
classDeclaration : annotation* $Property(name=IsAbstract,value=true) KAbstract? KClass name (TColon $Property(SuperClasses) classAncestors)? classBody;
$Scope
classBody : TOpenBrace classMemberDeclaration* TCloseBrace;
classAncestors : classAncestor (TComma classAncestor)*;
classAncestor : $SymbolUse(symbolType=MetaClass,location=ResolutionLocation.Parent) qualifier;
classMemberDeclaration 
	: $Property(Properties) fieldDeclaration 
	| $Property(Operations) operationDeclaration
	;

$SymbolDef(MetaProperty)
fieldDeclaration : annotation* $Property(Kind) fieldModifier? $Property(Type) typeReference name redefinitionsOrSubsettings? TSemicolon;
fieldModifier 
	: $Value(MetaPropertyKind.Containment) KContainment 
	| $Value(MetaPropertyKind.Readonly) KReadonly 
	| $Value(MetaPropertyKind.Lazy) KLazy 
	| $Value(MetaPropertyKind.Derived) KDerived
	;

redefinitionsOrSubsettings : redefinitions | subsettings;
redefinitions : KRedefines $Property(RedefinedProperties) nameUseList?;
subsettings : KSubsets $Property(SubsettedProperties) nameUseList?;

$SymbolUse(MetaProperty)
nameUseList : qualifier (TComma qualifier)*;

$SymbolDef(MetaExternAlias)
externAliasDeclaration : KExtern KAlias name TSemicolon;

$SymbolUse(MetaType)
returnType : typeReference | voidType;
$SymbolUse(MetaType)
typeOfReference : typeReference;
$SymbolUse(MetaType)
typeReference : collectionType | simpleType;
$SymbolUse(MetaType)
simpleType : primitiveType | objectType | nullableType | classType;

$SymbolUse(symbolTypes=(MetaClass,MetaEnum))
classType : qualifier;

$Identifier
objectType 
	: KObject 
	| KSymbol
	| KString
	;

$Identifier
primitiveType 
	: KInt 
	| KLong 
	| KFloat 
	| KDouble 
	| KByte 
	| KBool
	;

$Identifier
voidType 
	: KVoid
	;

$SymbolCtr(MetaNullableType)
nullableType : $Property(InnerType) primitiveType TQuestion;

$SymbolCtr(MetaCollectionType)
collectionType : $Property(Kind) collectionKind TLessThan $Property(InnerType) simpleType TGreaterThan;
collectionKind 
	: $Value(MetaCollectionKind.Set) KSet 
	| $Value(MetaCollectionKind.List) KList
	| $Value(MetaCollectionKind.MultiSet) KMultiSet 
	| $Value(MetaCollectionKind.MultiList) KMultiList
	;

$SymbolDef(MetaOperation)
operationDeclaration : annotation* KStatic? $Property(ReturnType) returnType name TOpenParen $Property(Parameters) parameterList? TCloseParen TSemicolon;
parameterList : parameter (TComma parameter)*;

$SymbolDef(MetaParameter)
parameter : annotation* $Property(Type) typeReference name;

$Opposite
associationDeclaration : annotation* KAssociation $SymbolUse(MetaProperty) source=qualifier KWith $SymbolUse(MetaProperty) target=qualifier TSemicolon;


// Additional rules for lexer:

// Identifiers
$Identifier
identifier 
	: IdentifierNormal 
	| IdentifierVerbatim
	| IUri
	;

// Literals
literal 
    : nullLiteral
	| booleanLiteral
	| integerLiteral
	| decimalLiteral
	| scientificLiteral
    | stringLiteral
	;

// Null literal
$Value
nullLiteral : KNull;

// Boolean literals
$Value
booleanLiteral : KTrue | KFalse;

// Number literals
$Value
integerLiteral : LInteger;
$Value
decimalLiteral : LDecimal;
$Value
scientificLiteral : LScientific;

// String literals
$Value
stringLiteral : LRegularString;
