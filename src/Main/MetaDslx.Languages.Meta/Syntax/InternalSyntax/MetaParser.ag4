parser grammar MetaParser;

@header 
{
using MetaDslx.CodeAnalysis.Symbols;
using MetaDslx.Languages.Meta.Model;
}

options
{
    tokenVocab = MetaLexer; 
	generateCompiler=true;
}

main: usingNamespaceOrMetamodel* namespaceDeclaration EOF;

$Name
name : identifier;

$Name
qualifiedName : qualifier;

$Qualifier
qualifier : identifier (TDot identifier)*;

$Property(Attributes)
$Use(MetaAttribute)
attribute : TOpenBracket qualifier TCloseBracket;

usingNamespaceOrMetamodel: usingNamespace | usingMetamodel;

$Import
usingNamespace: KUsing (name TAssign)? qualifier TSemicolon;

$MetamodelImport
usingMetamodel: KUsing KMetamodel (name TAssign)? usingMetamodelReference TSemicolon;
usingMetamodelReference: qualifier | $Value stringLiteral;

$Define(type=MetaNamespace,nestingProperty=Declarations,merge=true)
namespaceDeclaration: attribute* KNamespace qualifiedName namespaceBody;

$Scope
namespaceBody : TOpenBrace usingNamespaceOrMetamodel* metamodelDeclaration declaration* TCloseBrace;

$Property(DefinedMetaModel)
$Define(MetaModel)
$Property(Documentation)
$Documentation
metamodelDeclaration: attribute* KMetamodel name (TOpenParen metamodelPropertyList? TCloseParen)? TSemicolon;

metamodelPropertyList : metamodelProperty (TComma metamodelProperty)*;

metamodelProperty : metamodelUriProperty | metamodelPrefixProperty | majorVersionProperty | minorVersionProperty;

$Property(Uri)
metamodelUriProperty : IUri TAssign $Value stringLiteral;
$Property(Prefix)
metamodelPrefixProperty : IPrefix TAssign $Value stringLiteral;
$Property(MajorVersion)
majorVersionProperty : IMajorVersion TAssign $Value integerLiteral;
$Property(MinorVersion)
minorVersionProperty : IMinorVersion TAssign $Value integerLiteral;

declaration : enumDeclaration | classDeclaration | associationDeclaration | constDeclaration;

$Property(Declarations)
$Define(MetaEnum)
$Property(Documentation)
$Documentation
enumDeclaration : attribute* KEnum name enumBody;
$Scope
enumBody : TOpenBrace $Property(EnumLiterals) enumValues (TSemicolon enumMemberDeclaration*)? TCloseBrace;
enumValues : enumValue (TComma enumValue)*;
$Define(MetaEnumLiteral)
$Property(Documentation)
$Documentation
enumValue : attribute* name;
enumMemberDeclaration : $Property(Operations) operationDeclaration;

$Property(Declarations)
$Define(MetaClass)
$Property(Documentation)
$Documentation
classDeclaration : attribute* symbolAttribute? $Property(name=IsAbstract,value=true) KAbstract? KClass name (TColon $Property(SuperClasses) classAncestors)? classBody;
$Property(SymbolType)
symbolAttribute : symbolSymbolAttribute | expressionSymbolAttribute | statementSymbolTypeAttribute | typeSymbolTypeAttribute;

$SymbolSymbol
symbolSymbolAttribute : TOpenBracket KSymbol TColon qualifier TCloseBracket;
$ExpressionSymbol
expressionSymbolAttribute : TOpenBracket KExpression TColon qualifier TCloseBracket;
$StatementSymbol
statementSymbolTypeAttribute : TOpenBracket KStatement TColon qualifier TCloseBracket;
$TypeSymbol
typeSymbolTypeAttribute : TOpenBracket KType TColon qualifier TCloseBracket;

$Scope
classBody : TOpenBrace classMemberDeclaration* TCloseBrace;
classAncestors : classAncestor (TComma classAncestor)*;
classAncestor : $Use(type=MetaClass) qualifier;
classMemberDeclaration 
	: $Property(Properties) fieldDeclaration 
	| $Property(Operations) operationDeclaration
	;

$Define(MetaProperty)
$Property(Documentation)
$Documentation
fieldDeclaration : attribute* fieldSymbolPropertyAttribute? fieldContainment? fieldModifier? $Property(Type) typeReference name defaultValue? redefinitionsOrSubsettings* TSemicolon;
$Property(SymbolProperty)
fieldSymbolPropertyAttribute : TOpenBracket KProperty TColon $SymbolProperty identifier TCloseBracket;
$Property(name=IsContainment,value=true)
fieldContainment : KContainment;
$Property(Kind)
fieldModifier 
	: $Value(MetaPropertyKind.Readonly) KReadonly 
	| $Value(MetaPropertyKind.Lazy) KLazy 
	| $Value(MetaPropertyKind.Derived) KDerived
	| $Value(MetaPropertyKind.DerivedUnion) KUnion
	;
$Property(DefaultValue)
defaultValue : TAssign $Value stringLiteral;

redefinitionsOrSubsettings : redefinitions | subsettings;
redefinitions : KRedefines $Property(RedefinedProperties) nameUseList?;
subsettings : KSubsets $Property(SubsettedProperties) nameUseList?;

$Use(MetaProperty)
nameUseList : qualifier (TComma qualifier)*;

$Property(Declarations)
$Define(MetaConstant)
constDeclaration : KConst $Property(Type) typeReference name TSemicolon;

$Use(MetaType)
returnType : typeReference | voidType;
$Use(MetaType)
typeOfReference : typeReference;
$Use(MetaType)
typeReference : collectionType | simpleType;
$Use(MetaType)
simpleType : primitiveType | objectType | nullableType | classType;

$Use(types=(MetaClass,MetaEnum))
classType : qualifier;

objectType 
	: $Value(MetaInstance.Object) KObject 
	| $Value(MetaInstance.ModelObject) KSymbol
	| $Value(MetaInstance.String) KString
	;

primitiveType 
	: $Value(MetaInstance.Int) KInt 
	| $Value(MetaInstance.Long) KLong 
	| $Value(MetaInstance.Float) KFloat 
	| $Value(MetaInstance.Double) KDouble 
	| $Value(MetaInstance.Byte) KByte 
	| $Value(MetaInstance.Bool) KBool
	;

voidType 
	: $Value(MetaInstance.Void) KVoid
	;

$Define(MetaNullableType)
nullableType : $Property(InnerType) primitiveType TQuestion;

$Define(MetaCollectionType)
collectionType : $Property(Kind) collectionKind TLessThan $Property(InnerType) simpleType TGreaterThan;
collectionKind 
	: $Value(MetaCollectionKind.Set) KSet 
	| $Value(MetaCollectionKind.List) KList
	| $Value(MetaCollectionKind.MultiSet) KMultiSet 
	| $Value(MetaCollectionKind.MultiList) KMultiList
	;
	
$Define(MetaOperation)
$Property(Documentation)
$Documentation
operationDeclaration : attribute* operationModifier* $Property(ReturnType) returnType name TOpenParen $Property(Parameters) parameterList? TCloseParen TSemicolon;

operationModifier : operationModifierBuilder | operationModifierReadonly;
$Property(name=IsBuilder,value=true) 
operationModifierBuilder : KBuilder;
$Property(name=IsReadonly,value=true)
operationModifierReadonly : KReadonly;

parameterList : parameter (TComma parameter)*;

$Define(MetaParameter)
parameter : attribute* $Property(Type) typeReference name;

$Symbol(AssociationSymbol)
associationDeclaration : attribute* KAssociation $Property(Left) $Use(MetaProperty) source=qualifier KWith $Property(Right) $Use(MetaProperty) target=qualifier TSemicolon;


// Additional rules for lexer:

// Identifiers
$Identifier
identifier 
	: IdentifierNormal 
	| IdentifierVerbatim
	| IUri
	| IPrefix
	| IMajorVersion
	| IMinorVersion
	;

// Literals
literal 
    : nullLiteral
	| booleanLiteral
	| integerLiteral
	| decimalLiteral
	| scientificLiteral
    | stringLiteral
	;

// Null literal
$Value
nullLiteral : KNull;

// Boolean literals
$Value
booleanLiteral : KTrue | KFalse;

// Number literals
$Value
integerLiteral : LInteger;
$Value
decimalLiteral : LDecimal;
$Value
scientificLiteral : LScientific;

// String literals
$Value
stringLiteral : LRegularString;
