parser grammar CompilerParser;

@header 
{
using MetaDslx.Languages.Compiler.Model;
}

options
{
    tokenVocab = CompilerLexer; 
	generateCompiler=true;
}

main: namespaceDeclaration EOF;

$Property(Annotations) 
$Define(Annotation)
annotation: TOpenBracket name TCloseBracket;

$Define(type=Namespace,nestingProperty=Members,merge=true)
namespaceDeclaration: KNamespace qualifiedName TSemicolon namespaceBody;

$Scope
namespaceBody: usingDeclaration* grammarDeclaration;

$Property(Members) 
$Define(Grammar)
grammarDeclaration: annotation* KGrammar name TSemicolon $Scope ruleDeclarations;

$Import
usingDeclaration: KUsing (name TAssign)? qualifier TSemicolon;

ruleDeclarations: ruleDeclaration*;

$Property(Rules) 
ruleDeclaration: parserRuleDeclaration | lexerRuleDeclaration;

parserRuleDeclaration: parserRuleAlt | parserRuleSimple;

$Define(ParserRuleAlt)
parserRuleAlt: annotation* parserRuleName (KDefines $Property(DefinedModelObject) $Use(System.Type) qualifier)? TColon parserRuleAltRef (TBar parserRuleAltRef)* TSemicolon;

$Property(Alternatives)
parserRuleAltRef: $Use(ParserRule) parserRuleIdentifier;

$Define(ParserRuleSimple)
parserRuleSimple: annotation* parserRuleName (KDefines $Property(DefinedModelObject) $Use(System.Type) qualifier)? TColon parserRuleNamedElement+ eofElement? TSemicolon;

$Property(Elements)
$Define(ParserRuleNamedElement)
$Property(Element)
$Define(ParserRuleEofElement)
eofElement: KEof;

$Property(Elements)
$Define(ParserRuleNamedElement)
parserRuleNamedElement: annotation* (elementName assign)? parserNegatedElement multiplicity?;

$Property(AssignmentOperator)
assign
	: $Value(AssignmentOperator.Assign) TAssign 
	| $Value(AssignmentOperator.QuestionAssign) TQuestionAssign 
	| $Value(AssignmentOperator.NegatedAssign) TNegatedAssign 
	| $Value(AssignmentOperator.PlusAssign) TPlusAssign
	;
$Property(Multiplicity)
multiplicity
	: $Value(Multiplicity.NonGreedyZeroOrOne) TNonGreedyZeroOrOne 
	| $Value(Multiplicity.NonGreedyZeroOrMore) TNonGreedyZeroOrMore 
	| $Value(Multiplicity.NonGreedyOneOrMore) TNonGreedyOneOrMore 
	| $Value(Multiplicity.ZeroOrOne) TZeroOrOne 
	| $Value(Multiplicity.ZeroOrMore) TZeroOrMore 
	| $Value(Multiplicity.OneOrMore) TOneOrMore
	;

parserNegatedElement: $Property(name=IsNegated,value=true) TNegate? parserRuleElement;

$Property(Element)
parserRuleElement: parserRuleFixedElement | parserRuleReference | parserRuleWildcardElement | parserRuleBlockElement;

$Define(ParserRuleFixedElement)
parserRuleFixedElement: annotation* $Property(Value) stringLiteral;

$Define(ParserRuleWildcardElement)
parserRuleWildcardElement: annotation* TDot;

$Define(ParserRuleReferenceElement)
parserRuleReference: annotation* $Property(Rule) $Use(Rule) identifier;

$Define(ParserRuleBlockElement)
parserRuleBlockElement: annotation* TOpenParen parserRuleNamedElement+ TCloseParen;

$Define(LexerRule)
lexerRuleDeclaration: annotation* modifier=($Property(name=IsHidden,value=true) KHidden | $Property(name=IsFragment,value=true) KFragment)? lexerRuleName (KReturns $Property(ValueType) $Use(System.Type) qualifier)? TColon lexerRuleAlternative (TBar lexerRuleAlternative)* TSemicolon;

$Property(Alternatives)
$Define(LexerRuleAlternative)
lexerRuleAlternative: lexerRuleAlternativeElement+;

$Property(Elements)
$Define(LexerRuleAlternativeElement)
lexerRuleAlternativeElement: $Property(name=IsNegated,value=true) TNegate? lexerRuleElement multiplicity?;

$Property(Element)
lexerRuleElement: lexerRuleReferenceElement | lexerRuleFixedStringElement | lexerRuleFixedCharElement | lexerRuleWildcardElement | lexerRuleBlockElement | lexerRuleRangeElement;

$Define(LexerRuleReferenceElement)
lexerRuleReferenceElement: $Property(Rule) $Use(LexerRule) lexerRuleIdentifier;

$Define(LexerRuleWildcardElement)
lexerRuleWildcardElement: TDot;

$Define(LexerRuleFixedStringElement)
lexerRuleFixedStringElement: $Property(Value) $Value LString;

$Define(LexerRuleFixedCharElement)
lexerRuleFixedCharElement: $Property(Value) $Value LCharacter;

$Define(LexerRuleBlockElement)
lexerRuleBlockElement: TOpenParen lexerRuleAlternative (TBar lexerRuleAlternative)* TCloseParen;

$Define(LexerRuleRangeElement)
lexerRuleRangeElement: $Property(Start) start=lexerRuleFixedCharElement TDotDot $Property(End) end=lexerRuleFixedCharElement;

// Identifiers
$Name
name : identifier;

$Name
qualifiedName : qualifier;

$Qualifier
qualifier : identifier (TDot identifier)*;

$Identifier
identifier : LexerIdentifier | ParserIdentifier;

$Identifier
lexerRuleIdentifier : LexerIdentifier;

$Identifier
parserRuleIdentifier : ParserIdentifier;

$Name
$Identifier
lexerRuleName : LexerIdentifier;

$Name
$Identifier
parserRuleName : ParserIdentifier;

$Name
$Identifier
elementName : ParserIdentifier | IgnoredIdentifier;

// Literals
literal 
    : nullLiteral
	| booleanLiteral
	| integerLiteral
	| decimalLiteral
	| scientificLiteral
    | stringLiteral
	;

// Null literal
$Value
nullLiteral : KNull;

// Boolean literals
$Value
booleanLiteral : KTrue | KFalse;

// Number literals
$Value
integerLiteral : LInteger;

$Value
decimalLiteral : LDecimal;

$Value
scientificLiteral : LScientific;

// String literals
$Value
stringLiteral : LString;

$Value
charLiteral : LCharacter;

