parser grammar CoreParser;

@header 
{
using MetaDslx.CodeAnalysis.Symbols;
using MetaDslx.Languages.Core.Model;
}

options
{
    tokenVocab = CoreLexer; 
	generateCompiler=true;
}

$Define(Namespace)
$Scope
main: usingNamespace* declaration* mainBlock EOF;

$Define(BlockStatement)
$LocalScope
$Property(Statements) 
mainBlock: statement*;

$Import
usingNamespace: KUsing (name TAssign)? qualifier TSemicolon;

// Declarations

$Property(Members)
declaration: aliasDeclaration | enumDeclaration | structDeclaration | functionDeclaration;

$Define(Alias)
aliasDeclaration: KUsing name TAssign $Use(Declaration) qualifier;

$Define(EnumType)
enumDeclaration: KEnum name TOpenBrace enumLiteralList? TCloseBrace;
enumLiteralList: enumLiteral (TComma enumLiteral)*;
$Property(Members)
$Define(EnumLiteral)
enumLiteral: name;

$Define(StructType)
structDeclaration: KStruct name TOpenBrace structField* TCloseBrace;
$Property(Members)
$Define(Field)
structField: $Property(Type) typeReference name (TAssign $Property(DeclaredInitializer) expression)? TSemicolon;

$Define(Function)
functionDeclaration: functionResult name TOpenParen functionParameterList? TCloseParen $LocalScope $Property(Body) blockStatement;

$Property(Parameters)
functionParameterList : functionParameter (TComma functionParameter)*;
$Property(Parameters)
$Define(Parameter)
functionParameter : $Property(DeclaredType) typeReference name (TAssign $Property(DeclaredInitializer) expression)?;

$Property(Result) 
$Define(Parameter)
functionResult : $Property(DeclaredType) returnType;

// Statements

statement
	: TSemicolon #emptyStmt $Define(EmptyStatement)
	| blockStatement #blockStmt 
	| $Property(Expression) expression TSemicolon #exprStmt $Define(ExpressionStatement)
	| KForEach TOpenParen $Property(LoopControlVariable) variable=expression TColon $Property(Collection) collection=expression TCloseParen $Property(Body) statement #foreachStmt $Define(ForEachLoopStatement)
	| KFor TOpenParen $Property(Before) before=expressionList? semicolonBefore=TSemicolon $Property(Condition) condition=expression semicolonAfter=TSemicolon $Property(AtLoopBottom) atLoopBottom=expressionList? TCloseParen $Property(Body) statement #forStmt $Define(ForLoopStatement)
	| KIf TOpenParen $Property(Condition) condition=expression TCloseParen $Property(IfTrue) ifTrue=statement (KElse $Property(IfFalse) ifFalse=statement) #ifStmt $Define(IfStatement)
	| $Property(name=JumpKind,value=JumpKind.Break) KBreak TSemicolon #breakStmt $Define(JumpStatement)
	| $Property(name=JumpKind,value=JumpKind.Continue) KContinue TSemicolon #continueStmt $Define(JumpStatement)
	| $Property(name=JumpKind,value=JumpKind.GoTo) KGoto $Property(Target) $Use(Label) identifier TSemicolon #gotoStmt $Define(JumpStatement)
	| $Property(Label) $Define(Label) name TColon $Property(Statement) statement #labeledStmt $Define(LabeledStatement)
	| KLock TOpenParen $Property(LockedValue) lockedValue=expression TCloseParen $Property(Body) body=statement #lockStmt $Define(LockStatement)
	| KReturn $Property(ReturnedValue) returnedValue=expression TSemicolon #returnStmt $Define(ReturnStatement)
	| KSwitch TOpenParen $Property(Value) value=expression TCloseParen TOpenBrace switchCase* TCloseBrace #switchStmt $Define(SwitchStatement)
	| KTry $Property(Body) body=blockStatement catchClause* $Property(Finally) finallyClause? #tryStmt
	| usingHeader+ $Property(Body) body=statement #usingStmt $Define(UsingStatement)
	| KWhile TOpenParen $Property(name=ConditionIsTop,value=true) $Property(Condition) condition=expression TCloseParen $Property(Body) body=statement #whileStmt $Define(WhileLoopStatement)
	| KDo $Property(Body) body=statement KWhile TOpenParen $Property(name=ConditionIsTop,value=false) $Property(Condition) condition=expression TCloseParen TSemicolon #doWhileStmt $Define(WhileLoopStatement)
	;

$Define(BlockStatement)
$Property(Statements) 
blockStatement : TOpenBrace statement* TCloseBrace;
$Define(BlockStatement)
$Property(Statements) 
bareBlockStatement : statement+;

$Property(Cases)
$Define(SwitchCase)
switchCase: caseClause+ $Property(Body) bareBlockStatement;
$Property(Clauses) 
caseClause: singleValueCaseClause | defaultCaseClause; 
$Define(SingleValueCaseClause)
singleValueCaseClause: KCase $Property(Value) value=expression TColon;
$Define(DefaultCaseClause)
defaultCaseClause: KDefault TColon;

$Property(Catches)
$Define(CatchClause)
catchClause: KCatch (TOpenParen $Property(ExceptionDeclarationOrExpression) value=expression TCloseParen catchFilter?)? $Property(Handler) handler=blockStatement;
catchFilter: KWhen $Property(Filter) filter=expression;
finallyClause: KFinally handler=blockStatement;

usingHeader: KUsing TOpenParen $Property(Resources) resource=expression TCloseParen;

expressionList: expression (TComma expression)*;

// Expressions

expression
	: TOpenParen $Property(Operand) expression TCloseParen #parenthesizedExpr $Define(ParenthesizedExpression)
	| TOpenParen tupleArguments TCloseParen #tupleExpr $Define(TupleExpression)
	| KDiscard #discardExpr $Define(DiscardExpression)
	| KDefault #defaultExpr $Define(DefaultValueExpression)
	| KThis #thisExpr $Define(InstanceReferenceExpression)
	| KBase #baseExpr $Define(InstanceReferenceExpression)
	| $Property(Value) literal #literalExpr $Define(LiteralExpression)
	| name genericTypeArguments? #identifierExpr $Define(ReferenceExpression)
	| $Property(Qualifier) expression dotOperator name genericTypeArguments? #qualifierExpr $Define(ReferenceExpression)
	| $Property(Receiver) expression indexerOperator argumentList TCloseBracket #indexerExpr $Define(IndexerAccessExpression)
	| expression TOpenParen argumentList? TCloseParen #invocationExpr $Define(InvocationExpression)
	| KTypeof TOpenParen $Property(TypeOperand) typeReference TCloseParen #typeofExpr $Define(TypeOfExpression)
	| KNameof TOpenParen $Property(Argument) expression TCloseParen #nameofExpr $Define(NameOfExpression)
	| KSizeof TOpenParen $Property(TypeOperand) typeReference TCloseParen #sizeofExpr $Define(SizeOfExpression)
	| KChecked TOpenParen expression TCloseParen #checkedExpr
	| KUnchecked TOpenParen expression TCloseParen #uncheckedExpr
	| KNew $Property(ObjectType) typeReference TOpenParen argumentList? TCloseParen initializerExpression? #newExpr $Define(ObjectCreationExpression)
	| $Property(Operand) expression TExclamation #nullForgivingExpr $Define(NullForgivingExpression)
	| $Property(Operand) expression $Property(OperatorKind) postfixIncOrDecOperator #postfixIncOrDecExpr $Define(UnaryExpression)
	| $Property(OperatorKind) prefixIncOrDecOperator $Property(Operand) expression #prefixIncOrDecExpr $Define(UnaryExpression)
	| $Property(OperatorKind) unaryOperator $Property(Operand) expression #unaryExpr $Define(UnaryExpression)
	| TOpenParen $Property(TargetType) typeReference TCloseParen $Property(Operand) expression #typeCastExpr $Define(ConversionExpression)
	| KAwait $Property(Operation) expression #awaitExpr $Define(AwaitExpression)
	| $Property(LeftOperand) left=expression $Property(OperatorKind) $Value(BinaryOperatorKind.Range) TDotDot $Property(RightOperand) right=expression #rangeExpr $Define(BinaryExpression)
	| $Property(LeftOperand) left=expression $Property(OperatorKind) multiplicativeOperator $Property(RightOperand) right=expression #multExpr $Define(BinaryExpression)
	| $Property(LeftOperand) left=expression $Property(OperatorKind) additiveOperator $Property(RightOperand) right=expression #addExpr $Define(BinaryExpression)
	| $Property(LeftOperand) left=expression $Property(OperatorKind) shiftOperator $Property(RightOperand) right=expression #shiftExpr $Define(BinaryExpression)
	| $Property(LeftOperand) left=expression $Property(OperatorKind) relationalOperator $Property(RightOperand) right=expression #relExpr $Define(BinaryExpression)
	| $Property(ValueOperand) expression KIs $Property(name=IsNegated,value=true) KNot? $Property(TypeOperand) typeReference ($Property(DeclaredVariable) $Define(Variable) name)? #typeIsExpr $Define(IsTypeExpression)
	| $Property(Operand) expression KAs $Property(TargetType) typeReference #typeAsExpr $Define(ConversionExpression) $Property(name=IsTryCast,value=true)
	| $Property(LeftOperand) left=expression $Property(OperatorKind) equalityOperator $Property(RightOperand) right=expression #eqExpr $Define(BinaryExpression)
	| $Property(LeftOperand) left=expression $Property(OperatorKind) $Value(BinaryOperatorKind.BitwiseAnd) TAmpersand $Property(RightOperand) right=expression #andExpr $Define(BinaryExpression)
	| $Property(LeftOperand) left=expression $Property(OperatorKind) $Value(BinaryOperatorKind.BitwiseXor) THat $Property(RightOperand) right=expression #xorExpr $Define(BinaryExpression)
	| $Property(LeftOperand) left=expression $Property(OperatorKind) $Value(BinaryOperatorKind.BitwiseOr) TBar $Property(RightOperand) right=expression #orExpr $Define(BinaryExpression)
	| $Property(LeftOperand) left=expression $Property(OperatorKind) $Value(BinaryOperatorKind.LogicalAnd) TAndAlso $Property(RightOperand) right=expression #andAlsoExpr $Define(BinaryExpression)
	| $Property(LeftOperand) left=expression $Property(OperatorKind) $Value(BinaryOperatorKind.LogicalOr) TOrElse $Property(RightOperand) right=expression #orElseExpr $Define(BinaryExpression)
	| KThrow $Property(Exception) expression #throwExpr $Define(ThrowExpression)
	| $Property(Value) value=expression TQuestionQuestion $Property(WhenNull) whenNull=expression #coalExpr $Define(CoalesceExpression)
	| $Property(Condition) condition=expression TQuestion $Property(WhenTrue) whenTrue=expression TColon $Property(WhenFalse) whenFalse=expression #condExpr $Define(ConditionalExpression)
	| $Property(Target) target=expression TAssign $Property(Value) value=expression #assignExpr $Define(AssignmentExpression)
	| $Property(Target) target=expression $Property(OperatorKind) compoundAssignmentOperator $Property(Value) value=expression #compAssignExpr $Define(CompoundAssignmentExpression)
	| lambdaSignature TArrow lambdaBody #lambdaExpr $Define(LambdaExpression)
	| $Property(name=IsConst,value=true) KConst? $Property(DeclaredType) variableType variableDefList #varDefExpr $Define(VariableDeclarationExpression)
	;

$Property(Arguments)
tupleArguments : argumentExpression TComma argumentList;
$Property(Arguments)
argumentList: argumentExpression (TComma argumentExpression)*;
$Define(Argument)
argumentExpression: (name TColon)? $Property(Value) expression;

initializerExpression
	: fieldInitializerExpressions
	| collectionInitializerExpressions
	| dictionaryInitializerExpressions
	;

fieldInitializerExpressions: fieldInitializerExpression (TComma fieldInitializerExpression)*;
$Define(AssignmentExpression)
fieldInitializerExpression: $Property(Target) $Use(FieldLikeMember) identifier TAssign $Property(Value) expression;
collectionInitializerExpressions: expression (TComma expression)*;
dictionaryInitializerExpressions: dictionaryInitializerExpression (TComma dictionaryInitializerExpression)*;
dictionaryInitializerExpression: TOpenBracket identifier TCloseBracket TAssign expression;

lambdaSignature: implicitLambdaSignature | explicitLambdaSignature;
implicitLambdaSignature : implicitParameter | implicitParameterList;
$Property(Parameters)
implicitParameterList : TOpenParen implicitParameter (TComma implicitParameter)* TCloseParen;
$Property(Parameters)
$Define(Parameter)
implicitParameter : name;

explicitLambdaSignature : explicitParameterList;
$Property(Parameters)
explicitParameterList : TOpenParen explicitParameter (TComma explicitParameter)* TCloseParen;
$Property(Parameters)
$Define(Parameter)
explicitParameter : $Property(Type) typeReference name;

$Property(Body)
lambdaBody: $Define(ExpressionStatement) $Property(Expression) expression | blockStatement;

variableDefList: variableDef (TComma variableDef)*;
$Property(Variables)
$Define(Variable)
variableDef: name (TAssign $Property(DeclaredInitializer) initializer=expression)?;

dotOperator
	: TDot
	| $Property(name=IsNullConditional,value=true) TQuestionDot
	;

indexerOperator
	: TOpenBracket
	| $Property(name=IsNullConditional,value=true) TQuestionOpenBracket
	;

postfixIncOrDecOperator
	: $Value(UnaryOperatorKind.PostfixIncrement) TPlusPlus
	| $Value(UnaryOperatorKind.PostfixDecrement) TMinusMinus
	;

prefixIncOrDecOperator
	: $Value(UnaryOperatorKind.PrefixIncrement) TPlusPlus
	| $Value(UnaryOperatorKind.PrefixDecrement) TMinusMinus
	;

unaryOperator
	: $Value(UnaryOperatorKind.UnaryPlus) TPlus
	| $Value(UnaryOperatorKind.UnaryMinus) TMinus
	| $Value(UnaryOperatorKind.LogicalNegation) TExclamation
	| $Value(UnaryOperatorKind.BitwiseComplement) TTilde
	| $Value(UnaryOperatorKind.IndexFromEnd) THat
	;

multiplicativeOperator
	: $Value(BinaryOperatorKind.Multiplication) TAsterisk
	| $Value(BinaryOperatorKind.Division) TSlash
	| $Value(BinaryOperatorKind.Remainder) TPercent
	;

$Property(OperatorKind)
additiveOperator
	: $Value(BinaryOperatorKind.Addition) TPlus
	| $Value(BinaryOperatorKind.Subtraction) TMinus
	;

shiftOperator
	: leftShiftOperator
	| rightShiftOperator
	;
$Value(BinaryOperatorKind.LeftShift)
leftShiftOperator: first=TLessThan second=TLessThan;
$Value(BinaryOperatorKind.RightShift)
rightShiftOperator: first=TLessThan second=TLessThan;

relationalOperator
	: $Value(BinaryOperatorKind.LessThan) TLessThan
	| $Value(BinaryOperatorKind.GreaterThan) TGreaterThan
	| $Value(BinaryOperatorKind.LessThanOrEqual) TLessThanOrEqual
	| $Value(BinaryOperatorKind.GreaterThanOrEqual) TGreaterThanOrEqual
	;

equalityOperator
	: $Value(BinaryOperatorKind.Equal) TEqual
	| $Value(BinaryOperatorKind.NotEqual) TNotEqual
	;

compoundAssignmentOperator
	: $Value(BinaryOperatorKind.Addition) TPlusAssign
	| $Value(BinaryOperatorKind.Subtraction) TMinusAssign
	| $Value(BinaryOperatorKind.Multiplication) TAsteriskAssign
	| $Value(BinaryOperatorKind.Division) TSlashAssign
	| $Value(BinaryOperatorKind.Remainder) TPercentAssign
	| $Value(BinaryOperatorKind.LogicalAnd) TAmpersandAssign
	| $Value(BinaryOperatorKind.LogicalXor) THatAssign
	| $Value(BinaryOperatorKind.LogicalOr) TBarAssign
	| $Value(BinaryOperatorKind.LeftShift) TLeftShiftAssign
	| $Value(BinaryOperatorKind.RightShift) TRightShiftAssign
	;


// Type references

returnType : typeReference | voidType;

variableType : typeReference | varType;

$Use(DataType)
typeReference 
	: primitiveType #primitiveTypeRef
	| $Property(ReferencedType) namedType genericTypeArguments #genericTypeRef $Define(GenericTypeReference)
	| qualifier #namedTypeRef $Use(types=(ClassifierType,EnumType,DelegateType))
	| $Property(ElementType) typeReference TOpenBracket TCloseBracket #arrayTypeRef $Define(ArrayType)
	| $Property(InnerType) typeReference TQuestion #nullableTypeRef;

$Use(types=(ClassifierType,EnumType,DelegateType))
namedType : qualifier;

$Property(TypeArguments)
genericTypeArguments : TLessThan genericTypeArgument (TComma genericTypeArgument)* TGreaterThan;
genericTypeArgument : typeReference;

primitiveType
	: $Value(CoreInstance.Object) KObject 
	| $Value(CoreInstance.Boolean) KBool
	| $Value(CoreInstance.Char) KChar
	| $Value(CoreInstance.SByte) KSByte
	| $Value(CoreInstance.Byte) KByte
	| $Value(CoreInstance.Int16) KShort
	| $Value(CoreInstance.UInt16) KUShort
	| $Value(CoreInstance.Int32) KInt
	| $Value(CoreInstance.UInt32) KUInt
	| $Value(CoreInstance.Int64) KLong
	| $Value(CoreInstance.UInt64) KULong 
	| $Value(CoreInstance.Decimal) KDecimal
	| $Value(CoreInstance.Single) KFloat
	| $Value(CoreInstance.Double) KDouble 
	| $Value(CoreInstance.String) KString
	;

$Value(CoreInstance.Void) 
voidType : KVoid;

$Value(CoreInstance.VarType) 
varType : KVar;

// Additional rules for lexer:

// Identifiers
$Name
name : identifier;

$Name
qualifiedName : qualifier;

$Qualifier
qualifier : identifier (TDot identifier)*;

$Identifier
identifier 
	: IdentifierNormal 
	| IdentifierVerbatim
	;

// Literals
literal 
    : nullLiteral
	| booleanLiteral
	| integerLiteral
	| decimalLiteral
	| scientificLiteral
    | stringLiteral
	;

// Null literal
$Value
nullLiteral : KNull;

// Boolean literals
$Property(name=Type,value=CoreInstance.Boolean)
$Value
booleanLiteral : KTrue | KFalse;

// Number literals
$Property(name=Type,value=CoreInstance.Int32)
$Value
integerLiteral : LInteger;
$Property(name=Type,value=CoreInstance.Decimal)
$Value
decimalLiteral : LDecimal;
$Property(name=Type,value=CoreInstance.Double)
$Value
scientificLiteral : LScientific;

// String literals
$Property(name=Type,value=CoreInstance.String)
$Value
stringLiteral : LRegularString;
